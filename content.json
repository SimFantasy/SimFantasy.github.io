{"meta":{"title":"SimFantasy","subtitle":"","description":"Stay hungry, stay foolish","author":"Simz","url":"http://example.com","root":"/"},"posts":[{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"redux-toolkit","slug":"redux-toolkit","permalink":"http://example.com/tags/redux-toolkit/"},{"name":"zustand","slug":"zustand","permalink":"http://example.com/tags/zustand/"},{"name":"valtio","slug":"valtio","permalink":"http://example.com/tags/valtio/"}],"title":"React状态横评","date":"2023/10/05","text":"从Redux说起吐槽：Redux是React绕不过的坑，一个据说不是React专属的状态库（现在大部分js框架都是全家桶的年代），大量模板代码，过于复杂的学习曲线，总让我们感到困扰。 一个点击计数的state，在Redux中通常需要写store/index.js，store/reducer.js，store/actionCreator.js，store/constants.js四个文件，然后在全局通过Provider进行连接，在调用的页面还需要通过connect高阶进行包裹，然后通过props来映射，才能使用。 异步操作还需要通过第三方redux-thunk或redux-saga来实现。 所以对于这种时常会用到时常会用到但又不想去用的东西我们总是又爱又恨。好在React的生态是丰富的，总会有更多的好用的工具出现。 下面我们来看下现在比较流行的RTK和Zustand，以及我比较喜欢的Valtio，通过一个相同的案例（多个状态统一管理、本地计数、异步数据、异步数据传参）对这三个状态库在功能层面上进行比较下，看下各自的优缺点。 实现方式：通过三个文件来写本地计数store/modules/counter.js，异步获取数据store/modules/post.js，异步数据传参store/modules/user.js。通过store/index.js来对多个状态进行统一管理导出。 最终实现效果： Redux的升级RTK（Redux Tool Kit）RTK可以说是Redux老酒换新瓶，在一定程度上减少了模板代码和实现步骤。有亮点也有槽点，下面我们开始来构建上述中实现方式的三个store。 创建store1234567891011121314151617181920// store-reduxtoolkit/modules/counter.jsimport &#123; createSlice &#125; from &#x27;@reduxjs/toolkit&#x27;const counterSlice = createSlice(&#123; name: &#x27;counter&#x27;, initialState: &#123; value: 88 &#125;, reducers: &#123; increment: state =&gt; &#123; state.value += 1 &#125;, decrement: state =&gt; &#123; state.value -= 1 &#125; &#125;&#125;)export const &#123; increment, decrement &#125; = counterSlice.actionsexport default counterSlice.reducer 相比老版的Redux可以说精简了很多模板代码了，把reducer和actionCreator都放到了一起，没有使用constants了，可谓肉眼可见的进步，但是就是这样的代码在这三个状态库中是写的最多的一个。 让我们在来看异步获取数据。 12345678910111213141516171819202122232425262728293031// store-reduxtoolkit/modules/post.jsimport &#123; createSlice, createAsyncThunk &#125; from &#x27;@reduxjs/toolkit&#x27;export const fetchPosts = createAsyncThunk(&#x27;posts/fetchPosts&#x27;, async () =&gt; &#123; const response = await fetch(&#x27;https://gorest.co.in/public/v2/posts?per_page=5&#x27;) return response.json()&#125;)const postsSlice = createSlice(&#123; name: &#x27;posts&#x27;, initialState: &#123; posts: [], status: null &#125;, reducers: &#123;&#125;, extraReducers: builder =&gt; &#123; builder .addCase(fetchPosts.pending, (state, action) =&gt; &#123; state.status = &#x27;loading&#x27; &#125;) .addCase(fetchPosts.fulfilled, (state, &#123; payload &#125;) =&gt; &#123; state.status = &#x27;success&#x27; state.posts = payload &#125;) .addCase(fetchPosts.rejected, (state, action) =&gt; &#123; state.status = &#x27;failed&#x27; &#125;) &#125;&#125;)export default postsSlice.reducer 这一块其实比之前老版Redux只是做了Redux-thunk的整合，但是感觉又不是那么好用。 之前有另外一种写法，在createAsyncThunk中不直接return，而是在createSlice中添加修改状态的action，然后在createAsyncThunk中通过dispatch action来直接修改状态，但是这个官方不太推荐。根据官方的写法，就是上面的builder的写法。可以发现代码一下又变得复杂了，大多数情况下很多人是不会写pending和rejected的builder。 接下来是异步传参的，写法和异步获取数据类似，只是在thunk中需要传个参数。 12345678910111213141516171819202122232425262728293031// store-reduxtoolkit/modules/user.jsimport &#123; createSlice, createAsyncThunk &#125; from &#x27;@reduxjs/toolkit&#x27;export const fetchUsers = createAsyncThunk(&#x27;users/fetchUsers&#x27;, async page =&gt; &#123; const response = await fetch(`https://gorest.co.in/public/v2/users?page=$&#123;page&#125;&amp;per_page=5`) return response.json()&#125;)const usersSlice = createSlice(&#123; name: &#x27;users&#x27;, initialState: &#123; users: [], status: null &#125;, reducers: &#123;&#125;, extraReducers: builder =&gt; &#123; builder .addCase(fetchUsers.pending, (state, action) =&gt; &#123; state.status = &#x27;loading&#x27; &#125;) .addCase(fetchUsers.fulfilled, (state, &#123; payload &#125;) =&gt; &#123; state.status = &#x27;success&#x27; state.users = payload &#125;) .addCase(fetchUsers.rejected, (state, action) =&gt; &#123; state.status = &#x27;failed&#x27; &#125;) &#125;&#125;)export default usersSlice.reducer 如果需要放到一起最后来看下如何对多个状态库统一管理导出使用。RTK有点不好的话就是模式太固定，如果只有一个状态库时，也需要这样写，将单个状态库放到configureStore中。 1234567891011121314import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27;import counterReducer from &#x27;./modules/counter&#x27;import postsReducer from &#x27;./modules/post&#x27;import usersReducer from &#x27;./modules/user&#x27;const store = configureStore(&#123; reducer: &#123; counter: counterReducer, posts: postsReducer, users: usersReducer &#125;&#125;)export default store 这个基本和老版本一样，只是使用的方法不一样，没啥好说的。 在使用状态库的调整上我觉得才是RTK改进的比较多的一块，结束了之前老版本的通过props来做映射的写法，让代码简单了太多，之前总为一个方法称要想几个方法名称，而只是方法在不同调用下的不同名称而已，什么getUser、changeUser，dispatchUser。 需要注意的是，在使用RTK还是需要在入口文件上使用Provider来透传store以达到共享store的目的。 1234567891011import &#123; Provider &#125; from &#x27;react-redux&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import App from &#x27;@/App.jsx&#x27;import &#x27;@/index.css&#x27;import store from &#x27;@/store-redux&#x27;ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;) 使用state在需要使用store的页面上，RTK可以通过react-redux的hook来对store的状态和方法进行调用。 使用useSelector对store中的状态进行获取。需要注意使用的时，注意store库名称的的区别。如：count: state.counter.value中count是提供当前页面解构时使用的状态名称，后面state.counter.value中counter是在store中统一导出时的命名，value是counter状态库中的状态值。 使用useDispatch这个hook来调用store中的方法。如： dispatch(fetchPosts()) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// pages/reduxtoolkit-page.jsximport &#123; useState, useEffect, useCallback, memo &#125; from &#x27;react&#x27;import &#123; useDispatch, useSelector, shallowEqual &#125; from &#x27;react-redux&#x27;import cx from &#x27;clsx&#x27;import &#123; increment, decrement &#125; from &#x27;@/store-redux/modules/counter&#x27;import &#123; fetchPosts &#125; from &#x27;@/store-redux/modules/post&#x27;import &#123; fetchUsers &#125; from &#x27;@/store-redux/modules/user&#x27;const ReduxPage = () =&gt; &#123; const dispatch = useDispatch() const [page, setPage] = useState(1) // 获取状态，通过shallowEqual来进行比较，控制在状态数据发生变化时组件是否需要重新渲染 const &#123; count, posts, postState, users, userState &#125; = useSelector( state =&gt; (&#123; count: state.counter.value, posts: state.posts.posts, postState: state.posts.status, users: state.users.users, userState: state.users.status &#125;), shallowEqual ) // 调用store中异步方法发起posts请求 useEffect(() =&gt; &#123; dispatch(fetchPosts()) &#125;, [dispatch]) // 通过传入page参数调用store中的异步方法发起users请求 useEffect(() =&gt; &#123; dispatch(fetchUsers(page)) &#125;, [dispatch, page]) // 调用store中本地计数增加方法 const handleAdd = useCallback(() =&gt; &#123; dispatch(increment()) &#125;, [dispatch]) // 调用store中本地计数减少方法 const handleSub = useCallback(() =&gt; &#123; dispatch(decrement()) &#125;, [dispatch]) // 点击向前翻页 Users page 减少的方法 const handlePagePrev = useCallback(() =&gt; &#123; if (page &gt; 1) &#123; setPage(page - 1) &#125; &#125;, [page]) // 点击向后翻页 Users page 数增加的方法 const handlePageNext = useCallback(() =&gt; &#123; setPage(page + 1) &#125;, [page]) return ( &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;h1 className=&#x27;text-gray-400&#x27;&gt;Redux Page&lt;/h1&gt; //本地计数 &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Count: &#123;count&#125;&lt;/h2&gt; &lt;div className=&#x27;flex justify-start items-center gap-6 h-12&#x27;&gt; &lt;button onClick=&#123;handleAdd&#125; className=&#x27;px-6 py-2 bg-green-500 text-lg text-white rounded-lg&#x27; &gt; Add &lt;/button&gt; &lt;button onClick=&#123;handleSub&#125; className=&#x27;px-6 py-2 bg-red-500 text-lg text-white rounded-lg&#x27; &gt; Sub &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; // 获取Posts &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Posts&lt;/h2&gt; &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &#123;postState === &#x27;loading&#x27; &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;&#125; &#123;postState === &#x27;error&#x27; &amp;&amp; &lt;p&gt;Error&lt;/p&gt;&#125; &#123;postState === &#x27;success&#x27; &amp;&amp; ( &lt;div className=&#x27;flex flex-col gap-4&#x27;&gt; &#123;posts?.map(post =&gt; ( &lt;div key=&#123;post.id&#125; className=&#x27;flex flex-col gap-2 border-b border-dashed border-gray-200 pb-4&#x27; &gt; &lt;h3 className=&#x27;text-lg font-semibold line-clamp-1&#x27;&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p className=&#x27;text-gray-400 line-clamp-2&#x27;&gt;&#123;post.body&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125; &lt;/div&gt; &lt;/div&gt; // 获取Users &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Users&lt;/h2&gt; &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &#123;userState === &#x27;loading&#x27; &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;&#125; &#123;userState === &#x27;error&#x27; &amp;&amp; &lt;p&gt;Error&lt;/p&gt;&#125; &#123;userState === &#x27;success&#x27; &amp;&amp; ( &lt;div className=&#x27;flex flex-col gap-4&#x27;&gt; &#123;users?.map(user =&gt; ( &lt;div key=&#123;user.id&#125; className=&#x27;flex flex-col gap-2 border border-gray-200 rounded p-4&#x27; &gt; &lt;h3 className=&#x27;text-lg font-semibold line-clamp-1&#x27;&gt;&#123;user.name&#125;&lt;/h3&gt; &lt;p className=&#x27;text-gray-400&#x27;&gt;&#123;user.email&#125;&lt;/p&gt; &lt;p className=&#x27;text-gray-400&#x27;&gt;&#123;user.gender&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center gap-6 h-12&#x27;&gt; &lt;button onClick=&#123;handlePagePrev&#125; className=&#123;cx( &#x27;px-6 py-2 text-lg text-white rounded-lg&#x27;, &#123; &#x27; bg-green-500&#x27;: page &gt; 1 &#125;, &#123; &#x27;bg-gray-200&#x27;: page === 1 &#125; )&#125; disabled=&#123;page === 1&#125; &gt; 上一页 &lt;/button&gt; &lt;button onClick=&#123;handlePageNext&#125; className=&#x27;px-6 py-2 bg-green-500 text-lg text-white rounded-lg&#x27; &gt; 下一页 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default memo(ReduxPage) 页面代码使用tailwindcss来写的，看上去UI代码会有点多，其实内容还是很简单的，做了简单模块注释说明。 RTK使用下来会比Redux精简很多，但是写法和模板代码依旧很死板。 最近比较流行的ZustandZustand是最近逐渐流行的一个状态库，一个使用Redux方式打败Redux的状态库。这个作者还写另外两个状态库Jotai和Valtio。Zustand对标Redux，Jotai对标Recoil，Valtio使用的是proxy的方式，使用上有些类似mobx，但又不完全是。 zustand优势和特点不在这里赘述，直接去官网查看：Zustand官网文档，我们仅在代码层面来比较各自的优势和特点。 创建store123456// store-zustand/modules/counter.jsexport const createCounterSlice = set =&gt; (&#123; count: 77, increment: () =&gt; set(state =&gt; (&#123; count: state.count + 1 &#125;)), decrement: () =&gt; set(state =&gt; (&#123; count: state.count - 1 &#125;))&#125;) 可以发现在与RTK创建的counter store 近20行代码对比，zustand竟然只有6行。 123456789101112131415// store-zustand/modules/post.jsimport computed from &#x27;zustand-computed&#x27;export const createPostSlice = computed( set =&gt; (&#123; posts: [], fetchPosts: async () =&gt; &#123; const response = await fetch(&#x27;https://gorest.co.in/public/v2/posts?per_page=5&#x27;) set(&#123; posts: await response.json() &#125;) &#125; &#125;), state =&gt; (&#123; postsCount: state.posts.length &#125;)) 继续来看有异步请求的post store，redux的麻烦写法有差不多近30行，zustand也只有一半的代码量。如果去掉这个computed的代码，代码大概7、8行而已。只有RTK的三、四分之一。 代码中还增加了一个computed的中间件，用来计算获取到的posts数量。而RTK是不具备这个功能的，中间件也是zustand的一个特点，后面我们也会一起来看下zustand的中间件的使用和一些常用中间件。 123456789// store-zustand/modules/user.jsexport const createUserSlice = set =&gt; (&#123; users: [], fetchUsers: async page =&gt; &#123; const response = await fetch(`https://gorest.co.in/public/v2/users?page=$&#123;page&#125;&amp;per_page=5`) set(&#123; users: await response.json() &#125;) &#125;&#125;) 与post store类似，这里就可以看出代码量的区别了。 状态库统一导出。 1234567891011// store-zustand/index.jsimport &#123; create &#125; from &#x27;zustand&#x27;import &#123; createCounterSlice &#125; from &#x27;./modules/counter&#x27;import &#123; createPostSlice &#125; from &#x27;./modules/post&#x27;import &#123; createUserSlice &#125; from &#x27;./modules/user&#x27;export const useZustandStore = create((...a) =&gt; (&#123; ...createCounterSlice(...a), ...createPostSlice(...a), ...createUserSlice(...a)&#125;)) 这里应该是说zustand在写法上做了一个取巧吧，一般情况下创建一个store的代码如下： 1234567import &#123; create &#125; from &#x27;zustand&#x27;const useStore = create((set) =&gt; (&#123; bears: 0, increasePopulation: () =&gt; set((state) =&gt; (&#123; bears: state.bears + 1 &#125;)), removeAllBears: () =&gt; set(&#123; bears: 0 &#125;),&#125;)) zustand都是通过create方法来创建一个store hooks，而有多个状态库需要统一管理的情况下，只是把内部的方法拿了出来，在统一导入进来。 使用state123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// pages/zustand-page.jsximport &#123; useState, useEffect, useCallback, memo, Suspense &#125; from &#x27;react&#x27;import cx from &#x27;clsx&#x27;import &#123; useZustandStore &#125; from &#x27;@/store-zustand&#x27;const ZustandPage = () =&gt; &#123; const [page, setPage] = useState(1) const count = useZustandStore(state =&gt; state.count) const increment = useZustandStore(state =&gt; state.increment) const decrement = useZustandStore(state =&gt; state.decrement) const posts = useZustandStore(state =&gt; state.posts) const fetchPosts = useZustandStore(state =&gt; state.fetchPosts) const users = useZustandStore(state =&gt; state.users) const fetchUsers = useZustandStore(state =&gt; state.fetchUsers) const postsCount = useZustandStore(state =&gt; state.postsCount) useEffect(() =&gt; &#123; fetchPosts() &#125;, [fetchPosts]) useEffect(() =&gt; &#123; fetchUsers(page) &#125;, [fetchUsers, page]) const handleAdd = useCallback(() =&gt; &#123; increment() &#125;, [increment]) const handleSub = useCallback(() =&gt; &#123; decrement() &#125;, [decrement]) const handlePagePrev = useCallback(() =&gt; &#123; if (page &gt; 1) &#123; setPage(page - 1) &#125; &#125;, [page]) const handlePageNext = useCallback(() =&gt; &#123; setPage(page + 1) &#125;, [page]) return ( &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;h1 className=&#x27;text-gray-400&#x27;&gt;Zustand Page&lt;/h1&gt; &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Count: &#123;count&#125;&lt;/h2&gt; &lt;div className=&#x27;flex justify-start items-center gap-6 h-12&#x27;&gt; &lt;button onClick=&#123;handleAdd&#125; className=&#x27;px-6 py-2 bg-green-500 text-lg text-white rounded-lg&#x27; &gt; Add &lt;/button&gt; &lt;button onClick=&#123;handleSub&#125; className=&#x27;px-6 py-2 bg-red-500 text-lg text-white rounded-lg&#x27; &gt; Sub &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt; Posts &lt;small&gt;&#123;postsCount&#125;&lt;/small&gt; &lt;/h2&gt; &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;div className=&#x27;flex flex-col gap-4&#x27;&gt; &#123;!posts.length &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;&#125; &#123;posts?.map(post =&gt; ( &lt;div key=&#123;post.id&#125; className=&#x27;flex flex-col gap-2 border-b border-dashed border-gray-200 pb-4&#x27; &gt; &lt;h3 className=&#x27;text-lg font-semibold line-clamp-1&#x27;&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p className=&#x27;text-gray-400 line-clamp-2&#x27;&gt;&#123;post.body&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Users&lt;/h2&gt; &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;div className=&#x27;flex flex-col gap-4&#x27;&gt; &#123;!users.length &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;&#125; &#123;users?.map(user =&gt; ( &lt;div key=&#123;user.id&#125; className=&#x27;flex flex-col gap-2 border border-gray-200 rounded p-4&#x27;&gt; &lt;h3 className=&#x27;text-lg font-semibold line-clamp-1&#x27;&gt;&#123;user.name&#125;&lt;/h3&gt; &lt;p className=&#x27;text-gray-400&#x27;&gt;&#123;user.email&#125;&lt;/p&gt; &lt;p className=&#x27;text-gray-400&#x27;&gt;&#123;user.gender&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center gap-6 h-12&#x27;&gt; &lt;button onClick=&#123;handlePagePrev&#125; className=&#123;cx( &#x27;px-6 py-2 text-lg text-white rounded-lg&#x27;, &#123; &#x27; bg-green-500&#x27;: page &gt; 1 &#125;, &#123; &#x27;bg-gray-200&#x27;: page === 1 &#125; )&#125; disabled=&#123;page === 1&#125; &gt; 上一页 &lt;/button&gt; &lt;button onClick=&#123;handlePageNext&#125; className=&#x27;px-6 py-2 bg-green-500 text-lg text-white rounded-lg&#x27; &gt; 下一页 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default memo(ZustandPage) 在代码中我们可以看到在导出的状态和方法中，都是使用的单独的导出，这是为了确保状态和方法解耦，不受到其他状态的影响而造成不必要的多次渲染。但是可以使用shallow来进行处理，将状态写到一起 12345678const count = useZustandStore(state =&gt; state.count)const increment = useZustandStore(state =&gt; state.increment)const decrement = useZustandStore(state =&gt; state.decrement)const posts = useZustandStore(state =&gt; state.posts)const fetchPosts = useZustandStore(state =&gt; state.fetchPosts)const users = useZustandStore(state =&gt; state.users)const fetchUsers = useZustandStore(state =&gt; state.fetchUsers)const postsCount = useZustandStore(state =&gt; state.postsCount) 如果需要也可以写成这样，直接从store中解构出来，但这样会在各个状态变化时造成重复渲染(re-render)。 1const &#123;count, posts, users &#125; = useZustandStore(state =&gt;state.count) Zustand shallowshallow与RTK中的shallowEqual类似对数据进行比较，官方说明：如果你想构造一个内部有多个状态选择的对象，类似于Redux的 mapStateToProps ，你可以告诉Zustand，你希望通过传递相等函数来浅层比较对象。 写法上可以使用数组和对象的方式来使用： 1234567891011121314// 数组方式const [posts, users, count] = useZustandStore( state =&gt; [state.posts, state.users, state.count], shallow)// 对象方式const &#123; posts, users, count &#125; = useZustandStore( state =&gt; (&#123; posts: state.posts, users: state.users, count: state.count &#125;), shallow) 数组方式比对象方式的数据结构看上去没那么清晰，所以我一般会使用对象的方式。 Zustand的中间件再来说道说道zustand的中间件，中间件可以说是zustand的一个特色吧。我们可以发现zustand的store创建和使用基本都是使用方法的嵌套来实现的，说老实话我不是很喜欢这样，我还是比较喜欢对象的方式。zustand的中间件也是使用方法嵌套的方式来实现的。 推荐下官方和第三方的几个中间件： Devtools可以让zustand来使用redux的开发工具。 Persist可以持久化状态，将状态保存到localstorage。 Immer和redux中使用的immutable类似，使用不可变状态。 Computed可以让状态库具有类似vue中的计算方法。 下面我们就来看下这些中间件该如何使用，如果使用多个中间件该如何使用。 devtools： 通过zustand/middleware导入后，直接在creatre方法中进行嵌套即可，zustand的中间件大部分都是这样来进行嵌套就可以使用。 123456789101112131415// store-zustand/index.jsimport &#123; create &#125; from &#x27;zustand&#x27;import &#123; devtools &#125; from &#x27;zustand/middleware&#x27;import &#123; createCounterSlice &#125; from &#x27;./modules/counter&#x27;import &#123; createPostSlice &#125; from &#x27;./modules/post&#x27;import &#123; createUserSlice &#125; from &#x27;./modules/user&#x27;export const useZustandStore = create( devtools((...a) =&gt; (&#123; ...createCounterSlice(...a), ...createPostSlice(...a), ...createUserSlice(...a) &#125;))) 使用devtools的效果： persist： 使用也和devtools差不多，我们直接在devtools的中间件基础上直接使用，顺便看下如何使用多个中间件进行嵌套。 12345678910111213141516171819202122232425// store-zustand/index.jsimport &#123; create &#125; from &#x27;zustand&#x27;import &#123; devtools, persist &#125; from &#x27;zustand/middleware&#x27;import &#123; createCounterSlice &#125; from &#x27;./modules/counter&#x27;import &#123; createPostSlice &#125; from &#x27;./modules/post&#x27;import &#123; createUserSlice &#125; from &#x27;./modules/user&#x27;export const useZustandStore = create( devtools( persist( (...a) =&gt; (&#123; ...createCounterSlice(...a), ...createPostSlice(...a), ...createUserSlice(...a) &#125;), &#123; name: &#x27;zustand-store&#x27;, partialize: state =&gt; (&#123; counter: state.count &#125;) &#125; ) )) 注意persist中的两个参数： name：是存储在localstorage中的密钥名称。 partialize：可以设置在localstorage中只存储哪个状态内容，这个还是比较重要的，如果不使用这个方法则会将所有的state都保存到localstorage中。上面我只将count存储到localstorage中。在localstorage中只会保留这样的数据。 123456&#123; &quot;state&quot;: &#123; &quot;counter&quot;: 77 &#125;, &quot;version&quot;: 0&#125; version是存储的版本。官方的说明：如果要在存储中引入重大更改（例如重命名字段），可以指定新版本号。默认情况下，如果存储中的版本与代码中的版本不匹配，则不会使用存储的值。可以使用迁移函数来处理中断性更改，以便保留以前存储的数据。 Immer： 官方说明：Immer 中间件使您能够以更方便的方式使用不可变状态。此外，使用 Immer，您可以简化在 zustand 中处理不可变数据结构的过程。RTK自带了immutable还是省了一些麻烦。但zustand的使用也还好，只是多了层嵌套。 1234567891011121314151617181920212223242526// store-zustand/index.jsimport &#123; create &#125; from &#x27;zustand&#x27;import &#123; devtools, persist &#125; from &#x27;zustand/middleware&#x27;import &#123; immer &#125; from &#x27;zustand/middleware/immer&#x27;import &#123; createCounterSlice &#125; from &#x27;./modules/counter&#x27;import &#123; createPostSlice &#125; from &#x27;./modules/post&#x27;import &#123; createUserSlice &#125; from &#x27;./modules/user&#x27;export const useZustandStore = create( devtools( persist( immer((...a) =&gt; (&#123; ...createCounterSlice(...a), ...createPostSlice(...a), ...createUserSlice(...a) &#125;)), &#123; name: &#x27;zustand-store&#x27;, partialize: state =&gt; (&#123; counter: state.count &#125;) &#125; ) )) zustand-computed： 这个是一个官方推荐的第三方中间件，插件说明：zustand-computed是一个轻量级的，TypeScript友好的中间件，用于状态管理系统Zustand。这是一个简单的层，可在商店中的任何状态更改后添加转换函数。 用法也很简单，我们在上面的post的代码中已经使用其计算请求的post数量，在此不在赘述。 总体来说zustand来替代RTK是个很好的选择，代码量减少的很明显，据说社区也还比较活跃，因为有个中间件的机制，也使得其扩展也会比RTK方便很多。以上基本上就是Zustand的一些与RTK的对比与一些基本使用方法，官方的文档调理比较乱，如果需要了解更多有个 [官方食用指南] Valtio一个代理模式的状态库官方介绍 Valtio API是最小的，灵活的，没有主见的，有点神奇。Valtio 的代理将您传递给它的对象转换为自我感知代理，允许细粒度订阅和进行状态更新的创造力。在 React 中，Valtio 在渲染优化方面大放异彩。 在我使用的过程中感觉最大的优点就是灵活、简单，比zustand还要简单，写法上也更加灵活。官方的slogan也是Proxy state made simple。因为与zustand是同一个作者，所以很多东西也和zustand类似，也可以通过devtools使用来使用redux的dev插件。因为使用proxy的模式来组织state，所以天然自带computed。写法上比zustand的方法嵌套轻简很多。 创建store1234567891011// store-valito/modules/counter.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;export const state = proxy(&#123; count: 66&#125;)export const actions = &#123; increment: () =&gt; (state.count += 1), decrement: () =&gt; (state.count -= 1)&#125; 说到灵活，还得看valtio的，上面的写法是官方推荐的，这样可以方便在其他页面使用actions的方法。但是也可以写到state中一起。类似zustand的写法 123456789101112131415// store-valito/modules/counter.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;export const state = proxy(&#123; count: 66, increment: () =&gt; state.count += 1, decrement: () =&gt; state.count -= 1&#125;)// 也可以使用this来替代stateexport const state = proxy(&#123; count: 66, increment: () =&gt; this.count += 1, decrement: () =&gt; this.count -= 1&#125;) 方法也可以拆开单独写： 123456789// store-valito/modules/counter.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;export const state = proxy(&#123; count: 66&#125;)export const increment = () =&gt; state.count += 1export const decrementg = () =&gt; state.count -= 1 也可以使用class的方式 12345678910// store-valito/modules/counter.jsclass state &#123; count = 66, increment()&#123; this.count += 1 &#125;, decrement()&#123; this.count -= 1 &#125;&#125; 代码量上也与zustand差不多，但书写上形式上灵活很多。 异步调用上也和zustand差不多，但更灵活的事，valtio只需要一个异步方法，这样就可以把所有的异步方法写到一起统一管理，在store中导入即可。当然zustand也可以这样。 1234567891011121314151617181920// store-valtio/modules/post.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;export const fetchPosts = async () =&gt; &#123; const response = await fetch(&#x27;https://gorest.co.in/public/v2/posts?per_page=5&#x27;) return await response.json()&#125;export const state = proxy(&#123; posts: [], get postsCount() &#123; return state.posts.length &#125;&#125;)export const actions = &#123; fetchPosts: async () =&gt; &#123; state.posts = await fetchPosts() &#125;&#125; 按照zustand的写法异步请求方法与操作方法写到方法一起也可以。 1234567891011121314151617// store-valtio/modules/post.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;export const state = proxy(&#123; posts: [], get postsCount() &#123; return state.posts.length &#125;&#125;)export const actions = &#123; fetchPosts: async () =&gt; &#123; const response = await fetch(&#x27;https://gorest.co.in/public/v2/posts?per_page=5&#x27;) const data = await response.json() state.posts = data &#125;&#125; 这里还可以看到在state中使用了一个get 的方法，这个valtio中的computed了。proxy中的getter天然具有computed方法。 1234567891011121314// store-valtio/modules/user.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;export const state = proxy(&#123; users: []&#125;)export const actions = &#123; fetchUsers: async page =&gt; &#123; const response = await fetch(`https://gorest.co.in/public/v2/users?page=$&#123;page&#125;&amp;per_page=5`) const data = await response.json() state.users = data &#125;&#125; 此处与post类似，也不在赘述。 1234567891011// store-valtio/index.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; state as counterState &#125; from &#x27;./modules/counter&#x27;import &#123; state as postState &#125; from &#x27;./modules/post&#x27;import &#123; state as userState &#125; from &#x27;./modules/user&#x27;export const valtioStore = proxy(&#123; counter: counterState, posts: postState, users: userState&#125;) 统一管理导出也十分的方便，导出命名方式也可以在store slice就修改成对应的命名，只是个人书写习惯而已。 使用state我们在来看下如何使用valtio中的state和actions。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// pages/valito-page.jsximport &#123; useState, useEffect, useCallback, memo &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import cx from &#x27;clsx&#x27;import &#123; valtioStore &#125; from &#x27;@/store-valtio&#x27;import &#123; actions as counterActions &#125; from &#x27;@/store-valtio/modules/counter&#x27;import &#123; actions as userActions &#125; from &#x27;@/store-valtio/modules/user&#x27;import &#123; actions as postActions &#125; from &#x27;@/store-valtio/modules/post&#x27;const ValtioPage = () =&gt; &#123; const &#123; counter, posts, users &#125; = useSnapshot(valtioStore) const [page, setPage] = useState(1) useEffect(() =&gt; &#123; postActions.fetchPosts() &#125;, []) useEffect(() =&gt; &#123; userActions.fetchUsers(page) &#125;, [page]) const handleAdd = useCallback(() =&gt; &#123; counterActions.increment() &#125;, []) const handleSub = useCallback(() =&gt; &#123; counterActions.decrement() &#125;, []) const handlePagePrev = useCallback(() =&gt; &#123; if (page &gt; 1) &#123; setPage(page - 1) &#125; &#125;, [page]) const handlePageNext = useCallback(() =&gt; &#123; setPage(page + 1) &#125;, [page]) return ( &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;h1 className=&#x27;text-gray-400&#x27;&gt;Valtio Page&lt;/h1&gt; &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Count: &#123;counter.count&#125;&lt;/h2&gt; &lt;div className=&#x27;flex justify-start items-center gap-6 h-12&#x27;&gt; &lt;button onClick=&#123;handleAdd&#125; className=&#x27;px-6 py-2 bg-green-500 text-lg text-white rounded-lg&#x27; &gt; Add &lt;/button&gt; &lt;button onClick=&#123;handleSub&#125; className=&#x27;px-6 py-2 bg-red-500 text-lg text-white rounded-lg&#x27; &gt; Sub &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt; Posts &lt;small&gt;&#123;posts.postsCount&#125;&lt;/small&gt; &lt;/h2&gt; &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;div className=&#x27;flex flex-col gap-4&#x27;&gt; &#123;!posts?.posts?.length &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;&#125; &#123;posts?.posts?.map(post =&gt; ( &lt;div key=&#123;post.id&#125; className=&#x27;flex flex-col gap-2 border-b border-dashed border-gray-200 pb-4&#x27; &gt; &lt;h3 className=&#x27;text-lg font-semibold line-clamp-1&#x27;&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p className=&#x27;text-gray-400 line-clamp-2&#x27;&gt;&#123;post.body&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex flex-col gap-4 border-b border-gray-200 py-4&#x27;&gt; &lt;h2 className=&#x27;text-2xl font-semibold&#x27;&gt;Users&lt;/h2&gt; &lt;div className=&#x27;flex flex-col gap-2&#x27;&gt; &lt;div className=&#x27;flex flex-col gap-4&#x27;&gt; &#123;!users?.users?.length &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;&#125; &#123;users?.users?.map(user =&gt; ( &lt;div key=&#123;user.id&#125; className=&#x27;flex flex-col gap-2 border border-gray-200 rounded p-4&#x27;&gt; &lt;h3 className=&#x27;text-lg font-semibold line-clamp-1&#x27;&gt;&#123;user.name&#125;&lt;/h3&gt; &lt;p className=&#x27;text-gray-400&#x27;&gt;&#123;user.email&#125;&lt;/p&gt; &lt;p className=&#x27;text-gray-400&#x27;&gt;&#123;user.gender&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center gap-6 h-12&#x27;&gt; &lt;button onClick=&#123;handlePagePrev&#125; className=&#123;cx( &#x27;px-6 py-2 text-lg text-white rounded-lg&#x27;, &#123; &#x27; bg-green-500&#x27;: page &gt; 1 &#125;, &#123; &#x27;bg-gray-200&#x27;: page === 1 &#125; )&#125; disabled=&#123;page === 1&#125; &gt; 上一页 &lt;/button&gt; &lt;button onClick=&#123;handlePageNext&#125; className=&#x27;px-6 py-2 bg-green-500 text-lg text-white rounded-lg&#x27; &gt; 下一页 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default memo(ValtioPage) 这里的state调用很简单，因为使用了store的统一管理，所以结构出来的是各个 store slice，如果需要可以再解构下，但不太好理解代码了，所以没有采用这个写法。actions也是直接导入过来就可以直接使用。和zustand也差不多。只是导入方式有些区别，zustand需要从state中导入，而valtio直接从store slice中的actions中导入。 valtio使用useSnapshot来获取store，使用store需要注意下使用方法。 12345678import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; valtioStore &#125; from &#x27;@/store-valtio&#x27;const ValtioPage = () =&gt; &#123; // 这种方法是官方推荐的，这样可以避免重复渲染 const &#123; counter, posts, users &#125; = useSnapshot(valtioStore) // 这种方法也可以获得到状态，但官方不推荐，官方解释是：这不会触发重新渲染，但它不像任何其他全局变量那样遵循React规则。 const &#123; counter, posts, users &#125; = valtioStore&#125; 另外的写法，使用useProxy，在一定程度上可以优化写法。 在store导出时，使用useProxy来进行包裹，作为一个hooks导出。 1234567891011121314151617// store-valtio/index.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; useProxy &#125; from &#x27;valtio/utils&#x27;import &#123; state as counterState &#125; from &#x27;./modules/counter&#x27;import &#123; state as postState &#125; from &#x27;./modules/post&#x27;import &#123; state as userState &#125; from &#x27;./modules/user&#x27;const valtioStore = proxy(&#123; counter: counterState, posts: postState, users: userState&#125;)const useValtioStore = () =&gt; useProxy(valtioStore)export default useValtioStore 这样导出hooks后，在页面中使用时就可以不用使用useSnapshot来获取store了。但是使用hooks的方式来获取store，就不能直接从hooks中进行解构。如果是作为统一导出的store，就会导致在调用时调用结构会多一个层级，就像下面的这样。所以在日常使用时，可以将官方给的最佳实践和这种方式结合起来，在使用场景上进行区分，在单一state和action的使用上直接使用useProxy的hooks，在需要使用多个state和action时，使用官方的最佳实践。 123456789import useValtioStore from &#x27;@/store-valtio&#x27;const ValtioPage = () =&gt; &#123; const store = useValtioStore() return ( &lt;h1&gt;&#123;store.counter.count&#125;&lt;/h1&gt; )&#125; Valtio工具valtio没有zustand的中间件机制，但是zustand的一些功能valtio也可以通过工具和插件来实现。 devtools： valtio的devtools也是使用redux的devtools，但使用上不需要像zustand一样进行多层嵌套。 12345678910111213import &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; devtools &#125; from &#x27;valtio/utils&#x27;import &#123; state as counterState &#125; from &#x27;./modules/counter&#x27;import &#123; state as postState &#125; from &#x27;./modules/post&#x27;import &#123; state as userState &#125; from &#x27;./modules/user&#x27;export const valtioStore = proxy(&#123; counter: counterState, posts: postState, users: userState&#125;)devtools(valtioStore, &#123; name: &#x27;valtio&#x27;, enabled: true &#125;) 持久化： 持久化valtio有官方推荐的一个插件 Valtio-persist 可以使用，但使用valtio自带的deriver和subscribe都可以来实现。 123456789101112131415161718192021222324// store-valtio/modules/counter.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; derive &#125; from &#x27;valtio/utils&#x27;export const state = proxy(&#123; count: 66&#125;)export const actions = &#123; increment: () =&gt; (state.count += 1), decrement: () =&gt; (state.count -= 1)&#125;// derive方式derive(&#123; storage: get =&gt; &#123; localStorage.setItem(&#x27;valtio-count&#x27;, JSON.stringify(get(state))) &#125;&#125;)// subscribe方式subscribe(state, () =&gt; &#123; localStorage.setItem(&#x27;valtio-count&#x27;, JSON.stringify(state))&#125;) 一些使用建议在官方给了一个actions组织的的最佳实践 How to organize actions 中介绍了多种action的组织方式，在上面创建store时我也进行了介绍，但在实践中我喜欢将一些简单的action，比如一些直接修改状态的放到state中，这样在使用时 可以直接使用useStore的方式来直接调用。对于比较复杂的action，我偏向于放到单独的actions对象中，在使用时进行导入调用。这样可以确保state中代码 复杂度保持在一个比较简单的情况，不会一大坨代码都放到state中，actions中方一些相对复杂的也便于单独查看。当然这些也需要根据具体场景来进行处理，不需要模板化的一刀切。 Valtio使用的问题官方给了一些 使用时的问题 ，这里我只拿出来说一个问题。 将 React.memo 与对象属性一起使用可能会导致意外行为： 跟踪 useSnapshot(state) 返回的 snap 变量以进行渲染优化。如果将 snap 或 snap 中的某些对象传递给具有 React.memo 的组件，它可能无法按预期工作，因为 React.memo 可以跳过触摸对象属性。 不要使用 React.memo 不要将对象传递给具有React.memo 的组件（而是传递基元值）。 传入该元素的代理，然后在该代理上传递 useSnapshot 。 其实简单来说，就是不要将状态作为props传到有memo的子组件上，如果需要，子组件直接使用useSnapshot直接去store获取。 官方实例： 123456789101112131415161718192021222324// 2.的示例const ChildComponent = React.memo( (&#123; title, // 字符串或任何原始值都可以 description, // 字符串或任何原始值都可以 // obj, // 应避免使用对象 &#125;) =&gt; ( &lt;div&gt; &#123;title&#125; - &#123;description&#125; &lt;/div&gt; ))const ParentComponent = () =&gt; &#123; const snap = useSnapshot(state) return ( &lt;div&gt; &lt;ChildComponent title=&#123;snap.obj.title&#125; description=&#123;snap.obj.description&#125; /&gt; &lt;/div&gt; )&#125; 1234567891011121314151617181920// 3.的示例const state = proxy(&#123; objects: [ &#123; id: 1, label: &#x27;foo&#x27; &#125;, &#123; id: 2, label: &#x27;bar&#x27; &#125;, ],&#125;)const ObjectList = React.memo(() =&gt; &#123; const stateSnap = useSnapshot(state) return stateSnap.objects.map((object, index) =&gt; ( &lt;Object key=&#123;object.id&#125; objectProxy=&#123;state.objects[index]&#125; /&gt; ))&#125;)const Object = React.memo((&#123; objectProxy &#125;) =&gt; &#123; const objectSnap = useSnapshot(objectProxy) return objectSnap.bar&#125;) valtio足够简单、灵活，之前很多项目中我都会使用valtio做成hooks来做些auth的操作，比如使用deriver来将auth的信息存储到localstorage中，使用computed判断是否登录。 总结RTK、Zustand、Valtio都是不错的状态库，代码量还是Zustand和Valtio有巨大的优势，RTK作为老牌状态库Redux的优化工具，在现代状态库中还是有很多缺失，机制上不如zustand、灵活性上不如valtio。 RTK虽说槽点很多，但是有些可取之处，RTK Query结合RTK一起使用也是个不错的选择，但是用过React Query， swr，也会发现RTK Query的模板化代码和奇怪的组织结构让你没有兴趣使用，如果需要在项目中使用Redux RTK的话，当然还是可以使用RTK Query的，毕竟都是一个妈妈生的。 Zustand是个可以用用的状态库，唯一让人吐槽的就是方法的嵌套，使用上有些心智负担，但中间件机制和足够简洁的使用方式足可以满足你对状态的使用需求。 Valtio足够简单、灵活，如何更好的组织才会让你使用更加的得心应手。","permalink":"http://example.com/2023/10/05/React%E7%8A%B6%E6%80%81%E6%A8%AA%E8%AF%84/","photos":[]},{"tags":[{"name":"typescript","slug":"typescript","permalink":"http://example.com/tags/typescript/"}],"title":"TypeScript 进阶","date":"2023/10/05","text":"面相对象 TS为前端面向对象开发带来了契机 JS语言没有类型检查，如果使用面向对象的方式开发，会产生大量的接口，而大量的接口会导致调用复杂度剧增，这种复杂度必须通过严格的类型检查来避免错误，尽管可以使用注释或文档或记忆力，但是它们没有强约束力。 TS带来了完整的类型系统，因此开发复杂程序时，无论接口数量有多少，都可以获得完整的类型检查，并且这种检查是据有强约束力的。 面向对象中有许多非常成熟的模式，能处理复杂问题 在过去的很多年中，在大型应用或复杂领域，面向对象已经积累了非常多的经验。 面相对象概念面向对象：Oriented（基于） Object（事物），简称OO。是一种编程思想，它提出一切以类对切入点思考问题。 其他编程思想：面向过程、函数式编程 面向过程：以功能流程为思考切入点，不太适合大型应用 函数式编程：以数学运算为思考切入点 面向对象：以划分类为思考切入点。类是最小的功能单元 类：可以产生对象的模板。 类的基础继承可以描述类与类之间的关系 继承可以描述类与类之间的关系 坦克、玩家坦克、敌方坦克 玩家坦克是坦克，敌方坦克是坦克 如果A和B都是类，并且可以描述为A是B，则A和B形成继承关系： B是父类，A是子类 B派生A，A继承自B B是A的基类，A是B的派生类 如果A继承自B，则A中自动拥有B中的所有成员 示例： 123456789101112131415161718192021222324252627282930313233343536class Tank &#123; name: string = &#x27;坦克&#x27; geo: &#123; x: number; y: number &#125; = &#123; x: 11, y: 22 &#125; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125;&#125;class PlayerTank extends Tank &#123; name: string = &#x27;玩家坦克&#x27; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125; shoot() &#123; console.log(`$&#123;this.name&#125; 射击`) &#125;&#125;class EnemyTank extends Tank &#123; name: string = &#x27;敌方坦克&#x27; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125;&#125;const tank = new Tank()const playerTank = new PlayerTank()const enemyTank = new EnemyTank()tank.say() // 我是坦克playerTank.say() // 我是玩家坦克playerTank.shoot() // 玩家坦克 射击enemyTank.say() // 我是敌方坦克console.log(&#x27;敌方坦克坐标: &#x27;, enemyTank.geo) // 敌方坦克坐标: &#123; x: 11, y: 22 &#125; 以上示例可以看到，只要通过继承的方式，玩家坦克和敌方坦克 都可以获得坦克这个父类的所有属性和方法，并且可以重写对应的属性和方法 成员的重写重写(override)：子类中覆盖父类的成员 子类成员不能改变父类成员的类型 12345678910111213141516171819class Tank &#123; name: string = &#x27;坦克&#x27; geo: &#123; x: number; y: number &#125; = &#123; x: 11, y: 22 &#125; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125;&#125;class PlayerTank extends Tank &#123; name: string = &#x27;玩家坦克&#x27; geo: string = &#x27;玩家坐标&#x27; // 类型“PlayerTank”中的属性“geo”不可分配给基类型“Tank”中的同一属性。 不能将类型“string”分配给类型“&#123; x: number; y: number; &#125;”。 say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125; shoot() &#123; console.log(`$&#123;this.name&#125; 射击`) &#125;&#125; 无论是属性还是方法，子类都可以对父类的相应成员进行重写，但是重写时，需要保证类型的匹配。 注意this关键字：在继承关系中，this的指向是动态——调用方法时，根据具体的调用者确定this指向 super关键字：在子类的方法中，可以使用super关键字读取父类成员 12345678910111213141516171819202122232425262728class Tank &#123; name: string = &#x27;坦克&#x27; geo: &#123; x: number; y: number &#125; = &#123; x: 11, y: 22 &#125; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125;&#125;class PlayerTank extends Tank &#123; name: string = &#x27;玩家坦克&#x27; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125; shoot() &#123; console.log(`$&#123;this.name&#125; 射击`) &#125; allSay() &#123; super.say() this.say() &#125;&#125;const playerTank = new PlayerTank()playerTank.allSay()// 我是玩家坦克// 我是玩家坦克 类型匹配 鸭子辨型法 子类的对象，始终可以赋值给父类 面向对象中，这种现象，叫做里氏替换原则 如果需要判断一个数据的具体子类类型，可以使用instanceof 123456789101112131415161718192021222324252627282930class Tank &#123; name: string = &#x27;坦克&#x27; geo: &#123; x: number; y: number &#125; = &#123; x: 11, y: 22 &#125; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125;&#125;class PlayerTank extends Tank &#123; name: string = &#x27;玩家坦克&#x27; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125; shoot() &#123; console.log(`$&#123;this.name&#125; 射击`) &#125; allSay() &#123; super.say() this.say() &#125;&#125;const playerTank: Tank = new PlayerTank()// playerTank.allSay() // 类型“Tank”上不存在属性“allSay”。if(playerTank instanceof PlayerTank) &#123; playerTank.allSay()&#125; 当在实例化时，指定子类（PlayerTank）的类型为父类（Tank）时，直接使用子类自己的属性方法会报错。因为不确定这个子类的类型是否有自己的属性和方法，因为只给了子类为父类的类型，那么父类中的属性和方法是安全可用的，所以可以使用 类型保护 来确定是否是子类 从而来使用子类 自己的属性和方法 protected修饰符readonly：只读修饰符 访问权限修饰符：private、 public、 protected protected: 受保护的成员，只能在自身和子类中访问 1234567891011121314151617class Tank &#123; protected name: string = &#x27;坦克&#x27; say() &#123; console.log(`我是$&#123;this.name&#125;`) &#125;&#125;class PlayerTank extends Tank &#123; shoot() &#123; console.log(`$&#123;this.name&#125; 射击`) &#125;&#125;const playerTank = new PlayerTank()// playerTank.name // 属性“name”受保护，只能在类“Tank”及其子类中访问。playerTank.shoot() // 坦克 射击 受保护的 属性，在类(class)的外面是无法访问到的，但是在类和子类中可以访问到 单根性和传递性单根性：每个类最多只能拥有一个父类 传递性：如果A是B的父类，并且B是C的父类，则，可以认为A也是C的父类 抽象类为什么需要抽象类有时，某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建它的对象。该类可以作为抽象类。 给类前面加上abstract，表示该类是一个抽象类，不可以创建一个抽象类的对象。 示例： 12345678910111213abstract class Chess &#123;&#125;class Horse extends Chess &#123;&#125;class Cannon extends Chess &#123;&#125;class Soldier extends Chess &#123;&#125;const horse = new Horse()const cannon = new Cannon()const soldier = new Soldier()// const chess = new Chess() // 无法创建抽象类的实例。 抽象成员父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或实现是什么，因此，需要有一种强约束，让继承该类的子类，必须要实现该成员。 抽象类中，可以有抽象成员，这些抽象成员必须在子类中实现。 在抽象类的属性或方法的前面加上abstract。 注意：需要在抽象类中加上抽象成员的属性或方法前加上关键字abstract才行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class Chess &#123; x: number = 0 y: number = 0 abstract readonly name: string abstract move(targetX: number, targetY: number): boolean&#125;class Horse extends Chess &#123; readonly name = &#x27;马&#x27; move(targetX: number, targetY: number) &#123; this.x = targetX this.y = targetY console.log(&#x27;马走日&#x27;) return true &#125;&#125;class Cannon extends Chess &#123; readonly name: string constructor() &#123; super() this.name = &#x27;炮&#x27; &#125; move(targetX: number, targetY: number) &#123; this.x = targetX this.y = targetY console.log(&#x27;飞炮&#x27;) return true &#125;&#125;class Soldier extends Chess &#123; get name() &#123; return &#x27;兵&#x27; &#125; move(targetX: number, targetY: number) &#123; this.x = targetX this.y = targetY console.log(&#x27;拱卒&#x27;) return true &#125;&#125;const horse = new Horse()const cannon = new Cannon()const soldier = new Soldier()horse.move(2, 3)cannon.move(1, 3)soldier.move(0, 1) 上述类中棋（Chess）为父类，马（Horse）、炮（Cannon）、兵（Soldier）为子类，父类为抽象类（abstract class），包含抽象属性（abstract name）和抽象方法（abstract move()），所有的子类都必须实现name属性和move方法 设计模式 - 模板模式设计模式：面对一些常见的功能场景，有一些固定的、经过多年实践的成熟方法，这些方法称之为设计模式。 模板模式：有些方法，所有的子类实现的流程完全一致，只是流程中的某个步骤的具体实现不一致，可以将该方法提取到父类，在父类中完成整个流程的实现，遇到实现不一致的方法时，将该方法做成抽象方法。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract class Chess &#123; x: number = 0 y: number = 0 abstract readonly name: string move(targetX: number, targetY: number): boolean &#123; console.log(&#x27;1.边界判断&#x27;) console.log(&#x27;2.目标位置是否有己方棋子&#x27;) if (this.rule(targetX, targetY)) &#123; this.x = targetX this.y = targetY console.log(`$&#123;this.name&#125;移动成功`) return true &#125; console.log(`$&#123;this.name&#125;移动失败`) return false &#125; protected abstract rule(targetX: number, targetY: number): boolean&#125;class Horse extends Chess &#123; readonly name = &#x27;马&#x27; protected rule(targetX: number, targetY: number) &#123; console.log(&#x27;马走日&#x27;) return true &#125;&#125;class Cannon extends Chess &#123; readonly name: string constructor() &#123; super() this.name = &#x27;炮&#x27; &#125; protected rule(targetX: number, targetY: number) &#123; console.log(&#x27;飞炮&#x27;) return true &#125;&#125;class Soldier extends Chess &#123; get name() &#123; return &#x27;兵&#x27; &#125; protected rule(targetX: number, targetY: number) &#123; console.log(&#x27;拱卒&#x27;) return false &#125;&#125;const horse = new Horse()const cannon = new Cannon()const soldier = new Soldier()horse.move(2, 3)cannon.move(1, 3)soldier.move(0, 1) 上述代码中，在父类（Chess）中实现了模板模式，在一个公共的方法（move）中实现了一些基本流程和功能，但中间需要通过抽象方法，每个棋子移动规则（rule）来判断是否移动成功，所以每个子类都只需要实现这个抽象类来作为判断依据实现（rule），就能实现move方法并得到返回的结果 当需要新增（Chess）的子类时，可以在添加完子类后的报错，用鼠标点击快速修复，然后点击实现已继承的抽象类，IDE就会把新增的子类需要实现的抽象类显示出来，剩下就只需要实现这些抽象属性和抽象方法即可。 静态成员什么是静态成员 静态成员是指，附着在类上的成员（属于某个构造函数的成员） 使用static修饰的成员，是静态成员 123456789101112class User &#123; constructor(public username: string, public email: string, public password: string) &#123;&#125; static login(username: string, password: string): User | undefined &#123; console.log(username, password) return undefined &#125;&#125;const result = User.login(&#x27;jacky&#x27;, &#x27;123456&#x27;)const user = new User(&#x27;jacky&#x27;, &#x27;jacky@qq.com&#x27;, &#x27;123456&#x27;)// user.login(&#x27;jacky&#x27;, &#x27;123456&#x27;) // 属性“login”在类型“User”上不存在。你的意思是改为访问静态成员“User.login”吗? 实例成员：对象成员，属于某个类的对象。类似上述示例中的username、email、password，只属于实例后的对象。 静态成员：非实例成员，属于某个类。类似上述示例中的login()方法，属于User类，而不属于实例对象。 静态方法中的this实例方法中的this指向的是当前对象 而静态方法中的this指向的是**当前类 示例： 1234567891011121314151617181920212223242526272829class User &#123; // 声明静态成员users static users: User[] = [] constructor(public username: string, public email: string, public password: string) &#123; // 在登录成功后，向User.users中添加一个新的User信息 // 这里的this指的是添加的用户信息（username/email/password），users是User的静态属性 User.users.push(this) &#125; static login(username: string, password: string): User | undefined &#123; // 根据用户名和密码找到users中对应的User return User.users.find(user =&gt; user.username === username &amp;&amp; user.password === password) &#125; // 实例方法，可以访问静态属性 sayHi() &#123; console.log(`Hello, $&#123;this.username&#125;`) &#125;&#125;// 添加多个用户const user1 = new User(&#x27;jacky&#x27;, &#x27;jacky@qq.com&#x27;, &#x27;123456&#x27;)const user2 = new User(&#x27;tom&#x27;, &#x27;tom@qq.com&#x27;, &#x27;123456&#x27;)const user3 = new User(&#x27;jerry&#x27;, &#x27;jerry@qq.com&#x27;, &#x27;123456&#x27;)// 登录用户信息，如果查找到users中有对应的User信息，则返回对应的User信息const result = User.login(&#x27;jacky&#x27;, &#x27;123456&#x27;)// 判断如果有登录返回则执行sayHi实例方法if (result) &#123; result.sayHi()&#125; 设计模式 - 单例模式单例模式：某些类的对象，在系统中最多只能有一个，为了避免开发者造成随意创建多个类对象的错误，可以使用单例模式进行强约束。 123456789101112131415161718192021222324252627282930class Board &#123; width: number = 480 height: number = 480 protected constructor() &#123;&#125; init() &#123; console.log(&#x27;init board&#x27;) &#125; protected static _board: Board // 在创建棋盘时进行判断，如果棋盘已经存在则返回棋盘，否则实例化一个棋盘 static createBoard(): Board &#123; if (this._board) &#123; return this._board &#125; else &#123; this._board = new Board() return this._board &#125; &#125;&#125;// 因为constructor是受保护的，仅可在类声明中访问。所以不能实例化// const board = new Board() // 类“Board”的构造函数是受保护的，仅可在类声明中访问。const board1 = Board.createBoard()const board2 = Board.createBoard()// 此时board1和board2指向同一个对象console.log(board1 === board2) // true 上述代码中，始终只会有一个new Board()对象，并且限制在外部实例化，只能通过静态方法createBoard来创建一个棋盘。 再谈接口接口用于约束类、对象、函数，是一个类型契约。 示例： 一群动物猫、狗、猪有各种表演技能。 火圈秀： 猫能跳单火圈、跳双火圈 舞蹈秀： 狗能跳舞、唱歌 猪能跳舞、唱歌 123456789101112131415161718192021222324252627282930313233343536373839404142434445// animals.tsimport &#123; IDanceShow, IFireShow &#125; from &#x27;./interfaces&#x27;export abstract class Animal &#123; abstract type: string constructor(public name: string, public age: number) &#123;&#125; sayHello() &#123; console.log(`hello everyone, I&#x27;m $&#123;this.type&#125; $&#123;this.name&#125;,I&#x27;m $&#123;this.age&#125; years old.`) &#125;&#125;export class Cat extends Animal implements IFireShow &#123; type: string = &#x27;Cat&#x27; singleFireHoop() &#123; console.log(`$&#123;this.name&#125; cross single fire hoop`) &#125; doubleFireHoops() &#123; console.log(`$&#123;this.name&#125; cross double fire hoops`) &#125;&#125;export class Dog extends Animal implements IDanceShow &#123; type: string = &#x27;Dog&#x27; dance() &#123; console.log(`$&#123;this.name&#125; is dance`) &#125; sing() &#123; console.log(`$&#123;this.name&#125; sing song`) &#125;&#125;export class Pig extends Animal implements IDanceShow &#123; type: string = &#x27;Pig&#x27; dance() &#123; console.log(`$&#123;this.name&#125; is dance`) &#125; sing() &#123; console.log(`$&#123;this.name&#125; sing song`) &#125;&#125; 上述代码实现了： 定义父抽象类Animal，指定每个动物的类别，并拥有name、age的属性、sayHello的方法。 定义猫Cat、狗Dog、猪Pig的类，继承自Animal，Cat实现了IFireShow的接口，Dog和Pig实现了IDanceShow的接口 定义猫Cat的技能为跳单火圈singleFireHoop、跳双火圈doubleFireHoops 定义狗Dog和猪的技能为跳舞dance和唱歌sing 123456789101112131415161718192021222324// interfaces.tsexport interface IFireShow &#123; singleFireHoop(): void doubleFireHoops(): void&#125;export interface IDanceShow &#123; dance(): void sing(): void&#125;export const hasFireShow = (animal: object): animal is IFireShow =&gt; &#123; if ((animal as IFireShow).singleFireHoop &amp;&amp; (animal as IFireShow).doubleFireHoops) &#123; return true &#125; return false&#125;export const hasDanceShow = (animal: object): animal is IDanceShow =&gt; &#123; if ((animal as IDanceShow).dance &amp;&amp; (animal as IDanceShow).sing) &#123; return true &#125; return false&#125; 上述代码实现了： IFireShow和IDanceShow两个接口，并定义了各自接口需要实现的方法。 hasFireShow是类型保护函数，参数传入了一个对象&#96;&#96;animal，后面的animal is IFireShow是用来判断，参数是否是IFireShow这个类型，如果是返回true，否则返回false。然后在函数中对传入参数在来进行断言animal as IFireShow，断言后的参数，就可以找到接口IFireShow中的对应方法。如果判断有对应方法，则返回true否则返回false&#96;。 hasDanceShow同hasFireShow类似。 12345678910111213141516171819202122232425262728293031323334// index.tsimport &#123; Animal, Cat, Dog, Pig &#125; from &#x27;./animals&#x27;import &#123; hasDanceShow, hasFireShow &#125; from &#x27;./interfaces&#x27;const animals: Animal[] = [new Cat(&#x27;mimi&#x27;, 3), new Dog(&#x27;wangwang&#x27;, 4), new Pig(&#x27;hengheng&#x27;, 5)]// all animals say helloanimals.forEach(a =&gt; a.sayHello())// hello everyone, I&#x27;m Cat mimi,I&#x27;m 3 years old.// hello everyone, I&#x27;m Dog wangwang,I&#x27;m 4 years old.// hello everyone, I&#x27;m Pig hengheng,I&#x27;m 5 years old.// fire show startanimals.forEach(a =&gt; &#123; if (hasFireShow(a)) &#123; a.singleFireHoop() a.doubleFireHoops() &#125;&#125;)// mimi cross single fire hoop// mimi cross double fire hoops// dance show startanimals.forEach(a =&gt; &#123; if (hasDanceShow(a)) &#123; a.dance() a.sing() &#125;&#125;)// wangwang is dance// wangwang sing song// hengheng is dance// hengheng sing song 上述代码实现了： 定义了一组动物，并给每个动物赋值名字和年龄 通过forEach循环父类方法sayHello实现每个动物say hello的动作。 通过forEach循环，并通过hasFireShow方法来判断，哪些动物具有singleFireHoop和doubleFireHoops方法，如果有则执行该方法，实现表演。 通过forEach循环，并通过hasDanceShow方法来判断，哪些动物具有dance和sing方法，如果有则执行该方法，实现表演。 通过上述示例可以看到。不使用接口实现时： 对表演的方法（成员函数）没有强约束力，不能通过表演方法来限制哪些有该表演方法的动物来进行表演 容易将类型和能力耦合在一起 面向对象领域中的接口的语义：表达了某个类是否拥有某种能力 某个类具有某种能力，其实，就是实现了某种接口 类型保护函数：通过调用该函数，会触发TS的类型保护，该函数必须返回boolean 接口和类型别名的最大区别：接口可以被类实现，而类型别名不可以 接口可以继承类表示该类的所有成员都在接口中。 示例： 123456789101112131415161718class A &#123; a1: string = &#x27;&#x27; a2: string = &#x27;&#x27;&#125;class B &#123; b1: number = 0 b2: number = 0&#125;// 接口C可以同时继承A、B两个类interface C extends A, B &#123;&#125;// 实现C接口的对象，必须同时实现对应接口中的属性。const c: C = &#123; a1: &quot;&quot;, a2: &quot;&quot;, b1: 0, b2: 0&#125; 索引器对象[值]，使用成员表达式 在TS中，默认情况下，不对索引器（成员表达式）做严格的类型检查 使用配置noImplicitAny开启对隐式any的检查。 隐式any：TS根据实际情况推导出的any类型 1234567class A &#123; [props: string]: string name: string = &#x27;jacky&#x27;&#125;const a = new A()console.log(a[&#x27;name&#x27;]) // jacky 在索引器中，键的类型可以是字符串，也可以是数字 1234567891011class A &#123; [props: string]: string [props: number]: string name: string = &#x27;jacky&#x27; 2 = &#x27;3&#x27;&#125;const a = new A()console.log(a[&#x27;name&#x27;]) // jackyconsole.log(a[2]) // 3 在类中，索引器书写的位置应该是所有成员之前 在TS中，如果某个类中使用了两种类型的索引器，要求两种索引器的值类型必须匹配 TS中索引器的作用 在严格的检查下，可以实现为类动态增加成员 可以实现动态的操作类成员 示例： 123456789101112class A &#123; [props: string]: string name: string = &#x27;jacky&#x27;&#125;const a = new A()// 在没有索引器之前，使用成员表达式的方式，是无法添加新的成员的// a[&#x27;age&#x27;] // 元素隐式具有 &quot;any&quot; 类型，因为类型为 &quot;&quot;age&quot;&quot; 的表达式不能用于索引类型 &quot;A&quot;。 类型“A”上不存在属性“age”。// 在增加索引器之后，就可以向对象中增加新的属性a[&#x27;age&#x27;] = &#x27;13&#x27;console.log(a[&#x27;age&#x27;]) // 13 在JS中，所有的成员名本质上，都是字符串，如果使用数字作为成员名，会自动转换为字符串。 this的指向约束在JavaScript中this指向的几种情况 明确：大部分时候，this的指向取决于函数的调用方式 如果直接调用函数（全局调用），this指向全局对象或undefined (启用严格模式) 如果使用 对象.方法 调用，this指向对象本身 如果是dom事件的处理函数，this指向事件处理对象 特殊情况： 箭头函数，this在函数声明时确定指向，指向函数位置的this 使用bind、apply、call手动绑定this对象 由于在JavaScript中this的指向灵活性太大，在很多场景下函数中相同的this有不同的指向，造成this很难判断。 TypeScript中的this配置noImplicitThis为true，表示不允许this隐式的指向any 在TS中，允许在书写函数时，手动声明该函数中this的指向，将this作为函数的第一个参数，该参数只用于约束this，并不是真正的参数，也不会出现在编译结果中。 123456789101112131415161718192021// 在对象中使用this约束interface IUser &#123; name: string age: number // 在接口中指出该方法的this指向接口对象本身 sayHi(this: IUser): void&#125;const user: IUser = &#123; name: &#x27;jacky&#x27;, age: 14, sayHi() &#123; console.log(this.age, this.name) &#125;&#125;// 因为对this指向做了约束，所以不能使用此方法来调用sayHi方法// const u = user.sayHi// u() // 类型为“void”的 &quot;this&quot; 上下文不能分配给类型为“IUser”的方法的 &quot;this&quot;。// 正确方法user.sayHi() 1234567891011121314// 在类中使用this约束class User &#123; constructor(public name: string, public age: number) &#123;&#125; // 明确指出this指向User对象本身 sayHi(this: User) &#123; console.log(this.name, this.age) &#125;&#125;const user = new User(&#x27;jacky&#x27;, 11)// const say = user.sayHi// say() // 类型为“void”的 &quot;this&quot; 上下文不能分配给类型为“User”的方法的 &quot;this&quot;。// 正确方法user.sayHi() 装饰器装饰器（Decorator）是一种语法结构，用来在定义时修改类（class）的行为。 在语法上，装饰器有如下几个特征。 第一个字符（或者说前缀）是@，后面是一个表达式。 @&#96;后面的表达式，必须是一个函数（或者执行后可以得到一个函数）。 这个函数接受所修饰对象的一些相关值作为参数。 这个函数要么不返回值，要么返回一个新对象取代所修饰的目标对象。 123456789101112@decoratorclass A &#123;&#125;function decorator(target: object) &#123; console.log(`执行 装饰器 decorator `)&#125;const a = new A()console.log(a)// 返回// 执行 装饰器 ClassDecorator // A &#123;&#125; 装饰器有多种形式，基本上只要在@符号后面添加表达式都是可以的。 @后面的表达式，最终执行后得到的应该是一个函数。 装饰器一般只用来为类添加某种特定行为。 解决的问题装饰器，能够带来额外的信息量，可以达到分离关注点的目的。 信息书写位置的问题 重复代码的问题 上述两个问题产生的根源：某些信息，在定义时，能够附加的信息量有限。 装饰器的作用：为某些属性、类、参数、方法提供元数据信息(metadata) 元数据：描述数据的数据 装饰器的本质在JavaScript中，装饰器是一个函数。（装饰器是要参与运行的） 装饰器可以修饰： 类 成员（属性+方法） 参数 类装饰器类装饰器的本质是一个函数，该函数接收一个参数，表示类本身（构造函数本身） 使用装饰器@得到一个函数 1type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void; 在TS中，如何约束一个变量为类 Function new (参数)=&gt;object 在TS中要使用装饰器，需要开启experimentalDecorators 装饰器函数的运行时间：在类定义后直接运行 类装饰器可以具有的返回值： void：仅运行函数 返回一个新的类：会将新的类替换掉装饰目标 多个装饰器的情况：会按照后加入先调用的顺序进行调用（）。 示例： 12345678910111213@decoratorclass A &#123;&#125;function decorator(target: Function) &#123; target.prototype.name = &#x27;jacky&#x27; target.prototype.sayHi = function () &#123; console.log(&#x27;hi, I am A&#x27;) &#125;&#125;const a = new A()console.log((a as any).name) // jackyconsole.log((a as any).sayHi()) // hi, I am A 上方代码可以看到 类装饰器 在类的原型上增加了属性name和方法sayHi方法 通过实例化类A，可以从实例中获取到装饰器在类原型上增加的属性和方法。 示例： 当需要装饰器来传递一些参数时，上述例子中的方式就不适合了，需要使用装饰器工厂方法类传递参数（通过一个方法产生一个装饰器） 123456789101112131415@decorator(&#x27;jacky&#x27;)class A &#123;&#125;function decorator(name: string) &#123; return (target: Function) =&gt; &#123; target.prototype.name = name target.prototype.sayHi = function () &#123; console.log(`hi, I am $&#123;name&#125;`) &#125; &#125;&#125;const a = new A()console.log((a as any).name) //jackyconsole.log((a as any).sayHi()) // hi, I am jacky 上述代码释义： 通过装饰器传递了一个用户名给类A 装饰器通过装饰器工厂方法来接收字符串的用户名，然后返回一个符合装饰器要求的函数 在类原型上传递一些属性name和方法sayHi 在类的实例中调用装饰器中的属性和方法 示例： 多个装饰器方法和装饰器执行顺序 12345678910111213141516171819202122@d1()@d2()class A &#123;&#125;function d1() &#123; console.log(&#x27;d1&#x27;) return (target: Function) =&gt; &#123; console.log(&#x27;d1 decorator&#x27;) &#125;&#125;function d2() &#123; console.log(&#x27;d2&#x27;) return (target: Function) =&gt; &#123; console.log(&#x27;d2 decorator&#x27;) &#125;&#125;// d1// d2// d2 decorator// d1 decorator 上述代码释义： 装饰器方法，会按照顺序执行所以看到先打印了d1、d2 装饰器方法返回的装饰器，按照离类的远近顺序执行所以打印的是d2 decorator、d1 decorator 成员(类成员)装饰器 属性 属性装饰器也是一个函数，该函数需要两个参数： 如果是静态属性，则为类本身； 如果是实例属性，则为类的原型； 固定为一个字符串，表示属性名 1declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void; 示例： 12345678910111213141516171819202122232425class A &#123; @d(&#x27;姓名&#x27;) name: string = &#x27;jacky&#x27; @d(&#x27;年龄&#x27;) age: number = 36&#125;function d(title: string) &#123; return (target: any, key: string) =&gt; &#123; if (!target.$props) &#123; target.$props = [] &#125; target.$props.push(&#123; title, key &#125;) &#125;&#125;const a = new A()console.log((a as any).$props)// [ &#123; title: &#x27;姓名&#x27;, key: &#x27;name&#x27; &#125;, &#123; title: &#x27;年龄&#x27;, key: &#x27;age&#x27; &#125; ]console.log((A.prototype as any).$props)// [ &#123; title: &#x27;姓名&#x27;, key: &#x27;name&#x27; &#125;, &#123; title: &#x27;年龄&#x27;, key: &#x27;age&#x27; &#125; ] 代码释义： 通过装饰器给类的属性上添加装饰器，并设置对应的参数title 装饰器通过装饰器方法，返回一个符合属性装饰器要求的函数，有两个参数：target目标类，和key 属性名。 装饰器中通有个判断在target类的原型上是否有一个$props的属性，如果没有就设置这个属性为一个数组，并向数组中添加title和key 在类的实例中可以直接调用装饰器中添加的属性，并打印结果 也可以通过类的原型找到该属性，并打印结果 方法 方法装饰器也是一个函数，该函数需要三个参数： 如果是静态方法，则为类本身； 如果是实例方法，则为类的原型； 固定为一个字符串，表示方法名 属性描述对象 1declare type MethodDecorator = &lt;T&gt;(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void; 示例： 1234567891011121314151617class A &#123; @methodDecorator() sayHi() &#123;&#125;&#125;function methodDecorator() &#123; return (target: object, propertyKey: string, descriptor: PropertyDescriptor) =&gt; &#123; console.log(target, propertyKey, descriptor) &#125;&#125;// &#123;&#125; sayHi &#123;// value: [Function: sayHi],// writable: true,// enumerable: false,// configurable: true// &#125; 代码释义： 给类的方法加装饰器，需要传递三个参数target、propertyKey、descriptor 打印结果可以看到： target就是类本身 propertyKey就是方法名 descriptor是一个方法描述的配置对象 value是方法内容，value可以是一个方法或字符串 writable： 是否可以重新赋值 enumerable：在遍历循环中是否可以遍历出 可以有多个装饰器修饰 示例： 12345678910111213141516171819class A &#123; @methodDecorator() @useless sayHi() &#123;&#125;&#125;function methodDecorator() &#123; return (target: object, propertyKey: string, descriptor: PropertyDescriptor) =&gt; &#123; // 设置被装饰的方法可以被枚举、遍历 descriptor.enumerable = true &#125;&#125;function useless(target: object, propertyKey: string, descriptor: PropertyDescriptor) &#123; descriptor.value = () =&gt; console.log(&#x27;该方法不可用&#x27;)&#125;const a = new A()a.sayHi() // 该方法不可用 代码释义： 当有多个装饰器时，离方法最近的将会最先执行 useless装饰器将sayHi的方法替换成了console.log(&#39;该方法不可用&#39;) 所以在实例化后，执行该方法得到的是该方法不可用 综合示例通过装饰器标注类的名称、类中属性名称，并通过一个打印函数将类名称和属性名称与对应的赋值打印出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//decorator.ts// 类装饰器export function classDecorator(name: string) &#123; return (target: Function) =&gt; &#123; // 将装饰器工厂参数获取到的name赋值给$classDecorator target.prototype.$classDecorator = name &#125;&#125;// 属性装饰器export function methodDecorator(name: string) &#123; return (target: any, propertyKey: string) =&gt; &#123; // 判断是原型上是否有$methodDecorator这个属性，如果没有就添加，并赋值为一个空数组 if (!target.$methodDecorator) &#123; target.$methodDecorator = [] &#125; // 往$methodDecorator数组中添加装饰器工厂获取到的name和该属性的名称 target.$methodDecorator.push(&#123; name, propertyKey &#125;) &#125;&#125;// 打印装饰器函数export function printDecoratoar(obj: any) &#123; // 输出类的名字 // 查看原型上是否有$classDecorator这个属性，如果有则打印该属性 // 如果没有则在该改类的原型上查找 if (obj.$classDecorator) &#123; console.log(obj.$classDecorator) &#125; else &#123; console.log(Object.getPrototypeOf(obj).constructor.name) &#125; // 输出属性的名字 // 查看该原型上是否有$methodDecorator这个属性，如果没有则添加该属性，并赋值为一个数组 if (!obj.$methodDecorator) &#123; obj.$methodDecorator = [] &#125; // 遍历传入的实例类 // 并判断在原型的$methodDecorator中是否有有和传入的方法名称相同的值 // 如果有就打印类中属性的装饰器名称和对应的值 // 如果没有则打印属性的名称和属性的值 for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; const prop = obj.$methodDecorator.find((item: any) =&gt; item.propertyKey === key) if (prop) &#123; console.log(`\\t $&#123;prop.name&#125;: $&#123;obj[key]&#125;`) &#125; else &#123; console.log(`\\t $&#123;key&#125;: $&#123;obj[key]&#125;`) &#125; &#125; &#125;&#125; 1234567891011121314151617181920// index.tsimport &#123; classDecorator, methodDecorator, printDecoratoar &#125; from &#x27;./decorator&#x27;@classDecorator(&#x27;用户&#x27;)class User &#123; @methodDecorator(&#x27;用户名&#x27;) username: string = &#x27;&#x27; @methodDecorator(&#x27;密码&#x27;) password: string = &#x27;&#x27;&#125;const user = new User()user.username = &#x27;jacky&#x27;user.password = &#x27;123456&#x27;printDecoratoar(user)// 用户// 用户名: jacky// 密码: 123456 reflect-metadata库该库的作用：保存元数据 使用： 12345678910111213141516// 直接导入reflect-metadata库，会在全局作用import &#x27;reflect-metadata&#x27;// 通过metadata设置User类上的装饰器，传入key：userClass，value：用户@Reflect.metadata(&#x27;userClass&#x27;, &#x27;用户&#x27;)class User &#123; // 通过metadata设置User类上属性username的装饰器，传入key：userProp，value：用户名 @Reflect.metadata(&#x27;userProp&#x27;, &#x27;用户名&#x27;) username!: string&#125;const u = new User()// 通过getMetadata获取User类上的元数据，需要传入key和User类console.log(Reflect.getMetadata(&#x27;userClass&#x27;, User))// 通过getMetadata获取User类中username属性的元数据，需要传入key、实例对象、属性名称console.log(Reflect.getMetadata(&#x27;userProp&#x27;, u, &#x27;username&#x27;)) 示例： 使用reflect-metadata来优化之前的综合示例 可以大量减少代码 不会对原型造成污染 1234567891011121314151617181920212223242526272829303132333435363738394041424344// decorator.tsimport &#x27;reflect-metadata&#x27;// 使用Symbol.for方法来创建一个symbol对象，这个对象在系统中一定是唯一的const key = Symbol.for(&#x27;decorator&#x27;)/** * 通过Reflect.metadata设置元数据 * key为唯一的键 * decorator为设置的元数据值 */export function decorator(decorator: string) &#123; return Reflect.metadata(key, decorator)&#125;export function printDecoratoar(obj: any) &#123; // 获取类 const objClass = Object.getPrototypeOf(obj) /** * 输出类的名字 * 通过Reflect.hasMetadata查看类上是否有元数据 * 如果有则通过Reflect.getMetadata来获取元数据 * 如果没有则打印类的名称（constructor.name） */ if (Reflect.hasMetadata(key, objClass)) &#123; console.log(Reflect.getMetadata(key, objClass)) &#125; else &#123; console.log(objClass.constructor.name) &#125; /** * 输出属性的名字 * 通过for in循环遍历类上的所有属性名称 * 通过Reflect.hasMetadata来判断是否存在属性的元数据 * 如果存在则打印元数据的value值和属性值 * 如果不存在则打印属性名称keyName和属性值 */ for (const keyName in obj) &#123; if (Reflect.hasMetadata(key, obj, keyName)) &#123; console.log(`\\t $&#123;Reflect.getMetadata(key, obj, keyName)&#125;: $&#123;obj[keyName]&#125;`) &#125; else &#123; console.log(`\\t $&#123;keyName&#125;: $&#123;obj[keyName]&#125;`) &#125; &#125;&#125; class-validator库这个库是基于reflect-metadata的，可以使用装饰器的方式来对类、类属性做验证。在属性上定义验证装饰器规则，通过validate来验证装饰器规则。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import &#x27;reflect-metadata&#x27;import &#123; IsNotEmpty, MinLength, MaxLength, validate, IsEmail, Max, Min, IsBoolean&#125; from &#x27;class-validator&#x27;class User &#123; @IsNotEmpty(&#123; message: &#x27;名称不能为空&#x27; &#125;) @MinLength(3, &#123; message: &#x27;名称不能少于2字符&#x27; &#125;) @MaxLength(20, &#123; message: &#x27;名称不能超过12个字符&#x27; &#125;) name!: string @IsNotEmpty(&#123; message: &#x27;邮箱不能为空&#x27; &#125;) @IsEmail(&#123;&#125;, &#123; message: &#x27;邮箱格式不正确&#x27; &#125;) email!: string @IsNotEmpty(&#123; message: &#x27;密码不能为空&#x27; &#125;) @MinLength(6, &#123; message: &#x27;密码不能少于6字符&#x27; &#125;) @MaxLength(20, &#123; message: &#x27;密码不能超过12个字符&#x27; &#125;) password!: string @Min(18, &#123; message: &#x27;年龄不能小于18岁&#x27; &#125;) @Max(120, &#123; message: &#x27;年龄不能大于120岁&#x27; &#125;) age!: number @IsBoolean(&#123; message: &#x27;性别必须为布尔值&#x27; &#125;) gender!: boolean&#125;const user = new User()user.name = &#x27;ja&#x27;user.email = &#x27;jacky@qq.com&#x27;user.password = &#x27;123456&#x27;user.age = 21user.gender = true/** * class-validator验证器 * 验证上述装饰器中是否有错误 */validate(user).then(errors =&gt; &#123; if (errors.length &gt; 0) &#123; console.log(errors) &#125;&#125;)// 错误返回结果// [ // ValidationError &#123;// target: User &#123;// name: &#x27;ja&#x27;,// email: &#x27;jacky@qq.com&#x27;,// password: &#x27;123456&#x27;,// age: 21,// gender: true// &#125;,// value: &#x27;ja&#x27;,// property: &#x27;name&#x27;,// children: [],// constraints: &#123; minLength: &#x27;名称不能少于2字符&#x27; &#125;// &#125;// ] class-transformer 库也依赖于reflect-metadata库，能将对象从平面对象转为类的对象。简单来说就是将平面对象与类对象进行映射，从而获取类对象中的一些方法来处理平面对象中的属性数据。 平面对象：通过大括号书写的对象就是一个平面对象，通过ajax从远程获取的json对象也是一个平面对象。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#x27;reflect-metadata&#x27;import &#123; Type, plainToClass &#125; from &#x27;class-transformer&#x27;import axios from &#x27;axios&#x27;class User &#123; id!: number @Type(() =&gt; Number) age!: number lastName!: string firstName!: string getName() &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; isAdult() &#123; return this.age &gt; 36 &amp;&amp; this.age &lt; 60 &#125;&#125;// https://www.myjsons.com/v/87ec1597// [// &#123;// id: 1,// age: &#x27;27&#x27;,// lastName: &#x27;Cage&#x27;,// firstName: &#x27;Johny&#x27;// &#125;,// &#123;// id: 2,// age: &#x27;50&#x27;,// lastName: &#x27;Somoni&#x27;,// firstName: &#x27;Ismoil&#x27;// &#125;,// &#123;// id: 3,// age: &#x27;12&#x27;,// lastName: &#x27;Dacascos&#x27;,// firstName: &#x27;Luke&#x27;// &#125;// ]const result = axios .get(&#x27;https://www.myjsons.com/v/87ec1597&#x27;) .then(res =&gt; res.data) .then(users =&gt; &#123; /** * 将获取到的users数据与User类进行映射 * 使用plainToClass方法，传入User类和users数据 */ const userClass = plainToClass(User, users) /** * 通过for of循环遍历获取到映射后的数据中的每一项值 * 并通过User类上的方法getName()和isAdult()来处理数据 * 通过装饰器设置将age的类型从string转换为number */ for (const user of Object.values(userClass)) &#123; console.log(user.getName(), user.isAdult()) console.log(&#x27;Fullname: &#x27;, user.getName()) console.log(&#x27;IsAdult: &#x27;, user.isAdult()) console.log(&#x27;Age: &#x27;, user.age, &#x27;Age Type: &#x27;, typeof user.age) console.log(&#x27;\\n&#x27;) &#125; &#125;) 参数装饰器要求函数有三个参数： 如果方法是静态的，则为类本身；如果方法是实例方法，则为类的原型 方法名称 在参数列表中的索引 示例： 1234567891011121314151617class User &#123; firstName!: string lastName!: string getFullName( firstName: string, @setName lastName: string ) &#123; return firstName + &#x27; &#x27; + lastName &#125;&#125;function setName(target: any, method: string, index: number) &#123; console.log(target, method, index) // &#123;&#125; getFullName 1&#125; 类型演算根据已知的类型，计算出新的类型 typeofTS中的typeof，书写的位置在类型约束的位置上。 表示：获取某个数据的类型 示例： 123456789101112131415/** * 变量a的类型为字面量类型abscsd * 变量b使用typeof a将类型指向a的字面量类型abscsd * 所以b的类型只能为字母abscsd，值只能为abscsd */const a = &#x27;abscsd&#x27;let b: typeof a = &#x27;abscsd&#x27;/** * 变量c指定了类型为string * 变量d使用typeof c将类型指向了c的类型string * 所以c的类型也为string */const c: string = &#x27;abscsd&#x27;let d: typeof c = &#x27;234234&#x27; 当typeof作用于类的时候，得到的类型，是该类的构造函数 示例： 12345678910111213class User &#123; username!: string password!: string&#125;/** * 在函数中通过参数导入一个class类，返回一个该类的实例 * 参数cls通过typeof 指向User类的构造函数，指向类的本身 */function createUser(cls: typeof User): User &#123; return new cls()&#125;const u = createUser(User) keyof作用于类、接口、类型别名，用于获取其他类型中的所有成员名组成的联合类型。 示例： 123456789101112131415161718192021interface User &#123; username: string password: string&#125;/** * printUserProp函数的参数key，需要使用到接口User中所有属性的联合类型作为参数类型 * 如果接口发生变化，就需要调整key中的联合类型 * 使用keyof User来获取User中所有属性，并会自动计算变化的属性情况，无需再手工调整 */// function printUserProp(obj: User, key: &quot;username&quot; | &quot;password&quot;) &#123;function printUserProp(obj: User, key: keyof User) &#123; console.log(obj[key])&#125;const user: User = &#123; username: &#x27;jacky&#x27;, password: &#x27;123456&#x27;&#125;printUserProp(user, &#x27;username&#x27;) // jacky 示例： 1234567891011121314151617181920212223242526interface User &#123; username: string password: string age: number&#125;/** * 使用userObj类型别名，中的索引器，来对接口User中的属性进行约束 * 索引器指定类型为接口User中的属性名称，指定类型为string * 可以使用keyof升级下联合类型的使用 */type userObj = &#123; [p in keyof User]: string // [p in &#x27;username&#x27; | &#x27;password&#x27; | &#x27;age&#x27;]: string /* * * 索引器代码等同于如下代码 * username:string, * password:string, * age:string */&#125;const u: userObj = &#123; username: &#x27;jacky&#x27;, password: &#x27;123456&#x27;, age: &#x27;12&#x27;&#125; 根据上面的示例，做个升级 将接口User中的属性都作为只读属性，创建User的对象后，不允许修改 再做个升级，使用泛型，将类型别名作为通用的，不仅限制User接口，其他接口也可以将其变为只读属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071interface User &#123; username: string password: string age: number&#125;type userObj = &#123; readonly [p in keyof User]: User[p]&#125;const user: userObj = &#123; username: &#x27;jacky&#x27;, password: &#x27;123456&#x27;, age: 12&#125;// user.age = 13 // 无法为“age”赋值，因为它是只读属性。/** * 使用泛型给类型别名propObj来做通用约束 * 索引器p 只能为泛型中的属性，并且必须是只读，属性的类型同泛型中的属性类型一致 */type propObj&lt;T&gt; = &#123; readonly [p in keyof T]: T[p]&#125;const u: propObj&lt;User&gt; = &#123; username: &#x27;jacky&#x27;, password: &#x27;123456&#x27;, age: 12&#125;// u.age = 13 // 无法为“age”赋值，因为它是只读属性。interface Article &#123; title: string description: string content: string date: Date&#125;const article: propObj&lt;Article&gt; = &#123; title: &#x27;hello&#x27;, description: &#x27;world&#x27;, content: &#x27;hello world&#x27;, date: new Date()&#125;// article.title = &#x27;hello world&#x27; // 无法为“title”赋值，因为它是只读属性。// /**// * 使用userObj类型别名，中的索引器，来对接口User中的属性进行约束// * 索引器指定类型为接口User中的属性名称，指定类型为string// * 可以使用keyof升级下联合类型的使用// */// type userObj = &#123;// [p in keyof User]: string// // [p in &#x27;username&#x27; | &#x27;password&#x27; | &#x27;age&#x27;]: string// /* *// * 索引器代码等同于如下代码// * username:string,// * password:string,// * age:string// */// &#125;// const u: userObj = &#123;// username: &#x27;jacky&#x27;,// password: &#x27;123456&#x27;,// age: &#x27;12&#x27;// &#125; TS中预设的类型演算 Partial ：将类型T中的成员变为可选 123456789101112131415interface User &#123; username: string password: string&#125;// 设置变量u的类型为 可选的User类型let u: Partial&lt;User&gt;/** * 给u赋值为空对象时也不会报错，因为属性都是可选的 * 如果赋值username属性，可以看到属性也是可选的 */u = &#123; username: &#x27;jacky&#x27; // (property) username?: string | undefined&#125; Required ：将类型T中的成员变为必填 123456789101112131415interface User &#123; username?: string password?: string&#125;// 设置变量u的类型为 必选的User类型let u: Required&lt;User&gt;/** * 如果不给变量u赋值完整的属性就会报错：类型 &quot;&#123; username: string; &#125;&quot; 中缺少属性 &quot;password&quot;，但类型 &quot;Required&lt;User&gt;&quot; 中需要该属性。 */u = &#123; username: &#x27;jacky&#x27;, password: &#x27;123&#x27;&#125; Readonly ：将类型T中的成员变为只读 123456789101112131415interface User &#123; username?: string password?: string&#125;// 设置变量u的类型为 只读的User类型let u: Readonly&lt;User&gt; = &#123; username: &#x27;jacky&#x27;, password: &#x27;123&#x27;&#125;/** * 如果给变量u的属性再次赋值，则会报错 */// u.password = &#x27;121&#x27; // 无法为“password”赋值，因为它是只读属性。 Exclude&lt;T, U&gt; ：从T中剔除可以赋值给U的类型。 12345678910111213141516171819interface User &#123; username: string email: string password: string image: string bio: string&#125;/** * 从User接口中排除password获得一个新的类型别名 */type userResponse = Exclude&lt;User, &#x27;password&#x27;&gt;const user: userResponse = &#123; username: &#x27;jacky&#x27;, email: &#x27;jacky@qq.com&#x27;, password: &#x27;123456&#x27;, image: &#x27;jacky.jpg&#x27;, bio: &#x27;jacky is a jacky&#x27;&#125; Extract&lt;T, U&gt; ：提取T中可以赋值给U的类型。 12345678910111213141516171819interface User &#123; username: string email: string password: string image: string bio: string&#125;interface Profile &#123; username: string email: string token: string&#125;/** * type userResponse = &quot;username&quot; | &quot;email&quot; * 相当于User和Profile的交集 */type userResponse = Extract&lt;keyof User, keyof Profile&gt; NonNullable ： 从T中剔除null和undefined。 123456789type username = string | null | undefined/** * type getUsername = string * NonNullable会把null和undefined去掉 */type getUsername = NonNullable&lt;username&gt;const username: getUsername = &#x27;jacky&#x27; ReturnType ：获取函数返回值类型。 123456789101112131415161718192021222324type getUser = () =&gt; string/** * type returnGetUser = string * 从一个函数类型getUser中推断出其返回类型 */type returnGetUser = ReturnType&lt;getUser&gt;// 从一个具体的函数中获取其返回类型function sum(a: number, b: number) &#123; return a + b&#125;function sum2(a: number, b: number) &#123; return a.toString() + b.toString()&#125;/** * let type: number * 通过ReturnType推断函数sum的返回值 * 需要通过typeof获取sum函数的类型 * 如果函数sum2的返回值产生了变化，推断的返回值typeof sum2类型也会发生变化 */let type: ReturnType&lt;typeof sum&gt;let type2: ReturnType&lt;typeof sum2&gt; InstanceType： 获取构造函数类型的实例类型。 预设类型演算的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Make all properties in T optional */type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;;/** * Make all properties in T required */type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P];&#125;;/** * Make all properties in T readonly */type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;;/** * Exclude from T those types that are assignable to U */type Exclude&lt;T, U&gt; = T extends U ? never : T;/** * Extract from T those types that are assignable to U */type Extract&lt;T, U&gt; = T extends U ? T : never;/** * Exclude null and undefined from T */type NonNullable&lt;T&gt; = T &amp; &#123;&#125;;/** * Obtain the return type of a function type */type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;/** * Obtain the return type of a constructor function type */type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any; 声明文件概述什么是声明文件单独使用的模块，一般会同时提供一个单独的类型声明文件（declaration file），把本模块的外部接口的所有类型都写在这个文件里面，便于模块使用者了解接口，也便于编译器检查使用者的用法是否正确。 类型声明文件里面只有类型代码，没有具体的代码实现。它的文件名一般为[模块名].d.ts的形式，其中的d表示 declaration（声明）。 声明文件有什么用为JS代码提供类型声明 放声明文件的位置 放置到tsconfig.json配置中包含include的目录中 123456&#123; &quot;compilerOptions&quot;: &#123; ... &#125;, &quot;include&quot;: [&quot;./src&quot;]&#125; 放置到node_modules/@types文件夹中 手动配置tsconfig.json中的typeRoot配置项，注意使用此配置项后，之前的在tsconfig.json中配置的include、node_modules/@types文件夹中的声明文件就会失效，所以需要在此配置项中增加之前的默认配置位置 12345&#123; &quot;compilerOptions&quot;: &#123; &quot;typeRoots&quot;: [&quot;node_modules/@types&quot;, &quot;./types&quot;] &#125;&#125; 与JS代码所在目录相同，并且文件名也相同的文件。用ts代码书写的工程发布之后的格式。 1234// srcsrc |- index.js |- index.d.ts 编写声明文件类型声明文件的来源主要有以下几个： TypeScript 编译器自动生成。 TypeScript 内置类型文件。 外部模块的类型声明文件，需要自己安装。 自动生成工程是使用ts开发的，发布（编译）之后，是js文件，发布的是js文件。 如果发布的文件，需要其他开发者使用，可以使用声明文件，来描述发布结果中的类型。 只要使用编译选项declaration，编译器就会在编译时自动生成单独的类型声明文件。 12345&#123; &quot;compilerOptions&quot;: &#123; &quot;declaration&quot;: true &#125;&#125; 手动编写什么场景下需要手动编写？ 对已有库，它是使用js书写而成，并且更改该库的代码为ts成本较高，可以手动编写声明文件 对一些第三方库，它们使用js书写而成，并且这些第三方库没有提供声明文件，可以手动编写声明文件。 全局声明声明一些全局的对象、属性、变量 示例： 给console对象下的方法log添加类型声明 1234567// src/index.tsconselo.log(&quot;hello world&quot;)// src/global.d.tsdeclare var console: &#123; log: (...args: any[]) =&gt; void&#125; 如果有多个类似的类型声明，我们可以使用接口 1234567891011// src/index.tsconsole.log(&#x27;Hello World&#x27;)console.error(&#x27;error&#x27;)// src/global.d.tsinterface Conselo &#123; log: (...args: any[]) =&gt; void error: (...args: any[]) =&gt; void&#125;declare var console: Conselo 给方法添加声明 1234567// src/index.tssetTimeout(() =&gt; &#123; console.log(&#x27;Hello World 2&#x27;)&#125;, 2000)// src/global.d.tsdeclare var setTimeout: (callback: (...args: any[]) =&gt; void, ms: number) =&gt; number 使用命名空间namespace来进行声明 namespace: 表示命名空间，可以将其认为是一个对象，命名空间中的内容，必须通过命名空间.成员名访问 123456789// src/index.tsconsole.log(&#x27;Hello World&#x27;)console.error(&#x27;error&#x27;)// src/global.d.tsdeclare namespace console &#123; const log: (...args: any[]) =&gt; void const error: (...args: any[]) =&gt; void&#125; 模块声明示例： 添加lodash第三方库，给库的模块进行声明 12345// src/index.tsimport _ from &#x27;lodash&#x27;const chunk = _.chunk([1, 2, 3, 4, 5], 2)console.log(chunk) // [ [ 1, 2 ], [ 3, 4 ], [ 5 ] ] 注意：给lodash库做声明时，需要配置tsconfig.json中typeRoots设置声明文件的位置。&quot;typeRoots&quot;: [&quot;./src/types&quot;, &quot;./node_modules/@types&quot;]，否则会编译报错。 1234// src/types/lodash/index.d.tsdeclare module &#x27;lodash&#x27; &#123; export function chunk&lt;T&gt;(array: T[], size: number): T[][]&#125; 代码释义： 声明模块lodash中的chunk方法，使用泛型，参数为一个泛型数组，和number，返回一个泛型数组的数组 三斜线指令在一个声明文件中，包含另一个声明文件 示例： 如果给lodash的声明，我们放在了根目录下，那么可以使用三斜指令，将文件引入到配置的src/types/lodash/index.d.ts文件中 123// src/types/lodash/index.d.ts/// &lt;reference path=&quot;../../../lodash.d.ts&quot; /&gt; 使用第三方的声明文件通过安装第三方的类型文件，解决没有类型文件的问题。 示例： 给lodash安装类型声明文件 1pnpm add @types/lodash 测试效果： 12345import _ from &#x27;lodash&#x27;console.log(_.chunk([1, 2, 3, 4, 5], 2)) // [[1, 2], [3, 4], [5]]console.log(_.isEmpty(null)) //trueconsole.log(_.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;-&#x27;)) //a-b-c 注意：如果安装第三方的声明文件，注意原来配置的typeRoots配置项，容易造成错误 发布如果需要将自己编写的声明文件发布到官方的@types中，流程如下： 1） 进入github的开源项目：https://github.com/DefinitelyTyped/DefinitelyTyped 2） fork到自己的开源库中 3） 从自己的开源库中克隆到本地 4） 本地新建分支（例如：mylodash4.3），在新分支中进行声明文件的开发。在types目录中新建文件夹，在新的文件夹中开发声明文件 5） push分支到你的开源库 6） 到官方的开源库中，提交pull request 7） 等待官方管理员审核（1天） 审核通过之后，会将你的分支代码合并到主分支，然后发布到npm。 之后，就可以通过命令npm install @types/你发布的库名","permalink":"http://example.com/2023/10/05/TypeScript-%E8%BF%9B%E9%98%B6/","photos":[]},{"tags":[{"name":"typescript","slug":"typescript","permalink":"http://example.com/tags/typescript/"}],"title":"TypeScript 基础","date":"2023/10/05","text":"JavaScript的问题 使用了不存在的变量、函数或成员 把一个不确定的类型当作一个确定的类型处理 在使用null或undefined的成员 示例示例中的代码在JavaScript中运行没有问题，但是存在类型隐式转换，当getUserName函数返回404这个数值时，导致myName使用string类型的方法报错。 1234567891011121314function getUserName() &#123; if (Math.random() &gt; 0.5) &#123; return &#x27;John Doe&#x27; &#125; else &#123; return 404 &#125;&#125;let myName = getUserName()myName = myName .split(&#x27;&#x27;) .filter(m =&gt; m) .map(m =&gt; m[0].toUpperCase()) .join(&#x27;&#x27;) 在TypeScript的环境下，split方法就会出现错误提示： 类型“string | number”上不存在属性“split”。 类型“number”上不存在属性“split”。 并且还会提示filter的m、map的m上也会有提示： 参数“m”隐式具有“any”类型。 在TypeScript的帮助下，使用正确的类型限制，消除错误风险。 12345678910111213141516function getUserName(): string | number &#123; if (Math.random() &gt; 0.5) &#123; return &#x27;John Doe&#x27; &#125; else &#123; return 404 &#125;&#125;let myName = getUserName()if (typeof myName === &#x27;string&#x27;) &#123; myName = myName .split(&#x27;&#x27;) .filter(m =&gt; m) .map(m =&gt; m[0].toUpperCase()) .join(&#x27;&#x27;)&#125; JavaScript的原罪 JavaScript语言本身的特性，决定了该语言无法适应大型的复杂的项目 弱类型：某个变量，可以随时更换类型。 解释性：错误发生的时间，是在运行时 TypeScriptTypeScript简称Ts，TypeScript是JavaScript的超集（类似Less、Sass是Css的超集一样），是一个可选的、静态的类型系统。 类型系统 对代码中所有的标识符（变量、函数、参数、返回值）进行类型检查 可选的 学习曲线非常平滑。 静态的(在运行之前) 无论是浏览器环境，还是node环境，无法直接识别ts代码。需要借助tsc（TypeScript编译器）帮助将TypeScript代码转换成JavaScript代码。 静态：类型检查发生的时间，在编译的时候，而非运行时，TypeScript不参与任何运行时的类型检查。 TypeScript的介绍 2012年微软发布 （ES6，ES2015） Anders Hejlsberg 负责开发TypeScript项目 开源、拥抱ES标准 版本5.5 官网：http://www.typescriptlang.org/ TypeScript的好处 有了类型检查，增强了面向对象的开发 JavaScript中也有类和对象，JavaScript支持面向对象开发。没有类型检查，很多面向对象的场景实现起来有诸多问题。 使用TypeScript后，可以编写出完善的面向对象代码。 在Node中搭建TypeScript开发环境安装12345# 安装TypeScriptpnpm add typescript -g# 安装tsc编译器pnpm add tsc -g 示例12// index.tslet username:string = &#x27;jacky&#x27; 使用tsc编译TypeScript代码 1tsc index.ts 编译后在当前目录下生成index.js代码 12// index.jsvar username = &#x27;jacky&#x27; 问题在生成index.js后，index.ts中的username会报错。index.js中已经有了变量username，但index.ts中又声明了相同的变量名称，导致变量名全局污染。因为默认情况下，TS会做出下面几种假设： 假设当前的执行环境是dom 如果代码中没有使用模块化语句（import、export），便认为该代码是全局执行 编译的目标代码是ES3 有两种方式更改以上假设： 使用tsc命令行的时候，加上选项参数，比较繁琐 使用ts配置文件，更改编译选项，推荐。 TypeScript配置文件实现方式有两种： 手动在项目根目录下添加tsconfig.json文件 通过命令生成tsconfig.json文件 1tsc --init 使用了配置文件后，使用tsc进行编译时，不能跟上文件名，如果跟上文件名，会忽略配置文件。直接运行tsc即可 1tsc tsconfig.json说明1234567&#123; &quot;compilerOptions&quot;: &#123; // 编译选项 &quot;target&quot;: &quot;es2016&quot;, /* 配置编译目标代码的版本 */ &quot;module&quot;: &quot;commonjs&quot;, /* 配置编译模块的模块化标准 */ &quot;lib&quot;: [&quot;es2016&quot;], /* 指定一组描述目标运行时环境的捆绑库声明文件，默认情况下包含dom */ &#125;&#125; 示例：123// index.tslet say = &#x27;hello&#x27;console.log(say) 由于缺少node环境库，使用console.log会报错，提示：Cannot find name &#39;console。 原因lib&quot;: [&quot;es2016&quot;]中并不包含node环境库，所以需要通过安装第三方包（@type/node）来补充。 1pnpm add @type/node -D @types是一个ts官方的类型库，其中包含了很多对js代码的类型描述。例如：JQuery使用js写的，没有类型检查 安装@types/jquery，为jquery库添加类型定义。 指定编译目录和输出编译文件目录通常情况下，需要将代码放到src目录下，将index.ts放到src目录下，执行tsc，会在src目录下生成编译文件。这时可以在tsconfig.json中进行配置，指定需要编译的目录和指定输出的编译文件的目录 123456789&#123; &quot;compilerOptions&quot;: &#123; // 编译选项 &quot;target&quot;: &quot;es2016&quot;, /* 配置编译目标代码的版本 */ &quot;module&quot;: &quot;commonjs&quot;, /* 配置编译模块的模块化标准 */ &quot;lib&quot;: [&quot;es2016&quot;], /* 指定一组描述目标运行时环境的捆绑库声明文件，默认情况下包含dom */ &quot;outDir&quot;: &quot;./dist&quot; /* 为所有编译的文件指定一个输出文件夹。 */ &#125;, &quot;include&quot;: [&quot;src&quot;] /* 指定需要编译的目录，可以写入多个目录，此目录之外的ts内容将不会被编译 */&#125; 使用第三方库简化操作流程ts-node: 将ts代码在内存中完成编译，同时完成运行 1pnpm add ts-node -g nodemon: 用于检测文件的变化 1pnpm add nodemon -g 可以在package.json中配置scripts 12345&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon -e ts --watch ./src --exec ts-node ./src/index.ts&quot; &#125;,&#125; nodemon --exec ts-node ./src/index.ts：使用nodemon 当文件发生变化时来执行（--exec）ts-node这个命令，使用ts-node来编译./src/index.ts代码。 -e ts：监控的文件扩展名extension为ts，其他文件不受监控。 --watch ./src：监控的目录，此目录之外的文件不受监控。 当在开发时使用pnpm dev来执行配置好的运行时脚本。在开发完成之后，使用tsc来编译ts文件生成对应的js 类型约束TypeScript是一个可选的静态的类型系统。 仅需要在 变量、函数的参数、函数的返回值位置加上:类型 示例： 1let say: string = &#x27;hello&#x27; TypeScript在很多场景中可以完成类型推导 示例： 12345function sum(a: number, b: number): number &#123; return a + b;&#125;const result: number = sum(1, 2); 类型推导我们可以省略掉一些类型，TypeScript会自动推导对应的类型 12345function sum(a: number, b: number) &#123; return a + b&#125;const result = sum(1, 2) 小技巧：选中变量，按F2键，或者在变量上右键，在右键菜单中选择 重命名符号 在输入框中可以修改变量名称，修改后之前所有引用到该变量的变量名都会进行同步修改。 any类型示例： 1let foo 此种情况下，TypeScript并不能推导出该变量的类型，会在foo下显示三个点，提示该变量类型为any类型，表示任意类型，对该类型，TypeScript不进行类型检查 如何区分数字字符串和数字示例： 1let phone: string = &#x27;13333333333&#x27; 小技巧：关键看怎么读？ 如果按照数字的方式朗读，则为数字；否则，为字符串。 源代码和编译结果的差异示例： 12345678// src/index.tsfunction sum2(a: number, b: number) &#123; return a + b&#125;const result = sum2(1, 2)let foolet phone = &#x27;13333333333&#x27; 编译结果 1234567// dist/index.jsfunction sum2(a, b) &#123; return a + b;&#125;const result = sum2(1, 2);let foo;let phone = &#x27;13333333333&#x27;; 编译结果中没有类型约束信息 基本类型 number： 数值 1let num: number = 123 string：字符串 1let foo: string = &#x27;bar&#x27; boolean：布尔 123456function isOdd(n: number): boolean &#123; if(n % 2 === 0) &#123; return false &#125; return true&#125; array：数组 number[]是Array&lt;number&gt;的语法糖 123let nums: number[] = [1,2,3]// 或者let nums: Array&lt;number&gt; = [1,2,3] object：对象 此类型用的比较少，缺乏对象内容的约束，只能约束变量是个对象。 1234567891011let obj: object = &#123;&#125;function printValues(obj: object) &#123; const values = Object.values(obj) values.map(value =&gt; console.log(value))&#125;printValues(&#123; a: &#x27;Hello&#x27;, b: 123&#125;) null和undefined：空值和未定义 1let n: string = undefined null和undefined是所有其他类型的子类型，它们可以赋值给其他类型 通过添加strictNullChecks:true，可以获得更严格的空类型检查，null和undefined只能赋值给自身。 其他常用类型 联合类型：多种类型任选其一 123456let name: string | undefinedname = &#x27;jacky&#x27;if (typeof name === &#x27;string&#x27;) &#123; console.log(name.length)&#125; 配合类型保护进行判断。当对某个变量进行类型判断之后，在判断的语句块中便可以确定它的确切类型，`typeof`可以触发类型保护。 void类型：通常用于约束函数的返回值，表示该函数没有任何返回 123function printName(): void &#123; console.log(&#x27;jacky&#x27;)&#125; never类型：通常用于约束函数的返回值，表示该函数永远不可能结束 12345678910// 报错function throwError(message: string): never &#123; throw new Error(message)&#125;// 死循环function alwaysRun(): never &#123; while (true) &#123; console.log(&#x27;always run&#x27;) &#125;&#125; 字面量类型：使用一个值进行约束 12345678910111213141516171819202122let str:&quot;foo&quot;;// 只能赋值为foostr = &quot;foo&quot;;// 通过联合类型，限制赋值范围let gender: 0 | 1gender = 0gender = 1// arr永远只能取值为空数组let arr: [] = []// 初始化一个对象let user: &#123; name: string age: number&#125;user = &#123; name: &#x27;jacky&#x27;, age: 18&#125; 元祖类型Tuple：一个固定长度的数组，并且数组中每一项的类型确定 123let user: [string, number]// 只能给user赋值为字符串+数值两项的数组user = [&#x27;John&#x27;, 23] any类型：any类型可以绕过类型检查，因此，any类型的数据可以赋值给任意类型 123let data: any = &#x27;foo&#x27;// 存在安全隐患，不建议使用此类型赋值let num: number = data 函数相关类型约束类型别名对已知的一些类型定义名称 1type Name = string 示例： 12345678910111213141516171819type Gender = &#x27;male&#x27; | &#x27;female&#x27;type User = &#123; name: string age: number gender: Gender&#125;function getUser(user: User) &#123; return console.log(user)&#125;const user: User = &#123; name: &#x27;John&#x27;, age: 30, gender: &#x27;male&#x27;&#125;const myUser = getUser(user) 注意，在定义user时，必须指定user的类型为User，否则会把user.gender赋值的male当做字符串类型，而不是Gender类型 函数重载在函数实现之前，对函数调用的多种情况进行声明 示例： 定义函数combine只能传入都是number或都是string类型的参数，否则报错。 1234567891011121314function combine(a: number, b: number): numberfunction combine(a: string, b: string): stringfunction combine(a: number | string, b: number | string): any &#123; if (typeof a === &#x27;number&#x27; &amp;&amp; typeof b === &#x27;number&#x27;) &#123; return a * b &#125; if (typeof a === &#x27;string&#x27; &amp;&amp; typeof b === &#x27;string&#x27;) &#123; return a + b &#125;&#125;console.log(combine(2, 2))console.log(combine(&#x27;a&#x27;, &#x27;b&#x27;)) 可选参数可以在某些参数名后加上问号，表示该参数可以不用传递。可选参数必须在参数列表的末尾。 示例： 123456789101112131415161718// 设置c为可选参数function sum(a: number, b: number, c?: number) &#123; if (c) &#123; return a + b + c &#125; else &#123; return a + b &#125;&#125;console.log(sum(1, 2))console.log(sum(1, 2, 3))// c 的默认值为0，表示c为可选参数function sum2(a: number, b: number, c: number = 0) &#123; return a + b + c&#125;console.log(sum2(1, 2)) 综合示例创建一副扑克，不包含大小王，并打印出每个扑克。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 定义一个Poke类型为Card类型的数组type Poke = Card[]// 定义一个Card类型为一个花色和数字的对象type Card = &#123; color: Color mark: number&#125;// 定义一个Color类型为花色type Color = &#x27;♠&#x27; | &#x27;♣&#x27; | &#x27;♥&#x27; | &#x27;♦&#x27;// 创建poke的函数function createPoke(): Poke &#123; // 定义一个扑克的数组 const pokes: Poke = [] // 循环13个数，按花色放到数组，组成扑克 for (let index = 1; index &lt;= 13; index++) &#123; pokes.push(&#123; color: &#x27;♠&#x27;, mark: index &#125;) pokes.push(&#123; color: &#x27;♣&#x27;, mark: index &#125;) pokes.push(&#123; color: &#x27;♥&#x27;, mark: index &#125;) pokes.push(&#123; color: &#x27;♦&#x27;, mark: index &#125;) &#125; return pokes&#125;// 打印plke的函数function printPoke(pokes: Poke) &#123; // 给结果加换行符 let reslut = &#x27;\\n&#x27; // 遍历扑克，并按照数字返回每张扑克的花色和数字 // 1 设置A、11设置J、12设置Q、13设置K pokes.forEach((poke, i) =&gt; &#123; let card = poke.color if (poke.mark &gt; 1 &amp;&amp; poke.mark &lt;= 10) &#123; card += poke.mark &#125; else if (poke.mark === 11) &#123; card += &#x27;J&#x27; &#125; else if (poke.mark === 12) &#123; card += &#x27;Q&#x27; &#125; else if (poke.mark === 13) &#123; card += &#x27;K&#x27; &#125; else &#123; card += &#x27;A&#x27; &#125; // 根据结果，给每张扑克加一个制表符，增加间距 reslut += `$&#123;card&#125;\\t` // 每隔 13 张扑克 增加一个换行符 if ((i + 1) % 13 === 0) &#123; reslut += &#x27;\\n&#x27; &#125; &#125;) console.log(reslut)&#125;// 创建并打印扑克const pokes = createPoke()printPoke(pokes) 扩展类型枚举枚举通常用于约束某个变量的取值范围。字面量和联合类型配合使用，也可以达到同样的目标。 字面量类型的问题 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题。 12345678910111213141516171819202122let gender: &#x27;male&#x27; | &#x27;female&#x27;// 使用字面量会造成重复代码function getuser(gender: &#x27;male&#x27; | &#x27;female&#x27;) &#123; if (gender === &#x27;male&#x27;) &#123; return &#x27;male&#x27; &#125; else &#123; return &#x27;female&#x27; &#125;&#125;getuser(&#x27;female&#x27;)// 使用类型别名解决重复代码问题type Gender = &#x27;male&#x27; | &#x27;female&#x27;let gender: Genderfunction getuser(gender: Gender) &#123; if (gender === &#x27;male&#x27;) &#123; return &#x27;male&#x27; &#125; else &#123; return &#x27;female&#x27; &#125;&#125;getuser(&#x27;female&#x27;) 逻辑含义和真实的值产生了混淆，会导致当修改真实值的时候，产生大量的修改。 上述的例子中，只解决了重复问题，无法解决逻辑值与真实值的问题。比如：性别，在数据库中只会存为1和2，用1表示male，2表示female。在实际代码中如果使用字面量和类型别名，则无法表示1和male，2和female的关系。 字面量类型不会进入到编译结果。 枚举枚举是一些命名常量值的组合，Enum 代表枚举类型，按照下面的步骤来定义枚举： 首先，把变量名写在 enum 关键字之后； 然后，定义枚举中的常量值。 语法： 1enum name &#123;constant1, constant2, ...&#125;; 示例： 12345678910// 没有指定值的枚举enum Days &#123; Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125; 通常这种没有指定值的枚举，TypeScript其实会默认作为数值枚举类，自动给每个常量设置从0开始的数值，比如：(enum member) Days.Monday = 0 手动赋值12345678910// 指定首个常量的数值enum Days &#123; Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday&#125; 给首个常量赋值后，后续会自动自增赋值。 字符枚举将枚举常量定义为字符串的形式。使用时类似对象的用法，需要使用 枚举name.枚举常量 的形式 1234567891011121314enum Gender &#123; male = 1, female = 2&#125;function getUser(gender: Gender) &#123; if (gender === Gender.male) &#123; return &#x27;male&#x27; &#125; else &#123; return &#x27;female&#x27; &#125;&#125;console.log(getUser(Gender.male)) // male 枚举会出现在编译结果中，编译结果中表现为对象。 枚举的规则 枚举的字段值可以是字符串或数字 数字枚举的值会自动自增 被数字枚举约束的变量，可以直接赋值为数字 数字枚举的编译结果 和 字符串枚举有差异 最佳实践 尽量不要在一个枚举中既出现字符串字段，又出现数字字段 使用枚举时，尽量使用枚举字段的名称，而不使用真实的值 综合示例使用枚举来优化之前的扑克示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 定义一个Poke类型为Card类型的数组type Poke = Card[]// 定义一个Card类型为一个花色和数字的对象type Card = &#123; color: Color mark: Mark&#125;enum Color &#123; Spade = &#x27;♠&#x27;, Club = &#x27;♣&#x27;, Diamond = &#x27;♥&#x27;, Heart = &#x27;♦&#x27;&#125;enum Mark &#123; ace = &#x27;A&#x27;, two = &#x27;2&#x27;, three = &#x27;3&#x27;, four = &#x27;4&#x27;, five = &#x27;5&#x27;, six = &#x27;6&#x27;, seven = &#x27;7&#x27;, eight = &#x27;8&#x27;, nine = &#x27;9&#x27;, ten = &#x27;10&#x27;, jack = &#x27;J&#x27;, queen = &#x27;Q&#x27;, king = &#x27;K&#x27;&#125;// 创建poke的函数function createPoke(): Poke &#123; // 定义一个扑克的数组 const pokes: Poke = [] // 获取所有的花色值 const colors = Object.values(Color) // 获取所有牌面的值 const marks = Object.values(Mark) // 遍历所有花色和所有牌面，得到每张扑克 for (let color of colors) &#123; for (let mark of marks) &#123; // 将扑克添加到扑克数组中 pokes.push(&#123; color: color, mark: mark &#125;) &#125; &#125; console.log(pokes) return pokes&#125;// 打印plke的函数function printPoke(pokes: Poke) &#123; // 给结果加换行符 let reslut = &#x27;\\n&#x27; // 遍历扑克，并按照数字返回每张扑克的花色和数字 // 1 设置A、11设置J、12设置Q、13设置K pokes.forEach((poke, i) =&gt; &#123; // 每张扑克由花色和牌面组成 let card = poke.color + poke.mark // 根据结果，给每张扑克加一个制表符，增加间距 reslut += `$&#123;card&#125;\\t` // 每隔 13 张扑克 增加一个换行符 if ((i + 1) % 13 === 0) &#123; reslut += &#x27;\\n&#x27; &#125; &#125;) console.log(reslut)&#125;// 创建并打印扑克const pokes = createPoke()printPoke(pokes) 扩展：位枚举针对的数字枚举 位运算：两个数字换算成二进制后进行的运算 示例： 使用位运算来优雅的控制权限计算 123456789101112131415161718192021222324252627282930313233343536373839enum Permission &#123; read = 1, // 0001 write = 2, // 0010 update = 4, // 0100 delete = 8 // 1000&#125;// 使用位运算组合权限/* 使用或运算符，组合多个权限 位运算符或运算：位置上两个值只要有一个为1就是1 0001 | 0010 = 0011*/let p: Permission = Permission.read | Permission.writeconsole.log(p) // 3: 0011// 如何判断是否拥有某个权限/* 使用位运算判断 位运算符与运算：位置上两个值都为1才是1 当查询的权限值为自身时返回true 0011 &amp; 0010 = 0010*/function hasPermission(target: Permission, per: Permission) &#123; // 当查询的权限值为自身时返回true return (target &amp; per) === per&#125;console.log(hasPermission(p, Permission.read)) // true// 如何删除某个权限/* 使用位运算删除 位运算符异或运算：位置上两个值相同为0，否则为1 0011 ^ 0010 = 0001*/p = p ^ Permission.writeconsole.log(p) // 1: 0001 模块化TypeScript中，导入和导出模块，统一使用ES6的模块化标准 示例： 123456// src/demo.tsexport const username = &#x27;jacky&#x27;export const sum = (a: number, b: number): number =&gt; &#123; return a + b&#125; 使用export导出的变量和函数，在导入文件中可以很好的使用IDE的智能导入，而不需要先进行导入在使用。 12345// src/index.tsimport &#123; sum, username &#125; from &#x27;./demo&#x27;console.log(username)console.log(sum(1, 2)) 注意，在导入变量或函数时，在导入语句中，不要给导入的文件添加后缀，否则会报错。原因是，TypeScript文件需要编译成JavaScript文件，在编译后，如果导入的文件带有后缀则会保留到编译的JavaScript文件中，导致JavaScript文件报错。 编译结果中的模块化 如果编译结果的模块化标准是ES6： 没有区别 如果编译结果的模块化标准是commonjs：导出的声明会变成exports的属性，默认的导出会变成exports的default属性； 编译结果可以通过tsconfig.json来配置 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es2016&quot; /* 配置编译目标代码的版本 */, &quot;removeComments&quot;: true /* 在编译后的 JavaScript 文件中删除注释. */ &#125;&#125; 在TypeScript中书写CommonJs模块化代码导出：export = xxx 导入：import xxx = require(&quot;xxx&quot;) 使用tsc编译ts文件技巧在使用tsc编译ts时，指定了dist目录，但目录下要有之前编译过的旧文件，但在项目中已经删除了，但编译目录下还进行了保留，所以需要先删除dist目录在进行编译生成。可以在package.json文件中，新建一个scripts 12345&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;rd /s /q dist &amp;&amp; tsc&quot; &#125;&#125; rd：表示删除目录命令，但该命令只允许删除空目录 /s：强制删除目录，删除时提示是否确认删除 /q：同意所有确认命令 dist：需要删除的目录名称 &amp;&amp;：执行完前面的命令后，继续执行命令… tsc：ts编译 综合示例使用模块化来优化之前的扑克示例。 123456// src/poker/index.tsimport &#123; createPoke, printPoke &#125; from &#x27;./funcs&#x27;// 创建并打印扑克const pokes = createPoke()printPoke(pokes) 将枚举文件放到enums.ts文件中 1234567891011121314151617181920212223// src/poker/enums.tsexport enum Color &#123; Spade = &#x27;♠&#x27;, Club = &#x27;♣&#x27;, Diamond = &#x27;♥&#x27;, Heart = &#x27;♦&#x27;&#125;export enum Mark &#123; ace = &#x27;A&#x27;, two = &#x27;2&#x27;, three = &#x27;3&#x27;, four = &#x27;4&#x27;, five = &#x27;5&#x27;, six = &#x27;6&#x27;, seven = &#x27;7&#x27;, eight = &#x27;8&#x27;, nine = &#x27;9&#x27;, ten = &#x27;10&#x27;, jack = &#x27;J&#x27;, queen = &#x27;Q&#x27;, king = &#x27;K&#x27;&#125; 将类型申明文件放到tpyes.ts文件中 1234567891011// src/poker/types.tsimport &#123; Color, Mark &#125; from &#x27;./enums&#x27;// 定义一个Poke类型为Card类型的数组export type Poke = Card[]// 定义一个Card类型为一个花色和数字的对象export type Card = &#123; color: Color mark: Mark&#125; 将方法放到funcs.ts文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/poker/funcs.tsimport &#123; Color, Mark &#125; from &#x27;./enums&#x27;import &#123; Poke &#125; from &#x27;./types&#x27;// 创建poke的函数export function createPoke(): Poke &#123; // 定义一个扑克的数组 const pokes: Poke = [] // 获取所有的花色值 const colors = Object.values(Color) // 获取所有牌面的值 const marks = Object.values(Mark) // 遍历所有花色和所有牌面，得到每张扑克 for (let color of colors) &#123; for (let mark of marks) &#123; // 将扑克添加到扑克数组中 pokes.push(&#123; color: color, mark: mark &#125;) &#125; &#125; console.log(pokes) return pokes&#125;// 打印plke的函数export function printPoke(pokes: Poke) &#123; // 给结果加换行符 let reslut = &#x27;\\n&#x27; // 遍历扑克，并按照数字返回每张扑克的花色和数字 // 1 设置A、11设置J、12设置Q、13设置K pokes.forEach((poke, i) =&gt; &#123; // 每张扑克由花色和牌面组成 let card = poke.color + poke.mark // 根据结果，给每张扑克加一个制表符，增加间距 reslut += `$&#123;card&#125;\\t` // 每隔 13 张扑克 增加一个换行符 if ((i + 1) % 13 === 0) &#123; reslut += &#x27;\\n&#x27; &#125; &#125;) console.log(reslut)&#125; 注意： 在拆分文件后，不需要一个个手写导入对应的模块，可以在波浪线弹窗中选择 快速修复，选择 添加所有缺少的导入，从而快速导入所有缺少的模块。 使用模块拆分项目后，注意在tsconfig.json中需要配置&quot;module&quot;: &quot;commonjs&quot;，否则会出现 Cannot use import statement outside a module的错误 接口TypeScript的接口：用于约束类、对象、函数的契约（标准） 契约（标准）的形式： API文档，弱标准 代码约束，强标准 和类型别名一样，接口，不出现在编译结果中 接口约束 接口约束对象 123456789interface User &#123; name: string age: number&#125;const user: User = &#123; name: &#x27;jacky&#x27;, age: 18&#125; 接口约束函数 1234567891011121314interface User &#123; name: string age: number // sayHi(): void sayHi: () =&gt; void&#125;const user: User = &#123; name: &#x27;jacky&#x27;, age: 18, sayHi() &#123; console.log(&#x27;hello&#x27;) &#125;&#125; 注意：函数支持两种写法 接口的继承可以通过接口之间的继承，实现多种接口的组合 示例： 123456789101112interface Animal &#123; type: string&#125;interface Dog extends Animal &#123; name: string&#125;// dog对象中需要实现Dog接口和Animal两个接口的字段约束const dog: Dog = &#123; type: &#x27;dog&#x27;, name: &#x27;旺财&#x27;&#125; 使用类型别名可以实现类似的组合效果，需要通过&amp;，它叫做交叉类型 123456789101112type Animal = &#123; type: string&#125;type Dog = &#123; name: string&#125; &amp; Animalconst dog: Dog = &#123; type: &#x27;dog&#x27;, name: &#x27;旺财&#x27;&#125; 它们的区别： 子接口不能覆盖父接口的成员 12345678910111213interface Animal &#123; type: string&#125;interface Dog extends Animal &#123; // 接口“Dog”错误扩展接口“Animal”。 属性“type”的类型不兼容。 不能将类型“number”分配给类型“string”。 type: number name: string&#125;const dog: Dog = &#123; type: &#x27;dog&#x27;, // 不能将类型“string”分配给类型“number”。 name: &#x27;旺财&#x27;&#125; `TypeScript`中会出现两个错误，在定义的Dog接口中就会报错，告诉`type`类型不一致。在实现接口的对象中也会报错，因为接口的原因，导致出现类型冲突 交叉类型会把相同成员的类型进行交叉 12345678910111213type Animal = &#123; type: string&#125;type Dog = &#123; type: number name: string&#125; &amp; Animalconst dog: Dog = &#123; type: &#x27;dog&#x27;, // 报错：不能将类型“string”分配给类型“never”。 name: &#x27;旺财&#x27;&#125; 此时在Dog接口中，使用type: number 与Animal中的tpye:string冲突，出现了string &amp; number 这个类型不可能出现 所以就是never readonly只读修饰符，修饰的目标是只读，可以给初始变量赋值，一旦赋值完毕，不允许修改、操作 只读修饰符不在编译结果中 示例： 12345678910111213141516171819202122232425interface User &#123; readonly id: number name: string age: number readonly like: readonly string[]&#125;let user: User = &#123; id: 1, name: &#x27;张三&#x27;, age: 18, like: [&#x27;篮球&#x27;, &#x27;足球&#x27;]&#125;// readonly限制，不能重新赋值// user.id = 2// readonly限制数组字段 readonly like: string[] ，不能重新赋值，但是可以使用数组方法push// readonly限制数组类型 readonly like: readonly string[] ，不能使用数组方法// user.like = [&#x27;足球&#x27;, &#x27;篮球&#x27;]//user.like.push(&#x27;羽毛球&#x27;)const arr: readonly number[] = [1, 2, 3]// readonly限制，不能修改// arr.push(4) 类型兼容将B赋值给A，如果能完成赋值，就说明B和A类型兼容。 鸭子辨型法（子结构辨型法）：目标类型需要某一些特征，赋值的类型只要能满足该特征即可 基本类型：完全匹配 对象类型：鸭子辨型法 示例： 12345678910111213141516171819202122232425// 定义鸭子的接口类型interface Duck &#123; say: string swimming(): void&#125;// 定义鸭子的实例let duck: Duck = &#123; say: &#x27;ga,ga&#x27;, swimming() &#123; console.log(&#x27;duck swimming&#x27;) &#125;&#125;// 定义人类，但是有实现鸭子的接口let human = &#123; name: &#x27;jacky&#x27;, age: 18, say: &#x27;ha,ha&#x27; as &#x27;ga,ga&#x27;, swimming() &#123; console.log(`$&#123;this.name&#125; swimming`) &#125;&#125;// 所以可以将人类赋值给鸭子,说明人类和鸭子兼容duck = human 注意：say: &#39;ga,ga&#39; as &#39;ga,ga&#39;,，人类的say使用了断言，前面的ga,ga是值，后面的ga,ga是类型。不用断言也可以实现兼容。 类型断言 当直接使用对象字面量赋值的时候，会进行更加严格的判断 函数类型 一切无比自然 参数：传递给目标函数的参数可以少，但不可以多 返回值：要求返回必须返回；不要求返回，你随意； 12345678910111213141516interface Condition &#123; (n: number, i: number): boolean&#125;function sum(num: number[], callback: Condition): number &#123; let sum = 0 for (let i = 0; i &lt; num.length; i++) &#123; if (callback(num[i], i)) &#123; sum += num[i] &#125; &#125; return sum&#125;// 实际情况下没有用到第二个参数i，但依然可以赋值成功，类型兼容const result = sum([1, 2, 3, 4, 5], n =&gt; n % 2 !== 0)console.log(result) 类ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 ES6 中类的用法ES6 中类的用法，更详细的介绍可以参考 ECMAScript 6 入门 - Class 属性和方法使用 class 定义类，使用 constructor 定义构造函数。 通过 new 生成新实例的时候，会自动调用构造函数。 123456789101112class Person &#123; constructor(name) &#123; this.name = name &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;` &#125;&#125;const person = new Person(&#x27;jacky&#x27;)console.log(person.sayHi()) // My name is jacky 类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。 123456789101112class Student extends Person &#123; constructor(name) &#123; super(name) console.log(this.name) &#125; sayHi() &#123; return super.sayHi() + &quot;, I&#x27;m a student ~&quot; &#125;&#125;const student = new Student(&#x27;tom&#x27;) // tomconsole.log(student.sayHi()) // My name is tom, I&#x27;m a student ~ 存取器使用 getter 和 setter 可以改变属性的赋值和读取行为： 1234567891011121314151617class Person &#123; constructor(name) &#123; this.name = name &#125; get name() &#123; return &#x27;jacky&#x27; &#125; set name(value) &#123; console.log(&#x27;setter name: &#x27;, value) &#125;&#125;let person = new Person(&#x27;lisa&#x27;) // setter name: lisaperson.name = &#x27;tom&#x27; // setter name: tomconsole.log(person.name) // jacky 静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用： 1234567class Person &#123; static sayHi(name) &#123; console.log(`Hello $&#123;name&#125;`) &#125;&#125;Person.sayHi(&#x27;jacky&#x27;) // Hello jacky ES7 中类的用法实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义： 123456class Person &#123; name = &#x27;jacky&#x27;&#125;let p = new Person()console.log(p.name) // jacky 静态属性ES7 提案中，可以使用 static 定义一个静态属性： 12345class Person &#123; static name = &#x27;jacky&#x27;&#125;console.log(Person.name) // jacky TypeScript 中类的用法TypeScript实现了所有JavaScript中类的用法，并在其基础上增加了一些类型相关的功能。 public private 和 protectedTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 示例： 12345678910111213141516171819202122232425262728293031323334353637383940class User &#123; readonly id: number gender: &#x27;male&#x27; | &#x27;female&#x27; = &#x27;male&#x27; pid?: number private publishCount: number = 3 private currentCount: number = 0 constructor(public name: string, public age: number) &#123; this.id = Math.random() &#125; publish(title: string) &#123; if (this.currentCount &lt; this.publishCount) &#123; console.log(`$&#123;this.name&#125;发布了一篇文章：$&#123;title&#125; $&#123;this.currentCount + 1&#125;`) this.currentCount++ &#125; else &#123; console.log(&#x27;文章发布已达上限&#x27;) &#125; &#125;&#125;const user = new User(&#x27;张三&#x27;, 18)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)user.publish(&#x27;文章标题&#x27;)// 张三发布了一篇文章：文章标题 1// 张三发布了一篇文章：文章标题 2// 张三发布了一篇文章：文章标题 3// 文章发布已达上限// 文章发布已达上限// 文章发布已达上限// 文章发布已达上限// 文章发布已达上限 示例中可以看到原来在JavaScript中的一些特性，比如：实例属性等，TypeScript在此基础上还增加了 readonly只读修饰符。只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。 private和public访问修饰符 pid?: number可选属性。表示属性可选，类型为number | undefined 属性缩写，语法糖 123456789101112131415161718// 注意constructor参数一定要增加访问修饰符class User &#123; constructor(public name: string, public age: number) &#123; this.id = Math.random() &#125;&#125;// 上述代码可以看成下面代码的缩写// 当有实例属性，作为constructor的参数直接传入并且不做任何处理，就可以在constructor的参数中通过访问修饰符标识该参数达到语法糖效果class User &#123; public name: string public age: number constructor(name: string, age: number) &#123; this.id = Math.random() this.name = name this.age = age &#125;&#125; 综合示例使用类来修改之前的示例，在类中定义 初始化一副牌（创建一副牌） 打印一副牌 洗牌（打乱牌面顺序） 发牌（将牌发给三个玩家每人17张，桌面剩3张） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// poker/deck.tsimport &#123; Color, Mark, JokerType &#125; from &#x27;./enums&#x27;import &#123; Card, JokerCard &#125; from &#x27;./types&#x27;// 定义一副牌最后发到每个玩家和桌面剩下的牌的接口interface PublishResult &#123; player1: Deck player2: Deck player3: Deck left: Deck&#125;class Deck &#123; // 定义一副牌 private cards: Card[] = [] /** * 判断是否传入了一副牌 * 如果传入了就将牌面赋值到cards * 如果没有传入牌面就初始化牌面 */ constructor(cards?: Card[]) &#123; if (cards) &#123; this.cards = cards &#125; else &#123; this.init() &#125; &#125; // 初始化一副牌 private init() &#123; // 获取所有的花色值 const colors = Object.values(Color) // 获取所有牌面的值 const marks = Object.values(Mark) // 遍历所有花色和所有牌面，添加普通花色和牌面 for (let color of colors) &#123; for (let mark of marks) &#123; this.cards.push(&#123; color, mark, getCard() &#123; return `$&#123;color&#125;$&#123;mark&#125;` &#125; &#125; as Card) &#125; &#125; // 添加joker 小王 let joker: JokerCard = &#123; type: JokerType.black, getCard() &#123; return &#x27;joker&#x27; &#125; &#125; this.cards.push(joker) // 添加joker 大王 joker = &#123; type: JokerType.red, getCard() &#123; return &#x27;JOKER&#x27; &#125; &#125; this.cards.push(joker) &#125; /** * 打印一副牌 * 打印每张牌的花色和牌面 */ print() &#123; let reslut = &#x27;\\n&#x27; // 遍历扑克，并按照数字返回每张扑克的花色和数字 this.cards.forEach((poke, i) =&gt; &#123; reslut += `$&#123;poke.getCard()&#125;\\t` // 每隔 13 张扑克 增加一个换行符 if ((i + 1) % 6 === 0) &#123; reslut += &#x27;\\n&#x27; &#125; &#125;) console.log(reslut) &#125; /** * 洗牌 * 通过遍历一副牌，将牌面随机打乱 * 通过getRandom方法，随机获取一张牌的位置，将牌面替换到该位置，达到洗牌的效果 */ shuffle() &#123; for (let i = 0; i &lt; this.cards.length; i++) &#123; // 随机获取一张牌位置 const targetIndex = this.getRandom(0, this.cards.length) // 将牌面替换到该位置 const temp = this.cards[i] this.cards[i] = this.cards[targetIndex] this.cards[targetIndex] = temp &#125; &#125; /** * 发牌 * 给每个玩家发牌，每个玩家手上又是一副牌，可以套用Deck这个类 * @returns 发牌结果 */ publish(): PublishResult &#123; let player1: Deck, player2: Deck, player3: Deck, left: Deck // 摸牌 player1 = this.takeCards(17) player2 = this.takeCards(17) player3 = this.takeCards(17) left = new Deck(this.cards) return &#123; player1, player2, player3, left &#125; &#125; /** * 摸牌 * 给玩家摸牌 * @param count 需要摸几张牌 * @return 玩家摸到的牌 */ private takeCards(count: number): Deck &#123; const cards: Card[] = [] for (let i = 0; i &lt; count; i++) &#123; cards.push(this.cards.shift() as Card) &#125; return new Deck(cards) &#125; /** * 获取一个范围内的随机数 * @param min * @param max */ private getRandom(min: number, max: number) &#123; return Math.floor(Math.random() * (max - min) + min) &#125;&#125;export &#123; Deck &#125; 保留原来的enum.ts和types.ts，将funcs.ts中的方法已经移入到deck.ts中，删除funcs.ts。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// poker/enum.tsexport enum Color &#123; Spade = &#x27;♠&#x27;, Club = &#x27;♣&#x27;, Diamond = &#x27;♥&#x27;, Heart = &#x27;♦&#x27;&#125;export enum Mark &#123; ace = &#x27;A&#x27;, two = &#x27;2&#x27;, three = &#x27;3&#x27;, four = &#x27;4&#x27;, five = &#x27;5&#x27;, six = &#x27;6&#x27;, seven = &#x27;7&#x27;, eight = &#x27;8&#x27;, nine = &#x27;9&#x27;, ten = &#x27;10&#x27;, jack = &#x27;J&#x27;, queen = &#x27;Q&#x27;, king = &#x27;K&#x27;&#125;export enum JokerType &#123; black = &#x27;小王&#x27;, red = &#x27;大王&#x27;&#125;// poker/types.tsimport &#123; Color, JokerType, Mark &#125; from &#x27;./enums&#x27;// 定义一个Poke类型为Card类型的数组export type Poke = Card[]export interface Card &#123; getCard(): string&#125;export interface NormalCard extends Card &#123; color: Color mark: Mark&#125;export interface JokerCard extends Card &#123; type: JokerType&#125; 修改index.ts，玩家因为使用了Deck类型，所以每个玩家又可以使用Deck类中的打印方法。 12345678910111213141516171819202122232425// poker/index.tsimport &#123; Deck &#125; from &#x27;./deck&#x27;// 初始化一副牌const deck = new Deck()// 洗牌deck.shuffle()console.log(&#x27;===========一副牌============&#x27;)deck.print()const result = deck.publish()console.log(&#x27;============发牌=============&#x27;)console.log(&#x27;=============玩家 1==========&#x27;)result.player1.print()console.log(&#x27;=============玩家 2==========&#x27;)result.player2.print()console.log(&#x27;=============玩家 3==========&#x27;)result.player3.print()console.log(&#x27;==============桌面===========&#x27;)result.left.print() 泛型有时，书写某个函数时，会丢失一些类型信息（多个位置的类型应该保持一致或有关联的信息） 泛型：是指附属于函数、类、接口、类型别名之上的类型。泛型相当于是一个类型变量，在定义时，无法预先知道具体的类型，可以用该变量来代替，只有到调用时，才能确定它的类型 很多时候，TS会智能的根据传递的参数，推导出泛型的具体类型 如果无法完成推导，并且又没有传递具体的类型，默认为空对象 泛型可以设置默认值 在函数中使用泛型示例： 1234567891011121314// 在定义时，缺失对arr数组的约束，可以传入string或者numberfunction take(arr: any[], num: number) &#123; if (num &gt; arr.length) &#123; return arr &#125; let newArr: any[] = arr.slice(0, num) return newArr&#125;const numResult = take([1, 2, 3, 4, 5], 2)console.log(numResult)const strResult = take([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], 3)console.log(strResult) 使用泛型 12345678910111213function take&lt;T&gt;(arr: T[], num: number): T[] &#123; if (num &gt; arr.length) &#123; return arr &#125; let newArr: T[] = arr.slice(0, num) return newArr&#125;// 使用泛型&lt;number&gt;定义函数const numResult = take&lt;number&gt;([1, 2, 3, 4, 5], 2)console.log(numResult)// 可以通过传入的参数的类型来进行类型推导，得到一个泛型const strResult = take([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], 3)console.log(strResult) 在类型别名、接口、类中使用示例： 123456789101112131415161718192021222324// 类型别名// 定义类型别名，通过泛型设置参数num的类型type CallBack&lt;T&gt; = (num: T, i: number) =&gt; boolean// 使用接口，只需要调整类型别名定义方式, 效果与上述相同，二选一interface CallBack&lt;T&gt; &#123; (num: T, i: number): boolean&#125;// 定义函数的泛型，并将函数的泛型传递给参数callback的类型别名function filter&lt;T&gt;(arr: T[], callback: CallBack&lt;T&gt;): T[] &#123; const newArr: T[] = [] arr.forEach((n, i) =&gt; &#123; if (callback(n, i)) &#123; newArr.push(n) &#125; &#125;) return newArr&#125;// 给函数filter设置泛型的类型console.log(filter&lt;number&gt;([1, 2, 3, 4, 5], n =&gt; n % 2 !== 0))// 函数filter通过第一个参数的类型来进行类型推导，得到一个字符串类型的泛型console.log(filter([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], (n, i) =&gt; i &gt; 2)) 在类中定义泛型 123456789101112131415161718192021222324252627282930313233// 给类定义一个泛型，并影响类中的属性和方法class ArrayHelp&lt;T&gt; &#123; constructor(private arr: T[]) &#123;&#125; take(n: number): T[] &#123; if (n &gt;= this.arr.length) &#123; return this.arr &#125; const newArr: T[] = [] for (let i = 0; i &lt; n; i++) &#123; newArr.push(this.arr[i]) &#125; return newArr &#125; shuffle() &#123; for (let i = 0; i &lt; this.arr.length; i++) &#123; const targetIndex = this.getRandom(0, this.arr.length) const temp = this.arr[i] this.arr[i] = this.arr[targetIndex] this.arr[targetIndex] = temp &#125; &#125; private getRandom(min: number, max: number) &#123; return Math.floor(Math.random() * (max - min) + min) &#125;&#125;const arr = new ArrayHelp([&#x27;jacky&#x27;, &#x27;tom&#x27;, &#x27;lisa&#x27;, &#x27;sara&#x27;, &#x27;lily&#x27;])arr.shuffle()// 随机得到两个字符串console.log(arr.take(2)) 泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法。 示例： 从一个对象中获取一个name字段，将name的单词首字母大写，并返回该对象 1234567891011121314151617181920interface hasNameField &#123; name: string&#125;function formatNameToUpperCase&lt;T extends hasNameField&gt;(obj: T): T &#123; obj.name = obj.name .split(&#x27; &#x27;) .map(item =&gt; item[0].toUpperCase() + item.substring(1)) .join(&#x27; &#x27;) return obj&#125;const user = &#123; name: &#x27;jacky huang&#x27;, age: 18&#125;const result = formatNameToUpperCase(user)console.log(result) // &#123; name: &#x27;Jacky Huang&#x27;, age: 18 &#125; 多个泛型定义泛型的时候，可以一次定义多个类型参数 示例： 将两个数组混合，返回一个混合后的数组 12345678910111213141516171819function mixArray&lt;T, S&gt;(arr1: T[], arr2: S[]): (T | S)[] &#123; if (arr1.length !== arr2.length) &#123; throw new Error(&#x27;数组长度不一致&#x27;) &#125; const result = [] for (let i = 0; i &lt; arr1.length; i++) &#123; result.push(arr1[i]) result.push(arr2[i]) &#125; return result&#125;// 可以通过类型推导从参数的数组中推断出来泛型的类型const result1 = mixArray([1, 2, 3], [4, 5, 6])console.log(result1) // [ 1, 4, 2, 5, 3, 6 ]// 也可以指定函数的泛型类型const result2 = mixArray&lt;number, string&gt;([1, 2, 3], [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;])console.log(result2) // [ 1, &#x27;d&#x27;, 2, &#x27;e&#x27;, 3, &#x27;f&#x27; ] 综合示例开发一个字典类（Dictionary），字典中会保存键值对的数据 键值对数据的特点： 键（key）可以是任何类型，但不允许重复 值（value）可以是任何类型 每个键对应一个值 所有的键类型相同，所有的值类型相同 字典类中对键值对数据的操作： 按照键，删除对应的键值对 循环每一个键值对 得到当前键值对的数量 判断某个键是否存在 重新设置某个键对应的值，如果不存在，则添加 通过键得到对应的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface CallBack&lt;K, V&gt; &#123; (key: K, value: V): void&#125;export class Dictionary&lt;K, V&gt; &#123; private keys: K[] = [] private values: V[] = [] // 获取字典的内容的长度 get size() &#123; return this.keys.length &#125; // 通过key获取对应的value get(key: K) &#123; return this.values[this.keys.indexOf(key)] &#125; // 设置字典的内容，如果key不存在则添加一个新的key，如果key存在则替换value set(key: K, value: V) &#123; const index = this.keys.indexOf(key) if (index &lt; 0) &#123; this.keys.push(key) this.values.push(value) &#125; else &#123; this.values[index] = value &#125; &#125; // 循环遍历字典，调用回调函数 forEach(callBack: CallBack&lt;K, V&gt;) &#123; this.keys.forEach((key, i) =&gt; &#123; callBack(key, this.values[i]) &#125;) &#125; // 查询字典，如果key不存在则返回undefined，如果key存在则返回value has(key: K) &#123; return this.keys.includes(key) &#125; // 根据字典中的key删除对应的value delete(key: K) &#123; const index = this.keys.indexOf(key) if (index &lt; 0) &#123; return &#125; this.keys.splice(index, 1) this.values.splice(index, 1) &#125;&#125; 测试： 12345678910111213141516171819202122232425262728import &#123; Dictionary &#125; from &#x27;./dictionary&#x27;const dict = new Dictionary()dict.set(&#x27;a&#x27;, 1)console.log(&#x27;设置a的值为1&#x27;)dict.set(&#x27;b&#x27;, 2)console.log(&#x27;获取b的值为2&#x27;)dict.set(&#x27;c&#x27;, 3)console.log(&#x27;设置c的值为3&#x27;)console.log(&#x27;获取a的值: &#x27;, dict.get(&#x27;a&#x27;))dict.set(&#x27;a&#x27;, 4)console.log(&#x27;设置a的值为4&#x27;)console.log(&#x27;a的值: &#x27;, dict.get(&#x27;a&#x27;))console.log(&#x27;字典大小&#x27;, dict.size)dict.forEach((k, v) =&gt; &#123; console.log(`$&#123;k&#125;:$&#123;v&#125;`)&#125;)dict.delete(&#x27;a&#x27;)console.log(&#x27;删除a&#x27;)console.log(&#x27;字典大小: &#x27;, dict.size)","permalink":"http://example.com/2023/10/05/TypeScript-%E5%9F%BA%E7%A1%80/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"react-query","slug":"react-query","permalink":"http://example.com/tags/react-query/"}],"title":"Query Key Factory - React Query 的 QueryKey  查询管理工具","date":"2023/05/18","text":"在使用react-query做了几个项目以后，就感觉react-query中的查询和请求状态管理非常方便。但逐渐发现对react-query的使用需求在逐步发生变化： 基本需求就是对异步数据获取的状态进行管理。 获取到数据，react-query对数据进行缓存后，需要对缓存数据进行管理。 当需要进行数据交互通过useMutation获取到新的数据时，就需要通过之前查询数据的useQuery的queryKey修改缓存数据，通过query client中的setQueryData来修改缓存，或者使用invalidateQueries来使对应查询的queryKey让缓存失效来重新获取数据，最终就变成对queryKey的管理。 最近在做的real world练手项目中就碰到很多这种交互产生的问题，项目类似于Medium的一个多人博客，可以查看、发布文章、收藏文章、关注博主、对文章发布评论等，使用react-query来做API请求是非常简单的，但是在列表中点击收藏文章按钮，来收藏文章，在文章详情点击收藏按钮来收藏文章、关注博主。在文章详情中，对文章进行评论，这样就会产生大量的交互操作，需要在发起新的请求后修改之前的查询数据缓存或使之前的缓存失效，让新的数据生效。 这样我在第一个版本中，使用了一个valtio的store对当前请求的queryKey进行管理，如果在加载到当前页面有请求发生，则会通过setKey将当前请求的queryKey放到store中，如果当前页面有交互发生，需要使用invalidateQueries来使当前页面的缓存失效，就可以在useMutation时，通过getKey来获取当前请求的queryKey，从而来更新数据。 这样能在一定层面上解决queryKey的问题，但也存在几个问题： 写法上就很繁琐，每次useMutation都需要先从store中获取下key。 从store中获取的key也是有局限性的。无法使用多个invalidateQueries来让多个位置的请求缓存失效，仅限当前页面。如果是在列表1中收藏的文章，列表2中的相同文章的收藏按钮不一定更新了这个状态，跟react-query的缓存时效和机制有关。 基于上面的问题到react-query的官方找了下，看下又没有类似的解决办法，果然官方有推荐两个类似的包Query Key Factory和React Query Kit。React Query Kit比较偏向对queryKey和queryFn做集中管理，还有中文版的说明，应该是国人开发的，但跟我的需求关联不大，后面项目在好好研究下吧。Query Key Factory更加能满足我对queryKey的管理需求，所以采用了Query Key Factory。 Query Key Factory的安装和使用说明Query Key Factory包的功能说明： @tanstack&#x2F;query 的类型安全查询密钥管理，具有自动完成功能。 专注于编写和使查询无效而无需记住的麻烦 您如何为特定查询设置密钥！ 这个库会处理剩下的事情。 安装： 1pnpm add @lukemorales/query-key-factory 以我做的real world第2个版本内容结合官方的例子来做使用说明： 定义queryKey、queryFn 对queryKey的定义，官方给了两种方式： 使用createQueryKeyStore将所有的queryKey都放到一起来定义。官方示例： 123456789101112131415161718192021222324252627282930import &#123; createQueryKeyStore &#125; from &quot;@lukemorales/query-key-factory&quot;;export const queries = createQueryKeyStore(&#123; users: &#123; // 不定义queryKey和queryFn，会自动产生一个queryKey:[&#x27;users&#x27;, &#x27;all&#x27;] all: null, detail: (userId: string) =&gt; (&#123; queryKey: [userId], queryFn: () =&gt; api.getUser(userId), &#125;), &#125;, todos: &#123; detail: (todoId: string) =&gt; [todoId], list: (filters: TodoFilters) =&gt; (&#123; queryKey: [&#123; filters &#125;], queryFn: (ctx) =&gt; api.getTodos(&#123; filters, page: ctx.pageParam &#125;), contextQueries: &#123; search: (query: string, limit = 15) =&gt; (&#123; queryKey: [query, limit], queryFn: (ctx) =&gt; api.getSearchTodos(&#123; page: ctx.pageParam, filters, limit, query, &#125;), &#125;), &#125;, &#125;), &#125;,&#125;); 使用createQueryKeys， mergeQueryKeys组合，通过createQueryKeys来定义每个模块的queryKey，然后通过mergeQueryKeys来合并。我主要使用的这种方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; createQueryKeys, mergeQueryKeys &#125; from &#x27;@lukemorales/query-key-factory&#x27;import api from &#x27;@/service/apis&#x27;export const users = createQueryKeys(&#x27;users&#x27;, &#123; view: () =&gt; (&#123; queryKey: [&#x27;user&#x27;], queryFn: () =&gt; api.User.view() &#125;)&#125;)export const profile = createQueryKeys(&#x27;profile&#x27;, &#123; view: username =&gt; (&#123; queryKey: [username], queryFn: () =&gt; api.Profile.view(username) &#125;)&#125;)export const articles = createQueryKeys(&#x27;articles&#x27;, &#123; all: (limit, offset, author = null, favorited = null, tag = null) =&gt; (&#123; queryKey: [offset, author, favorited, tag], queryFn: () =&gt; api.Article.all(limit, offset, author, favorited, tag) &#125;), feed: (limit, offset) =&gt; (&#123; queryKey: [offset], queryFn: () =&gt; api.Article.feed(limit, offset) &#125;), view: slug =&gt; (&#123; queryKey: [slug], queryFn: () =&gt; api.Article.view(slug) &#125;)&#125;)export const comments = createQueryKeys(&#x27;comments&#x27;, &#123; all: slug =&gt; (&#123; queryKey: [slug], queryFn: () =&gt; api.Comment.all(slug) &#125;)&#125;)export const tags = createQueryKeys(&#x27;tags&#x27;, &#123; all: () =&gt; (&#123; queryKey: [&#x27;tags&#x27;], queryFn: () =&gt; api.Default.tags() &#125;)&#125;)export const querykeys = mergeQueryKeys(users, profile, articles, comments, tags) 通过createQueryKeys来定义每个模块的queryKey和queryFn。当然官方的示例也给了只定义queryKey在useQuery在使用queryFn的示例： 123456export const todos = createQueryKeys(&#x27;todos&#x27;, &#123; detail: (todoId: string) =&gt; [todoId], list: (filters: TodoFilters) =&gt; (&#123; queryKey: [&#123; filters &#125;], &#125;),&#125;); 使用可以见后面的官方使用说明 使用定义好的queryKey和queryFn官方的示例很凌乱，在createQueryKeys时定义的内容不一致，相同的 todo detail有不同的定义，我研究了半天，整理如下： 123456789101112131415import &#123; queries &#125; from &#x27;../queries&#x27;// 在createQueryKeys中没有定义queryKey、queryFn,但会产生一个默认的queryKey [`users`, &#x27;all&#x27;]// 可以在useQuery在来定义queryFnexport function useUsers() &#123; return useQuery(&#123; ...queries.users.all, queryFn: () =&gt; api.getUsers(), &#125;);&#125;;// 使用在createQueryKeys中定义的queryKey、queryFn，直接传递参数即可，会自动生成queryKey、queryFn// queryKey: [&#x27;users&#x27;, &#x27;detail&#x27;, userId]export function useUserDetail(id: string) &#123; return useQuery(queries.users.detail(id));&#125;; 因为只需要对useQuery进行QueryKey的设置，我这边的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import &#123; querykeys &#125; from &#x27;@/service/queryKeys&#x27;import &#123; useParams &#125; from &#x27;react-router-dom&#x27;const User = &#123; useUser: () =&gt; useQuery(querykeys.users.view())&#125;const Profile = &#123; useProfile: () =&gt; &#123; const &#123; username &#125; = useParams() return useQuery(querykeys.profile.view(username)) &#125;&#125;const Article = &#123; useArticles: (limit, offset, author, favorited, tag) =&gt; useQuery(querykeys.articles.all(limit, offset, author, favorited, tag)), useArticlesFeed: (limit, offset) =&gt; useQuery(querykeys.articles.feed(limit, offset)), useArticle: (slug, options) =&gt; &#123; return useQuery(querykeys.articles.view(slug), options) &#125;&#125;const Comment = &#123; useComments: slug =&gt; useQuery(querykeys.comments.all(slug))&#125;const Tag = &#123; useTags: () =&gt; useQuery(querykeys.tags.all())&#125;export default &#123; User, Profile, Article, Comment, Tag&#125; 使用之前定义好的queryKey、queryFn就很简单了。下面放到一起看起来就很清晰。 123456789101112131415161718192021222324252627// queryKey.jsx 定义queryKey、queryFnexport const users = createQueryKeys(&#x27;users&#x27;, &#123; view: () =&gt; (&#123; queryKey: [&#x27;user&#x27;], queryFn: () =&gt; api.User.view() &#125;)&#125;)export const profile = createQueryKeys(&#x27;profile&#x27;, &#123; view: username =&gt; (&#123; queryKey: [username], queryFn: () =&gt; api.Profile.view(username) &#125;)&#125;)// queries.jsx 使用queryKey.jsx中定义好的queryKey、queryFnconst User = &#123; useUser: () =&gt; useQuery(querykeys.users.view())&#125;// 如果还有需要查询路径参数的还可以使用react-router-domconst Profile = &#123; useProfile: () =&gt; &#123; const &#123; username &#125; = useParams() return useQuery(querykeys.profile.view(username)) &#125;&#125; 这样就可以统一对react-query的queryKey、queryFn来进行管理使用了。 如何在useMutation中使用queryKey使用querykeys.users.view._def中这个方法可以直接使对应的queryKey失效，也不需要传递什么参数。多个模块的查询失效实现也很简单，见下方示例。 或者使用users.detail(&#123; status: &#39;completed&#39; &#125;).queryKey这种传参数的方式来获取queryKey，再进行queryClient.invalidateQueries操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import &#123; useMutation, useQueryClient &#125; from &#x27;@tanstack/react-query&#x27;import &#123; querykeys &#125; from &#x27;@/service/queryKeys&#x27;import api from &#x27;@/service/apis&#x27;import &#123; useAuth &#125; from &#x27;@/hooks&#x27;const User = &#123; useLogin: () =&gt; &#123; const &#123; login &#125; = useAuth() return useMutation(api.User.login, &#123; onSuccess: data =&gt; &#123; login(data) &#125; &#125;) &#125;, useRegister: () =&gt; &#123; const &#123; login &#125; = useAuth() return useMutation(api.User.register, &#123; onSuccess: data =&gt; &#123; login(data) &#125; &#125;) &#125;, useUserUpdate: () =&gt; &#123; const queryClient = useQueryClient() return useMutation(api.User.update, &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.users.view._def) &#125; &#125;) &#125;&#125;const Profile = &#123; useFollow: (following, username) =&gt; &#123; const queryClient = useQueryClient() return useMutation(following ? () =&gt; api.Profile.unfollow(username) : () =&gt; api.Profile.follow(username), &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.profile.view._def) queryClient.invalidateQueries(querykeys.articles.view._def) &#125; &#125;) &#125;&#125;const Article = &#123; useArticleCreate: () =&gt; &#123; const queryClient = useQueryClient() return useMutation(api.Article.create, &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.articles.all._def) queryClient.invalidateQueries(querykeys.articles.feed._def) &#125; &#125;) &#125;, useArticleUpdate: slug =&gt; &#123; const queryClient = useQueryClient() return useMutation(article =&gt; api.Article.update(slug, article), &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.articles.all._def) queryClient.invalidateQueries(querykeys.articles.feed._def) &#125; &#125;) &#125;, useArticleDelete: slug =&gt; &#123; const queryClient = useQueryClient() return useMutation(api.Article.delete, &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.articles.all._def) queryClient.invalidateQueries(querykeys.articles.feed._def) &#125; &#125;) &#125;&#125;const Comment = &#123; useCommentCreate: slug =&gt; &#123; const queryClient = useQueryClient() return useMutation(body =&gt; api.Comment.create(slug, body), &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.comments.all._def) &#125; &#125;) &#125;, useCommentDelete: (slug, id) =&gt; &#123; const queryClient = useQueryClient() return useMutation(() =&gt; api.Comment.delete(slug, id), &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.comments.all._def) &#125; &#125;) &#125;&#125;const Favorite = &#123; useFavorite: (slug, favorited) =&gt; &#123; const queryClient = useQueryClient() return useMutation(favorited ? () =&gt; api.Favorite.unfavorite(slug) : () =&gt; api.Favorite.favorite(slug), &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries(querykeys.articles.all._def) queryClient.invalidateQueries(querykeys.articles.feed._def) queryClient.invalidateQueries(querykeys.articles.view._def) &#125; &#125;) &#125;&#125;export default &#123; User, Profile, Article, Comment, Favorite&#125; Query Key Factory还有一些其他的方法，没有细究了，需求满足了。 Query Key Factory 的问题 问题：在createMutationKeys中创建带有参数的突变，和queryKey一起使用时会undefine，这个bug目前还没解决。New createMutationKeys doesn’t work for mutations with arguments · Issue #55 · lukemorales&#x2F;query-key-factory (github.com) 解决办法：所以我在项目中没有使用createMutationKeys来创建mutationKey和mutationFn。因为useMutation不需要key，使用createMutationKeys只是做个统一管理，可以等后面这个库成熟点了再来看看。 问题：使用createQueryKeys创建的queryFn不能使用enabled，这个应该不会去解决了。why does enabled not work within the query-key-factory? · Issue #61 · lukemorales&#x2F;query-key-factory (github.com) 解决办法：这里可以只在createQueryKeys中需要使用enabled的模块中只声明queryKey，queryFn可以放到useQuery中。或者不使用createQueryKeys中的queryKey，单独来写useQuery来规避这个问题。","permalink":"http://example.com/2023/05/18/Query-Key-Factory-React-Query-%E7%9A%84-QueryKey-%E6%9F%A5%E8%AF%A2%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"title":"如何在一台电脑上配置多个Github SSH","date":"2023/05/05","text":"因为遇到需要使用两个github账号来做不同账号的代码同步，于是学习了下。主要解决同一台电脑上两个github账号切换的问题。如果已经有主账号了，不需要再次生成，下面仅为副账号生成设置步骤。 生成副账号的SSH第一步，我们需要为账号生成密钥：命令： 1ssh-keygen -t ed25519 -C &quot;your_email@work.com&quot; 在输入命令，修改对应的邮箱后，回车。 需要注意的是，当其出现以下提示时，需要手动修改一下文件名， 否则可能会覆盖已有的默认 SSH，比如我们修改成 ~/.ssh/work_ed25519，注意此处的路径，如果前面的路径设置没效果或者错误，可以使用绝对路径/Users/you/.ssh/work_ed25519 1Enter file in which to save the key (/Users/you/.ssh/id_ed25519): ~/.ssh/work_ed25519 然后一路按 enter 即可。接下来我们可以通过以下方法来确认是否成功生成密钥： 123ls ~/.ssh/ id_ed25519id_ed25519.pub work_ed25519work_ed25519.pub 若列出以上文件则表示成功。 添加SSH公钥把生成的公钥传入 GitHub 中，在github头像上点击出菜单，settings，在设置页面左侧菜单栏中找到SSH and GPG keys，然后选择 New SSH key 并把 work_ed25519.pub 中的公钥复制进去即可。 将 SSH 密钥加入 ssh-agent 并进行配置打开 ~/.ssh/ 下的 config （若没有的话新建即可，就是一个config文件，没有后缀）文件并输入以下的信息并保存： 1234567891011Host github.com User mainUsername AddKeysToAgent yes IgnoreUnknown UseKeychain IdentityFile ~/.ssh/id_rsa Host work.com HostName github.com User subUsername AddKeysToAgent yes IgnoreUnknown UseKeychain IdentityFile ~/.ssh/work_ed25519 需要注意的几个点： 第一组可以设置成默认的主账号，这样clone时可以不需要修改。第二组设置为副账号，在clone时就需要进行修改了，下面会单独来说下如何修改。 User这里需要填写账号的用户名，可以在settings页面的头像旁看到，括号中的就是账号的用户名，需要确定好不要写错。 确认好IdentityFile所对应的生成账号文件。 如何使用副账号进行Clone配置就完成啦，当我们需要 clone 公司的项目时，只需要略微修改其 SSH 即可： 1234# 原始链接git@github.com:公司名/项目名.git #需要修改成git@work.com:公司名/项目名.git 需要修改的地方有两处： github.com 需要修改为config文件中配置的Host work.com 公司名，需要修改为config文件中配置的User subUsername 配置工作区账号通过 git config user.email 来查看当前邮箱时，发现其实还是主账号的邮箱，这样副账号commit时，会使用主账号来进行推送。这时就需要配置对应的工作区账号。在项目目录执行如下命令： 12git initgit config --local user.email work@email.com work@email.com 为副账号的邮箱。这样我们就为该工作区配置好了正确的信息。在配置完工作区账号后，我们可以通过 git config user.email来查看当前目录下的邮箱，就已经替换成副账号的邮箱了。 配置流程可以总结如下： 为副账号配置SSH 将SSH公钥配置到Github 配置Config文件 设置工作区user.email","permalink":"http://example.com/2023/05/05/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGithub-SSH/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"react-router","slug":"react-router","permalink":"http://example.com/tags/react-router/"}],"title":"React Route 6.4功能","date":"2023/02/02","text":"React Route 最近更新到了6.8，在6.4的版本中增加了一些新功能。应该是借鉴了remix的一些功能吧，毕竟是一个系统的产品。开发中的内卷逐渐在产品中体现了出来。 安装新功能需安装6.4或之后版本，所以安装最新版即可。 1pnpm add react-router-dom@latest 基础路由在6.4之前的路由基本都会放到app.jsx中。 12345678910111213141516171819202122232425262728293031323334353637383940// src/app.jsximport React from &#x27;react&#x27;import &#123; BrowserRouter, Routes, Route, NavLink &#125; from &#x27;react-router-dom&#x27;import RootStyle from &#x27;@/styles/root.style&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;./pages/Contact&#x27;const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &lt;RootStyle /&gt; &lt;header className=&#x27;layout-header&#x27;&gt; &lt;h1 className=&#x27;logo&#x27;&gt;React Route 6.4&lt;/h1&gt; &lt;nav className=&#x27;navs&#x27;&gt; &lt;NavLink to=&#x27;/&#x27; className=&#x27;nav-item&#x27;&gt; Home &lt;/NavLink&gt; &lt;NavLink to=&#x27;about&#x27; className=&#x27;nav-item&#x27;&gt; About &lt;/NavLink&gt; &lt;NavLink to=&#x27;contact&#x27; className=&#x27;nav-item&#x27;&gt; Contact &lt;/NavLink&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main className=&#x27;layout-main&#x27;&gt; &lt;Routes&gt; &lt;Route index element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&#x27;about&#x27; element=&#123;&lt;About /&gt;&#125; /&gt; &lt;Route path=&#x27;contact&#x27; element=&#123;&lt;Contact /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/main&gt; &lt;/BrowserRouter&gt; )&#125;export default App 这种情况其实就是把app.jsx当做一个layout，所以很多人会将layout部分的内容单独抽出，以减少app.jsx页面的内容混乱和繁琐。 12345678910111213141516171819202122232425262728// src/components/Layout.jsximport React from &#x27;react&#x27;import &#123; NavLink &#125; from &#x27;react-router-dom&#x27;const Layout = (&#123; children &#125;) =&gt; &#123; return ( &lt;div className=&#x27;layout&#x27;&gt; &lt;header className=&#x27;layout-header&#x27;&gt; &lt;h1 className=&#x27;logo&#x27;&gt;React Route 6.4&lt;/h1&gt; &lt;nav className=&#x27;navs&#x27;&gt; &lt;NavLink to=&#x27;/&#x27; className=&#x27;nav-item&#x27;&gt; Home &lt;/NavLink&gt; &lt;NavLink to=&#x27;about&#x27; className=&#x27;nav-item&#x27;&gt; About &lt;/NavLink&gt; &lt;NavLink to=&#x27;contact&#x27; className=&#x27;nav-item&#x27;&gt; Contact &lt;/NavLink&gt; &lt;/nav&gt; &lt;main className=&#x27;layout-main&#x27;&gt;&#123;children&#125;&lt;/main&gt; &lt;/header&gt; &lt;/div&gt; )&#125;export default Layout 12345678910111213141516171819202122232425262728// src/app.jsximport React from &#x27;react&#x27;import &#123; BrowserRouter, Routes, Route &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import RootStyle from &#x27;@/styles/root.style&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;./pages/Contact&#x27;const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &lt;RootStyle /&gt; &lt;Layout&gt; &lt;Routes&gt; &lt;Route index element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&#x27;about&#x27; element=&#123;&lt;About /&gt;&#125; /&gt; &lt;Route path=&#x27;contact&#x27; element=&#123;&lt;Contact /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; )&#125;export default App 但是app.jsx中其实要放很多，引入、Provider之类的，放了一堆这个路由和导航，会导致页面内容过于混乱。在添加了styled-components的全局样式后，作为一个组件RootStyle引入后，在BrowserRouter标签下和其他的内容放到一起就很奇怪，后面如果还需要引入UI框架、ReactQuery等Provider的话，还需要嵌套多层。所以，在6之后的版本，使用useRoutes将router拆分出去作为一个组件引入到app.jsx中是我比较通常的做法。（需要注意，在引用了React 组件的文件，都需要为 .jsx的文件，否则会报错） 1234567891011121314151617181920// src/router/index.jsximport &#123; useRoutes &#125; from &#x27;react-router-dom&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;const routes = [ &#123; path: &#x27;/&#x27;, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt; &#125;]const RootRoutes = () =&gt; &#123; const router = useRoutes(routes) return router&#125;export default RootRoutes 这样让app.jsx保持比较精简的内容。 123456789101112131415161718192021// src/app.jsximport React from &#x27;react&#x27;import &#123; BrowserRouter, Routes, Route, NavLink &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import RootRoutes from &#x27;@/router&#x27;import RootStyle from &#x27;@/styles/root.style&#x27;const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &lt;RootStyle /&gt; &lt;Layout&gt; &lt;RootRoutes /&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; )&#125;export default App 6.4版本的路由调整在6.4的版本中引入了支持数据API的新路由： createBrowserRouter createMemoryRouter createHashRouter 之前的老路由将不支持数据API BrowserRouter MemoryRouter HashRouter NativeRouter StaticRouter 使用createRoutesFromElements可以将原来Routes、Route写法的路由直接转过来，不需要太多修改。并且可以从app.jsx中移出去。接下来我们看下如何使用。 在app.jsx文件中引入RouterProvider和路由文件即可。 1234567891011121314151617// src/app.jsximport React from &#x27;react&#x27;import &#123; RouterProvider &#125; from &#x27;react-router-dom&#x27;import &#123; router &#125; from &#x27;@/router/root-router&#x27;import RootStyle from &#x27;@/styles/root.style&#x27;const App = () =&gt; &#123; return ( &lt;&gt; &lt;RootStyle /&gt; &lt;RouterProvider router=&#123;router&#125; /&gt; &lt;/&gt; )&#125;export default App 在路由文件中，使用createBrowserRouter和createRoutesFromElements将原来Routes、Route标签写法的路由引入即可。在createRoutesFromElements中，不能使用Routes，createRoutesFromElements本身就相当于一个Routes。 123456789101112131415161718// src/router/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;export const router = createBrowserRouter( createRoutesFromElements( &lt;Route path=&#x27;/&#x27; element=&#123;&lt;Layout /&gt;&#125;&gt; &lt;Route index element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&#x27;about&#x27; element=&#123;&lt;About /&gt;&#125; /&gt; &lt;Route path=&#x27;contact&#x27; element=&#123;&lt;Contact /&gt;&#125; /&gt; &lt;/Route&gt; )) 同样也可以将标签写法转换成之前useRoutes的对象写法。 123456789101112131415161718192021// src/router/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;export const objectRouter = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; index: true, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt; &#125; ] &#125;]) 因为使用了路由的方式进行layout的包裹，所以这里需要将之前Layout组件中的children改成router中的Outlet标签。 123456789101112131415161718192021222324252627282930// src/components/Layout.jsximport React from &#x27;react&#x27;import &#123; NavLink, Outlet &#125; from &#x27;react-router-dom&#x27;const Layout = () =&gt; &#123; return ( &lt;div className=&#x27;layout&#x27;&gt; &lt;header className=&#x27;layout-header&#x27;&gt; &lt;h1 className=&#x27;logo&#x27;&gt;React Route 6.4&lt;/h1&gt; &lt;nav className=&#x27;navs&#x27;&gt; &lt;NavLink to=&#x27;/&#x27; className=&#x27;nav-item&#x27;&gt; Home &lt;/NavLink&gt; &lt;NavLink to=&#x27;about&#x27; className=&#x27;nav-item&#x27;&gt; About &lt;/NavLink&gt; &lt;NavLink to=&#x27;contact&#x27; className=&#x27;nav-item&#x27;&gt; Contact &lt;/NavLink&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main className=&#x27;layout-main&#x27;&gt; &lt;Outlet /&gt; &lt;/main&gt; &lt;/div&gt; )&#125;export default Layout 路由嵌套路由嵌套写法，和之前类似，只是换到了在createBrowserRouter中写。 123456789101112131415161718192021222324252627282930// src/router/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route, Navigate &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;import Type from &#x27;@/pages/Contact/Type&#x27;import Form from &#x27;@/pages/Contact/Form&#x27;export const objectRouter = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; index: true, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; index: true, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt; &#125; ] &#125; ] &#125;]) 需要注意的是，之前通常可以使用重复父级path来跳转到对应的路由，现在此方法不起作用了，但可以使用index的方法跳转。 123456789101112131415161718192021// after &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; path: &#x27;contact&#x27;, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt; &#125; ]&#125;// before&#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; index: true, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt; &#125; ]&#125; 自定义404错误页面和之前的方法一致。定义*的通配符。 12345678910111213141516171819202122232425262728293031323334// src/router/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route, Navigate &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;import Type from &#x27;@/pages/Contact/Type&#x27;import Form from &#x27;@/pages/Contact/Form&#x27;import NotFount from &#x27;@/pages/NotFount&#x27;export const objectRouter = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; index: true, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; index: true, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt; &#125; ] &#125;, &#123; path: &#x27;*&#x27;, element: &lt;NotFount /&gt; &#125; ] &#125;]) 6.4新增数据API之Loader基础使用这个Loader有点像NextJs中的getServerSideProps，但是以路由的方式向页面提供数据。并可以根据数据获取情况加载对应的数据。 我们新增一个Users的页面，并从https://gorest.co.in/public/v2/users，获取对应的Users数据。 注： Users为users页面的Layout页面。 12345678910111213141516171819202122232425262728293031323334// src/pages/Users/List.jsximport React from &#x27;react&#x27;import &#123; useLoaderData, Link &#125; from &#x27;react-router-dom&#x27;const UserList = () =&gt; &#123; const usersData = useLoaderData() return ( &lt;div className=&#x27;page-list&#x27;&gt; &#123;usersData?.map(user =&gt; ( &lt;Link to=&#123;user.id.toString()&#125; key=&#123;user.id&#125; className=&#x27;list-item&#x27;&gt; &lt;h4&gt;&#123;user.name&#125;&lt;/h4&gt; &lt;div&gt; &lt;span&gt;Email: &lt;/span&gt; &lt;span&gt;&#123;user.email&#125;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;Gender: &lt;/span&gt; &lt;span&gt;&#123;user.gender&#125;&lt;/span&gt; &lt;/div&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; )&#125;export const usersLoader = async () =&gt; &#123; const res = await fetch(&#x27;https://gorest.co.in/public/v2/users&#x27;) const data = await res.json() return data&#125;export default UserList 在root-router中引入usersLoader，并使用loader挂载到对应的路由上。 123456789101112131415161718192021222324252627282930313233343536373839404142// src/router/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route, Navigate &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;import Type from &#x27;@/pages/Contact/Type&#x27;import Form from &#x27;@/pages/Contact/Form&#x27;import NotFount from &#x27;@/pages/NotFount&#x27;import Users from &#x27;@/pages/Users&#x27;import UserList, &#123; usersLoader &#125; from &#x27;@/pages/Users/List&#x27;export const objectRouter = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; index: true, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; index: true, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt; &#125; ] &#125;, &#123; path: &#x27;users&#x27;, element: &lt;Users /&gt;, children: [ &#123; index: true, element: &lt;UserList /&gt;, loader: usersLoader &#125;, ] &#125;, &#123; path: &#x27;*&#x27;, element: &lt;NotFount /&gt; &#125; ] &#125;]) 通过loader传递params之前可以通过useParams的hook获取浏览器地址栏中的params参数。通过loader中的内置params参数也可以达到相同的效果。 通过获取单个用户详情时，解构出params中的id，来获取对应的用户数据。 123456789101112131415161718192021222324252627282930// src/pages/Users/Detail.jsximport React from &#x27;react&#x27;import &#123; useLoaderData &#125; from &#x27;react-router-dom&#x27;const UserDetail = () =&gt; &#123; const user = useLoaderData() return ( &lt;div className=&#x27;container page-container&#x27;&gt; &lt;h2 className=&#x27;page-title&#x27;&gt;name&lt;/h2&gt; &lt;div className=&#x27;page-content&#x27;&gt; &lt;strong&gt;Email: &lt;/strong&gt; &lt;p&gt; &#123;user.email&#125;&lt;/p&gt; &lt;strong&gt;Gender: &lt;/strong&gt; &lt;p&gt; &#123;user.gender&#125;&lt;/p&gt; &lt;strong&gt;Status: &lt;/strong&gt; &lt;p&gt; &#123;user.status&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export const userDetailLoader = async (&#123; params &#125;) =&gt; &#123; const &#123; id &#125; = params const res = await fetch(`https://gorest.co.in/public/v2/users/$&#123;id&#125;`) const data = await res.json() return data&#125;export default UserDetail 数据加载错误处理当获取数据错误时，可以通过在获取数据时的状态，抛出错误，并在路由中使用errorElement来展示错误信息加载的组件。 在获取数据时抛出错误。 1234567891011121314151617181920212223242526272829303132333435// src/pages/Users/Detail.jsximport React from &#x27;react&#x27;import &#123; useLoaderData &#125; from &#x27;react-router-dom&#x27;const UserDetail = () =&gt; &#123; const user = useLoaderData() return ( &lt;div className=&#x27;container page-container&#x27;&gt; &lt;h2 className=&#x27;page-title&#x27;&gt;name&lt;/h2&gt; &lt;div className=&#x27;page-content&#x27;&gt; &lt;strong&gt;Email: &lt;/strong&gt; &lt;p&gt; &#123;user.email&#125;&lt;/p&gt; &lt;strong&gt;Gender: &lt;/strong&gt; &lt;p&gt; &#123;user.gender&#125;&lt;/p&gt; &lt;strong&gt;Status: &lt;/strong&gt; &lt;p&gt; &#123;user.status&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export const userDetailLoader = async (&#123; params &#125;) =&gt; &#123; const &#123; id &#125; = params const res = await fetch(`https://gorest.co.in/public/v2/users/$&#123;id&#125;`) const data = await res.json() if (!res.ok) &#123; throw Error(&#x27;Failed to get data&#x27;) &#125; return data&#125;export default UserDetail 创建错误页面 1234567891011121314151617181920// src/pages/Users/Error.jsximport React from &#x27;react&#x27;import &#123; useRouteError, Link &#125; from &#x27;react-router-dom&#x27;const UserError = () =&gt; &#123; const error = useRouteError() return ( &lt;div className=&#x27;container page-container&#x27;&gt; &lt;h2 className=&#x27;page-title&#x27;&gt;Error&lt;/h2&gt; &lt;div className=&#x27;page-content&#x27;&gt; &lt;strong&gt;&#123;error.message&#125;&lt;/strong&gt; &lt;p&gt;&lt;/p&gt; &lt;Link to=&#x27;/&#x27;&gt;Back Homepage&lt;/Link&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default UserError 在路由中通过errorElement加载错误页面，当在Users的List和Detail页面都做了抛出错误，可以将errorElement放到父级路由上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// src/routers/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route, Navigate &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;import Type from &#x27;@/pages/Contact/Type&#x27;import Form from &#x27;@/pages/Contact/Form&#x27;import NotFount from &#x27;@/pages/NotFount&#x27;import Users from &#x27;@/pages/Users&#x27;import UserList, &#123; usersLoader &#125; from &#x27;@/pages/Users/List&#x27;import UserDetail, &#123; userDetailLoader &#125; from &#x27;@/pages/Users/Detail&#x27;import UserError from &#x27;@/pages/Users/Error&#x27;export const objectRouter = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; index: true, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; index: true, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt; &#125; ] &#125;, &#123; path: &#x27;users&#x27;, element: &lt;Users /&gt;, errorElement: &lt;UserError /&gt;, children: [ &#123; index: true, element: &lt;UserList /&gt;, loader: usersLoader &#125;, &#123; path: &#x27;:id&#x27;, element: &lt;UserDetail /&gt;, loader: userDetailLoader &#125; ] &#125;, &#123; path: &#x27;*&#x27;, element: &lt;NotFount /&gt; &#125; ] &#125;]) 6.4新增表单数据获取之Form这个算是个简单的formData的封装吧。 在表单页面通过Form标签中内置的request获取formData中表单字段name的值。通过对获取的数据进行验证，抛出错误阻止提交和跳转。 修改表单页面，使用Form标签，并进行提交，并通过request中的formData拿到表单数据。注：此处formAction函数一定要return出一个数据或null，否则报错。 12345678910111213141516171819202122232425262728293031323334353637383940414243// src/pages/Contact/Form.jsximport React from &#x27;react&#x27;import &#123; Form &#125; from &#x27;react-router-dom&#x27;const ContactForm = () =&gt; &#123; const data = useActionData() return ( &lt;div className=&#x27;page-container&#x27;&gt; &lt;Form method=&#x27;post&#x27; action=&#x27;/contact/form&#x27; className=&#x27;page-form&#x27;&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27; className=&#x27;form-label&#x27;&gt; Email &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;form-input&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#x27;content&#x27; className=&#x27;form-label&#x27;&gt; What Can We Help You Achieve?: &lt;/label&gt; &lt;textarea type=&#x27;text&#x27; name=&#x27;content&#x27; className=&#x27;form-textarea&#x27; rows=&#x27;6&#x27;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;button className=&#x27;form-btn&#x27; type=&#x27;submit&#x27;&gt; Submit &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/div&gt; )&#125;export const formAction = async (&#123; request &#125;) =&gt; &#123; const data = await request.formData() const submitFormInfo = &#123; email: data.get(&#x27;email&#x27;), content: data.get(&#x27;content&#x27;) &#125; console.log(&#x27;submitFormInfo&#x27;, submitFormInfo) return submitFormInfo&#125;export default ContactForm 在路由上配置此action 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// src/router/root-router.jsximport &#123; createBrowserRouter, createRoutesFromElements, Route, Navigate &#125; from &#x27;react-router-dom&#x27;import &#123; Layout &#125; from &#x27;@/components&#x27;import About from &#x27;@/pages/About&#x27;import Home from &#x27;@/pages/Home&#x27;import Contact from &#x27;@/pages/Contact&#x27;import Type from &#x27;@/pages/Contact/Type&#x27;import Form, &#123; formAction &#125; from &#x27;@/pages/Contact/Form&#x27;import NotFount from &#x27;@/pages/NotFount&#x27;import Users from &#x27;@/pages/Users&#x27;import UserList, &#123; usersLoader &#125; from &#x27;@/pages/Users/List&#x27;import UserDetail, &#123; userDetailLoader &#125; from &#x27;@/pages/Users/Detail&#x27;import UserError from &#x27;@/pages/Users/Error&#x27;export const objectRouter = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; index: true, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;about&#x27;, element: &lt;About /&gt; &#125;, &#123; path: &#x27;contact&#x27;, element: &lt;Contact /&gt;, children: [ &#123; index: true, element: &lt;Navigate to=&#x27;type&#x27; /&gt; &#125;, &#123; path: &#x27;type&#x27;, element: &lt;Type /&gt; &#125;, &#123; path: &#x27;form&#x27;, element: &lt;Form /&gt;, action: formAction &#125; ] &#125;, &#123; path: &#x27;users&#x27;, element: &lt;Users /&gt;, errorElement: &lt;UserError /&gt;, children: [ &#123; index: true, element: &lt;UserList /&gt;, loader: usersLoader &#125;, &#123; path: &#x27;:id&#x27;, element: &lt;UserDetail /&gt;, loader: userDetailLoader &#125; ] &#125;, &#123; path: &#x27;*&#x27;, element: &lt;NotFount /&gt; &#125; ] &#125;]) 通过对表单数据的验证，对数据进行拦截，未通过验证则抛出错误，通过后可以通过redire方法跳转到对应的页面。在Form组件中通过useActionData方法获取表单返回的错误信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// src/pages/Contact/Form.jsximport React from &#x27;react&#x27;import &#123; Form, redirect, useActionData &#125; from &#x27;react-router-dom&#x27;const ContactForm = () =&gt; &#123; const data = useActionData() return ( &lt;div className=&#x27;page-container&#x27;&gt; &#123;data &amp;&amp; data.error &amp;&amp; &lt;p&gt;&#123;data.error&#125;&lt;/p&gt;&#125; &lt;Form method=&#x27;post&#x27; action=&#x27;/contact/form&#x27; className=&#x27;page-form&#x27;&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27; className=&#x27;form-label&#x27;&gt; Email &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;form-input&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#x27;content&#x27; className=&#x27;form-label&#x27;&gt; What Can We Help You Achieve?: &lt;/label&gt; &lt;textarea type=&#x27;text&#x27; name=&#x27;content&#x27; className=&#x27;form-textarea&#x27; rows=&#x27;6&#x27;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;button className=&#x27;form-btn&#x27; type=&#x27;submit&#x27;&gt; Submit &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/div&gt; )&#125;export const formAction = async (&#123; request &#125;) =&gt; &#123; console.log(&#x27;request&#x27;, request) const data = await request.formData() const submitFormInfo = &#123; email: data.get(&#x27;email&#x27;), content: data.get(&#x27;content&#x27;) &#125; console.log(&#x27;submitFormInfo&#x27;, submitFormInfo) if (submitFormInfo.content.length &lt; 10) &#123; return &#123; error: &#x27;content must be over 10 chars long&#x27; &#125; &#125; return redirect(&#x27;/&#x27;)&#125;export default ContactForm 至此React Router Dom 6.4中的主要的新功能基本就这些，其他的还需要更加深入了解，可以看下官方文档中的说明。此处只做一个抛砖引玉，本次最后的Form是我最近比较想学的一个系列。对于不同的项目中，使用哪些form的库能更快的解决问题，后续会来做个比较。","permalink":"http://example.com/2023/02/02/React-Route-6-4%E5%8A%9F%E8%83%BD/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}],"title":"快速生成自己的色板样式模板","date":"2023/01/12","text":"之前有写过文章，使用 使用CSS变量给页面添加暗黑模式，本文算是前面这篇文章的补充吧，每次都要搞一堆不同颜色的色板也很是麻烦，体力活总有办法优化的。 借助ant-design/colors这个包，能帮助我们快速实现色板。 安装：1pnpm add @ant-design/colors 使用方法： 123456import &#123; generate &#125; from &#x27;@ant-design/colors&#x27;const colors = generate(&#x27;#1890ff&#x27;, &#123; theme: &#x27;dark&#x27;, backgroundColor: &#x27;#141414&#x27;,&#125;); 说明： 这个方法，需要传入一个主色#1890ff。 theme是色板的主题，是light还是dark。 backgoundColor是使用的背景色。 ‍ 方法结合这个方法，我们可以通过一个函数方法，通过传入一组颜色来生成一个样式模板。 1234567891011121314151617import &#123; generate &#125; from &#x27;@ant-design/colors&#x27;function generateColorTemplates(colors, theme, backgroundColor, prefix = &#x27;sim&#x27;) &#123; let css = `:root[data-color-mode=&#x27;$&#123;theme&#125;&#x27;]&#123;\\n` colors.forEach((&#123; name, color &#125;) =&gt; &#123; const colorShades = generate(color, &#123; theme, backgroundColor &#125;) css += ` --$&#123;prefix&#125;-$&#123;name&#125;: $&#123;color&#125;;\\n` colorShades.forEach((shade, index) =&gt; &#123; css += ` --$&#123;prefix&#125;-$&#123;name&#125;-$&#123;index&#125;: $&#123;shade&#125;;\\n` &#125;) &#125;) css += &#x27;&#125;&#x27; return css&#125; 参数说明： colors，需要传入一组颜色数组，格式：const colors = [&#123;name: &#39;red&#39;, color: &#39;#f5222d&#39; &#125;]。 theme，这里和antd的一样，是色板的主题，light或dark。 backgoundColor，也是和antd一样，使用的背景色。如light主题下，可以为#ffffff。 prefix，是模板的前缀，我这里使用的是sim。 ‍ 使用方法：12345678910import generateColorTemplates from &#x27;@/utils/generateColorTemplatesconst normalColor = [ &#123; name: &#x27;red&#x27;, color: &#x27;#f5222d&#x27; &#125;, &#123; name: &#x27;orange&#x27;, color: &#x27;#fa8c16&#x27; &#125;, &#123; name: &#x27;yellow&#x27;, color: &#x27;#fadb14&#x27; &#125;, &#123; name: &#x27;green&#x27;, color: &#x27;#52c41a&#x27; &#125;, &#123; name: &#x27;blue&#x27;, color: &#x27;#1677ff&#x27; &#125;]console.log(generateColorTemplates(normalColor, &#x27;light&#x27;, &#x27;#fff&#x27;, &#x27;sim&#x27;)) 输出结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657:root[data-color-mode=&#x27;light&#x27;]&#123; --sim-red: #f5222d; --sim-red-0: #fff1f0; --sim-red-1: #ffccc7; --sim-red-2: #ffa39e; --sim-red-3: #ff7875; --sim-red-4: #ff4d4f; --sim-red-5: #f5222d; --sim-red-6: #cf1322; --sim-red-7: #a8071a; --sim-red-8: #820014; --sim-red-9: #5c0011; --sim-orange: #fa8c16; --sim-orange-0: #fff7e6; --sim-orange-1: #ffe7ba; --sim-orange-2: #ffd591; --sim-orange-3: #ffc069; --sim-orange-4: #ffa940; --sim-orange-5: #fa8c16; --sim-orange-6: #d46b08; --sim-orange-7: #ad4e00; --sim-orange-8: #873800; --sim-orange-9: #612500; --sim-yellow: #fadb14; --sim-yellow-0: #feffe6; --sim-yellow-1: #ffffb8; --sim-yellow-2: #fffb8f; --sim-yellow-3: #fff566; --sim-yellow-4: #ffec3d; --sim-yellow-5: #fadb14; --sim-yellow-6: #d4b106; --sim-yellow-7: #ad8b00; --sim-yellow-8: #876800; --sim-yellow-9: #614700; --sim-green: #52c41a; --sim-green-0: #f6ffed; --sim-green-1: #d9f7be; --sim-green-2: #b7eb8f; --sim-green-3: #95de64; --sim-green-4: #73d13d; --sim-green-5: #52c41a; --sim-green-6: #389e0d; --sim-green-7: #237804; --sim-green-8: #135200; --sim-green-9: #092b00; --sim-blue: #1677ff; --sim-blue-0: #e6f4ff; --sim-blue-1: #bae0ff; --sim-blue-2: #91caff; --sim-blue-3: #69b1ff; --sim-blue-4: #4096ff; --sim-blue-5: #1677ff; --sim-blue-6: #0958d9; --sim-blue-7: #003eb3; --sim-blue-8: #002c8c; --sim-blue-9: #001d66;&#125; 这样就能快速输出我们想要的 色阶 样式模板。自己在格式化下，能更清晰的辨识即可。","permalink":"http://example.com/2023/01/12/%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E8%89%B2%E6%9D%BF%E6%A0%B7%E5%BC%8F%E6%A8%A1%E6%9D%BF/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}],"title":"使用CSS变量给页面添加暗黑模式","date":"2022/12/14","text":"之前有使用Styled Components的方式在页面中添加主题 Styled Components + Context 打造主题切换，但是过于繁琐和麻烦。于是之前又学习了下Chakra的暗黑模式，感觉也很麻烦，对于不想用Chakra框架，这种方式就很麻烦。前两天正好看到B站一小哥说这个用CSS变量的方式添加暗黑模式，遂学习了下，果然方便太多。 这里还有一篇文章来说这个暗黑模式的 THE COMPLETE GUIDE TO THE DARK MODE TOGGLE，有兴趣的可以去看下理论，这个里面写的代码使用存JavaScript的方式来实现属实有些拉胯，下面我们看下在React中如何快速实现。 ‍ 先准备好两套颜色，明亮和暗黑。我们先去 Material UI拿到他们暗黑模式下的基础配色，以及他的调色板中light颜色。如果有需要他还有两套比较亮度比较低的颜色可以使用。 然后到Antd的色彩生成器中去生成明亮和暗黑两套颜色。 明亮颜色生成器 暗黑颜色生成器 ‍ 于是我们拿到了以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// src/styles/base.style.css:root[data-color-mode=&#x27;light&#x27;] &#123; /* Typography */ --sim-text-primary: #212121; --sim-text-secondary: #666666; --sim-text-disabled: #9e9e9e; /* Button */ --sim-action-active: #757575; --sim-action-hover: #f5f5f5; --sim-action-selected: #ebebeb; --sim-action-disabled: #bdbdbd; --sim-action-disabeld-bg: #e0e0e0; /* Background */ --sim-bg-default: #ffffff; --sim-bg-paper: #ffffff; /* Divider */ --sim-divider: #e0e0e0; /* Palette Main Color:5 */ /*- Primary -*/ --sim-primary: #42a5f5; --sim-primary-0: #f0fbff; --sim-primary-1: #e8f8ff; --sim-primary-2: #bfe9ff; --sim-primary-3: #96d7ff; --sim-primary-4: #6ec2ff; --sim-primary-5: #42a5f5; --sim-primary-6: #2d81cf; --sim-primary-7: #1d60a8; --sim-primary-8: #104382; --sim-primary-9: #0a2c5c; /*- Secondary -*/ --sim-secondary: #ba68c8; --sim-secondary-0: #fff0ff; --sim-secondary-1: #faebfa; --sim-secondary-2: #ecdfed; --sim-secondary-3: #ddbce0; --sim-secondary-4: #cc90d4; --sim-secondary-5: #ba68c8; --sim-secondary-6: #914ca1; --sim-secondary-7: #6b337a; --sim-secondary-8: #471f54; --sim-secondary-9: #26112e; /*- Red -*/ --sim-red: #ef5350; --sim-red-0: #fff3f0; --sim-red-1: #fff2f0; --sim-red-2: #ffd4cf; --sim-red-3: #ffada6; --sim-red-4: #fc827c; --sim-red-5: #ef5350; --sim-red-6: #c9383b; --sim-red-7: #a3262c; --sim-red-8: #7d161f; --sim-red-9: #570f17; /*- Yellow -*/ --sim-yellow: #ff9800; --sim-yellow-0: #fff9e6; --sim-yellow-1: #ffe7a3; --sim-yellow-2: #ffd77a; --sim-yellow-3: #ffc552; --sim-yellow-4: #ffb029; --sim-yellow-5: #ff9800; --sim-yellow-6: #d97b00; --sim-yellow-7: #b35f00; --sim-yellow-8: #8c4600; --sim-yellow-9: #663000; /*- Blue -*/ --sim-blue: #03a9f4; --sim-blue-0: #e6fbff; --sim-blue-1: #a6efff; --sim-blue-2: #7de3ff; --sim-blue-3: #54d4ff; --sim-blue-4: #2bc3ff; --sim-blue-5: #03a9f4; --sim-blue-6: #0086cf; --sim-blue-7: #0068a8; --sim-blue-8: #004c82; --sim-blue-9: #00325c; /*- Green -*/ --sim-green: #4caf50; --sim-green-0: #e3f0e1; --sim-green-1: #d7e3d5; --sim-green-2: #c4d6c3; --sim-green-3: #99c997; --sim-green-4: #6fbd6f; --sim-green-5: #4caf50; --sim-green-6: #348a3a; --sim-green-7: #216327; --sim-green-8: #113d17; --sim-green-9: #061709; &#125; :root[data-color-mode=&#x27;dark&#x27;] &#123; /* Typography */ --sim-text-primary: #ffffff; --sim-text-secondary: #b8b8b8; --sim-text-disabled: #898989; /* Button */ --sim-action-active: #ffffff; --sim-action-hover: #252525; --sim-action-selected: #383838; --sim-action-disabled: #5a5a5a; --sim-action-disabeld-bg: #2f2f2f; /* Background */ --sim-bg-default: #121212; --sim-bg-paper: #121212; /* Divider */ --sim-divider: #2f2f2f; /* Palette Main Color:5 */ /*- Primary -*/ --sim-primary: #3b8fd3; --sim-primary-0: #141e29; --sim-primary-1: #192e41; --sim-primary-2: #203e56; --sim-primary-3: #285478; --sim-primary-4: #3172a6; --sim-primary-5: #3b8fd3; --sim-primary-6: #65b0e7; --sim-primary-7: #8fcdf3; --sim-primary-8: #bae3f8; --sim-primary-9: #e4f3fa; /*- Secondary -*/ --sim-secondary: #a15bad; --sim-secondary-0: #1f1722; --sim-secondary-1: #322136; --sim-secondary-2: #442c49; --sim-secondary-3: #5e3964; --sim-secondary-4: #7f4a88; --sim-secondary-5: #a15bad; --sim-secondary-6: #b983c1; --sim-secondary-7: #d3b4d6; --sim-secondary-8: #e5d9e6; --sim-secondary-9: #f5e7f5; /*- Red -*/ --sim-red: #ce4947; --sim-red-0: #281516; --sim-red-1: #401c1c; --sim-red-2: #542625; --sim-red-3: #752f2e; --sim-red-4: #a23c3a; --sim-red-5: #ce4947; --sim-red-6: #e57771; --sim-red-7: #f3a59f; --sim-red-8: #f8cec9; --sim-red-9: #faeeec; /*- Yellow -*/ --sim-yellow: #db8403; --sim-yellow-0: #2a1e0f; --sim-yellow-1: #442c0e; --sim-yellow-2: #593a0d; --sim-yellow-3: #7d4e0a; --sim-yellow-4: #ac6906; --sim-yellow-5: #db8403; --sim-yellow-6: #e7a027; --sim-yellow-7: #f3bc4f; --sim-yellow-8: #f8d177; --sim-yellow-9: #fae3a0; /*- Blue -*/ --sim-blue: #0592d2; --sim-blue-0: #0f1f29; --sim-blue-1: #0e2f41; --sim-blue-2: #0e3f56; --sim-blue-3: #0b5678; --sim-blue-4: #0874a5; --sim-blue-5: #0592d2; --sim-blue-6: #29b1e7; --sim-blue-7: #51caf3; --sim-blue-8: #7addf8; --sim-blue-9: #a3ebfa; /*- Green -*/ --sim-green: #4caf50; --sim-green-0: #141e15; --sim-green-1: #1b301c; --sim-green-2: #234125; --sim-green-3: #2c592e; --sim-green-4: #38783a; --sim-green-5: #439747; --sim-green-6: #66ac66; --sim-green-7: #92c090; --sim-green-8: #bfd0be; --sim-green-9: #d3dfd1; &#125; body &#123; background-color: var(--sim-bg-default); &#125; ‍ 然后去index.html文件上去给html标签添加一个属性data-color-mode=&#39;light&#39;，至此颜色已经准备完毕。我们来看下如何实现切换。可以通过自定义hooks来实现，然后这个hooks导出theme和toggleTheme，theme可以获得当前主题的值，toggleTheme是可以切换明亮&#x2F;暗黑主题的方法。 1234567891011121314151617181920212223242526272829303132333435// src/hooks/useTheme.jsximport React, &#123; useState, useEffect &#125; from &#x27;react&#x27;const useTheme = () =&gt; &#123; const [theme, setTheme] = useState(&#x27;light&#x27;) const root = document.documentElement useEffect(() =&gt; &#123; const localTheme = localStorage.getItem(&#x27;sim-theme&#x27;) if (localTheme) &#123; setTheme(localTheme) root.setAttribute(&#x27;data-color-mode&#x27;, localTheme) &#125; else &#123; setTheme(&#x27;light&#x27;) &#125; &#125;, []) const toggleTheme = () =&gt; &#123; if (theme === &#x27;light&#x27;) &#123; localStorage.setItem(&#x27;sim-theme&#x27;, &#x27;dark&#x27;) root.setAttribute(&#x27;data-color-mode&#x27;, &#x27;dark&#x27;) setTheme(&#x27;dark&#x27;) &#125; else &#123; localStorage.setItem(&#x27;sim-theme&#x27;, &#x27;light&#x27;) root.setAttribute(&#x27;data-color-mode&#x27;, &#x27;light&#x27;) setTheme(&#x27;light&#x27;) &#125; &#125; return &#123; theme, toggleTheme &#125;&#125;export default useTheme 这个hooks中的toggleTheme方法可以修改html标签上的data-color-theme的值，并把这个值保存到localstorage中做持久化。这样刷新页不会修改当前切换过来的主题颜色。 然后我们在页面中调用这个hooks，然后实现下简单的明亮&#x2F;暗黑模式的切换。 ‍ 因为项目是Tailwindcss的，他本身就有一套暗盒模式的样式写法，所以我们使用CSS Modules 的方式来实现这个样式切换。 先准备好样式，注意CSS Modules的书写方式，不能使用中划线。 12345678910111213141516171819202122232425262728293031323334353637383940// src/pages/Theme/style.module.css.box &#123; display: flex; justify-content: center; align-items: center; width: 80px; height: 80px; border-radius: 6px; font-size: 14px; color: var(--sim-text-primary);&#125;.primaryBg &#123; background-color: var(--sim-primary);&#125;.secondaryBg &#123; background-color: var(--sim-secondary);&#125;.blueBg &#123; background-color: var(--sim-blue);&#125;.redBg &#123; background-color: var(--sim-red);&#125;.yellowBg &#123; background-color: var(--sim-yellow);&#125;.greenBg &#123; background-color: var(--sim-green);&#125;.title &#123; color: var(--sim-text-primary);&#125; 调用CSS Modules也很麻烦，这也是我不喜欢用这个玩意的原因。我们使用clsx来辅助在一个className上邦两个样式。 1234567891011121314151617181920212223242526272829303132333435363738// src/pages/Theme/index.jsximport React from &#x27;react&#x27;import useTheme from &#x27;./useTheme&#x27;import cx from &#x27;clsx&#x27;import style from &#x27;./theme.module.css&#x27;const SetThemePage = () =&gt; &#123; const &#123; theme, toggleTheme &#125; = useTheme() console.log(&#x27;theme&#x27;, theme) return ( &lt;div className=&#x27;w-full min-h-screen&#x27;&gt; &lt;div className=&#x27;mx-auto my-10 w-[960px]&#x27;&gt; &lt;div className=&#x27;flex justify-end gap-4 items-center h-12 mb-10&#x27;&gt; &lt;button className=&#x27;bg-blue-500 text-white rounded-full px-4 py-1 hover:bg-blue-700&#x27; onClick=&#123;toggleTheme&#125; &gt; 切换 &lt;/button&gt; &lt;/div&gt; &lt;div className=&#x27;mb-6 text-sm font-bold mt-10&#x27;&gt; &lt;span className=&#123;style.title&#125;&gt;Theme Color&lt;/span&gt; &lt;/div&gt; &lt;div className=&#x27;grid grid-cols-6&#x27;&gt; &lt;div className=&#123;cx(style.box, style.primaryBg)&#125;&gt;Primary&lt;/div&gt; &lt;div className=&#123;cx(style.box, style.secondaryBg)&#125;&gt;Secondary&lt;/div&gt; &lt;div className=&#123;cx(style.box, style.blueBg)&#125;&gt;Blue&lt;/div&gt; &lt;div className=&#123;cx(style.box, style.redBg)&#125;&gt;Red&lt;/div&gt; &lt;div className=&#123;cx(style.box, style.yellowBg)&#125;&gt;Yellow&lt;/div&gt; &lt;div className=&#123;cx(style.box, style.greenBg)&#125;&gt;Green&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default SetThemePage 以下为两个模式切换的效果，可以看到右边的样式中会跟随切换展示不同的模式下的CSS属性值。 明亮模式 ‍ 暗黑模式 ​ ‍ 以上就通过四个文件的代码就实现了暗黑模式。如果稍微扩展下，就可以实现多个主题的切换。在样式中定义好多套样式CSS属性值在useTheme中修改下toggleTheme方法，使用switch接收切换的主题值即可。","permalink":"http://example.com/2022/12/14/%E4%BD%BF%E7%94%A8CSS%E5%8F%98%E9%87%8F%E7%BB%99%E9%A1%B5%E9%9D%A2%E6%B7%BB%E5%8A%A0%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"chakraui","slug":"chakraui","permalink":"http://example.com/tags/chakraui/"}],"title":"ChakraUI 暗黑模式切换","date":"2022/12/03","text":"使用ChakraUI可以快速切换暗黑模式。并且可以用来做主题切换，提供了一系列的钩子和函数使用起来非常方便。 ‍ 安装按官方给的安装，在vite中 1pnpm add @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^6 ‍ 配置安装好了后，需要在App文件中配置下。 12345678910111213141516171819202122import React from &#x27;react&#x27;import &#123; ChakraProvider, CSSReset &#125; from &#x27;@chakra-ui/react&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import RootRoutes from &#x27;@/router&#x27;import Layout from &#x27;@/components/layout&#x27;import RootStyle from &#x27;@/styles/base.style&#x27;const App = () =&gt; &#123; return ( &lt;ChakraProvider&gt; &lt;CSSReset /&gt; &lt;RootStyle /&gt; &lt;BrowserRouter&gt; &lt;Layout&gt; &lt;RootRoutes /&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; &lt;/ChakraProvider&gt; )&#125;export default App ‍ 如何使用配置完成后，我们就可以使用ChakraUI提供的钩子函数进行颜色主题的切换了 123456789101112131415161718192021222324// src/pages/Home/index.jsximport React from &#x27;react&#x27;import &#123; useColorMode, Button, Text, Box&#125; from &#x27;@chakra-ui/react&#x27;const Home = () =&gt; &#123; const &#123; colorMode, toggleColorMode &#125; = useColorMode() return ( &lt;div&gt; &lt;Box w=&#123;400&#125; h=&#123;200&#125; bgColor=&#123;colorMode === &#x27;light&#x27; ? &#x27;blue.200&#x27; : &#x27;red.100&#x27;&#125;&gt; &lt;Text&gt;当前模式：&#123;colorMode&#125;&lt;/Text&gt; &lt;/Box&gt; &lt;Button onClick=&#123;toggleColorMode&#125;&gt;切换模式&lt;/Button&gt; &lt;/div&gt; )&#125;export default Home 这样就实现了最简单的一个明亮和暗黑主题切换的模式了。 但是这样有一个问题，如果每次都用三元表达式来写这种样式判断就太麻烦了，需要自己写个方法。ChakraUI当然也想到了这个问题，于是他们提供了一个useColorModeValue的钩子方法。 12345678910111213141516171819202122232425262728// src/pages/Home/index.jsximport React from &#x27;react&#x27;import &#123; useColorMode, Button, Text, Box, useColorModeValue, LightMode, DarkMode&#125; from &#x27;@chakra-ui/react&#x27;const Home = () =&gt; &#123; const &#123; colorMode, toggleColorMode &#125; = useColorMode() const bgColor = useColorModeValue(&#x27;blue.200&#x27;, &#x27;red.100&#x27;) return ( &lt;div&gt; &lt;Box w=&#123;400&#125; h=&#123;200&#125; bgColor=&#123;bgColor&#125;&gt; &lt;Text&gt;当前模式：&#123;colorMode&#125;&lt;/Text&gt; &lt;/Box&gt; &lt;Button onClick=&#123;toggleColorMode&#125;&gt;切换模式&lt;/Button&gt; &lt;/div&gt; )&#125;export default Home 我们可以使用这个钩子方法来处理需要切换的颜色样式。 ‍ 强制主题模式样式有的场景需要保持主题模式下处于明亮或暗黑样式不变化，我们就可以使用LightMode和DarkMode两个组件对于不需要变化的组件进行包裹。 12345678910111213141516171819202122232425262728293031323334353637// src/pages/Home/index.jsximport React from &#x27;react&#x27;import &#123; useColorMode, Button, Text, Box, useColorModeValue, LightMode, DarkMode&#125; from &#x27;@chakra-ui/react&#x27;const Home = () =&gt; &#123; const &#123; colorMode, toggleColorMode &#125; = useColorMode() const bgColor = useColorModeValue(&#x27;blue.200&#x27;, &#x27;red.100&#x27;) return ( &lt;div&gt; &lt;Box w=&#123;400&#125; h=&#123;200&#125; bgColor=&#123;bgColor&#125;&gt; &lt;Text&gt;当前模式：&#123;colorMode&#125;&lt;/Text&gt; &lt;Button&gt;变色的按钮&lt;/Button&gt; &lt;LightMode&gt; &lt;Button colorScheme=&#x27;purple&#x27;&gt;不变色的按钮&lt;/Button&gt; &lt;/LightMode&gt; &lt;DarkMode&gt; &lt;Button colorScheme=&#x27;orange&#x27;&gt;不变色的按钮&lt;/Button&gt; &lt;/DarkMode&gt; &lt;/Box&gt; &lt;Button onClick=&#123;toggleColorMode&#125;&gt;切换模式&lt;/Button&gt; &lt;/div&gt; )&#125;export default Home ‍ 设置默认主题模式可以根据自定义主题的一些配置，来设置默认主题的模式。 通过extendTheme这个方法来配置继承的主题配置。 initialColorMode：设置默认主题模式，默认值是light。 useSystemColorMode：设置默认使用系统主题哦是，默认值是false。 1234567891011121314151617181920212223242526272829303132// src/app.jsimport React from &#x27;react&#x27;import &#123; ChakraProvider, CSSReset, extendTheme &#125; from &#x27;@chakra-ui/react&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import RootRoutes from &#x27;@/router&#x27;import Layout from &#x27;@/components/layout&#x27;import RootStyle from &#x27;@/styles/base.style&#x27;const theme = extendTheme(&#123; config: &#123; initialColorMode: &#x27;dark&#x27; // useSystemColorMode: true &#125;&#125;)const App = () =&gt; &#123; return ( &lt;ChakraProvider theme=&#123;theme&#125;&gt; &lt;CSSReset /&gt; &lt;RootStyle /&gt; &lt;BrowserRouter&gt; &lt;Layout&gt; &lt;RootRoutes /&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; &lt;/ChakraProvider&gt; )&#125;export default App extendTheme这个主题继承还可以定义ChakraUI中组件的一些样式配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import &#123; extendTheme &#125; from &#x27;@chakra-ui/react&#x27;const theme = extendTheme(&#123; colors: &#123;...&#125;, fonts: &#123; body: &quot;system-ui, sans-serif&quot;, heading: &quot;Georgia, serif&quot;, mono: &quot;Menlo, monospace&quot;, &#125;, fontSizes: &#123; xs: &quot;0.75rem&quot;, sm: &quot;0.875rem&quot;, md: &quot;1rem&quot;, lg: &quot;1.125rem&quot;, xl: &quot;1.25rem&quot;, &quot;2xl&quot;: &quot;1.5rem&quot;, &quot;3xl&quot;: &quot;1.875rem&quot;, &quot;4xl&quot;: &quot;2.25rem&quot;, &quot;5xl&quot;: &quot;3rem&quot;, &quot;6xl&quot;: &quot;3.75rem&quot;, &quot;7xl&quot;: &quot;4.5rem&quot;, &quot;8xl&quot;: &quot;6rem&quot;, &quot;9xl&quot;: &quot;8rem&quot;, &#125;, fontWeights: &#123; hairline: 100, thin: 200, light: 300, normal: 400, medium: 500, semibold: 600, bold: 700, extrabold: 800, black: 900, &#125;, lineHeights: &#123; normal: &quot;normal&quot;, none: 1, shorter: 1.25, short: 1.375, base: 1.5, tall: 1.625, taller: &quot;2&quot;, &quot;3&quot;: &quot;.75rem&quot;, &quot;4&quot;: &quot;1rem&quot;, &quot;5&quot;: &quot;1.25rem&quot;, &quot;6&quot;: &quot;1.5rem&quot;, &quot;7&quot;: &quot;1.75rem&quot;, &quot;8&quot;: &quot;2rem&quot;, &quot;9&quot;: &quot;2.25rem&quot;, &quot;10&quot;: &quot;2.5rem&quot;, &#125;, letterSpacings: &#123; tighter: &quot;-0.05em&quot;, tight: &quot;-0.025em&quot;, normal: &quot;0&quot;, wide: &quot;0.025em&quot;, wider: &quot;0.05em&quot;, widest: &quot;0.1em&quot;, &#125;, breakpoints: &#123; sm: &#x27;30em&#x27;, md: &#x27;48em&#x27;, lg: &#x27;62em&#x27;, xl: &#x27;80em&#x27;, &#x27;2xl&#x27;: &#x27;96em&#x27;, &#125;, space: &#123; px: &#x27;1px&#x27;, 0.5: &#x27;0.125rem&#x27;, 1: &#x27;0.25rem&#x27;, 1.5: &#x27;0.375rem&#x27;, 2: &#x27;0.5rem&#x27;, 2.5: &#x27;0.625rem&#x27;, 3: &#x27;0.75rem&#x27;, 3.5: &#x27;0.875rem&#x27;, 4: &#x27;1rem&#x27;, 5: &#x27;1.25rem&#x27;, 6: &#x27;1.5rem&#x27;, 7: &#x27;1.75rem&#x27;, 8: &#x27;2rem&#x27;, 9: &#x27;2.25rem&#x27;, 10: &#x27;2.5rem&#x27;, 12: &#x27;3rem&#x27;, 14: &#x27;3.5rem&#x27;, 16: &#x27;4rem&#x27;, 20: &#x27;5rem&#x27;, 24: &#x27;6rem&#x27;, 28: &#x27;7rem&#x27;, 32: &#x27;8rem&#x27;, 36: &#x27;9rem&#x27;, 40: &#x27;10rem&#x27;, 44: &#x27;11rem&#x27;, 48: &#x27;12rem&#x27;, 52: &#x27;13rem&#x27;, 56: &#x27;14rem&#x27;, 60: &#x27;15rem&#x27;, 64: &#x27;16rem&#x27;, 72: &#x27;18rem&#x27;, 80: &#x27;20rem&#x27;, 96: &#x27;24rem&#x27;, &#125;, sizes: &#123; ...theme.space, max: &#x27;max-content&#x27;, min: &#x27;min-content&#x27;, full: &#x27;100%&#x27;, &#x27;3xs&#x27;: &#x27;14rem&#x27;, &#x27;2xs&#x27;: &#x27;16rem&#x27;, xs: &#x27;20rem&#x27;, sm: &#x27;24rem&#x27;, md: &#x27;28rem&#x27;, lg: &#x27;32rem&#x27;, xl: &#x27;36rem&#x27;, &#x27;2xl&#x27;: &#x27;42rem&#x27;, &#x27;3xl&#x27;: &#x27;48rem&#x27;, &#x27;4xl&#x27;: &#x27;56rem&#x27;, &#x27;5xl&#x27;: &#x27;64rem&#x27;, &#x27;6xl&#x27;: &#x27;72rem&#x27;, &#x27;7xl&#x27;: &#x27;80rem&#x27;, &#x27;8xl&#x27;: &#x27;90rem&#x27;, container: &#123; sm: &#x27;640px&#x27;, md: &#x27;768px&#x27;, lg: &#x27;1024px&#x27;, xl: &#x27;1280px&#x27;, &#125;, &#125;, radii: &#123; none: &#x27;0&#x27;, sm: &#x27;0.125rem&#x27;, base: &#x27;0.25rem&#x27;, md: &#x27;0.375rem&#x27;, lg: &#x27;0.5rem&#x27;, xl: &#x27;0.75rem&#x27;, &#x27;2xl&#x27;: &#x27;1rem&#x27;, &#x27;3xl&#x27;: &#x27;1.5rem&#x27;, full: &#x27;9999px&#x27;, &#125;, zIndices: &#123; hide: -1, auto: &#x27;auto&#x27;, base: 0, docked: 10, dropdown: 1000, sticky: 1100, banner: 1200, overlay: 1300, modal: 1400, popover: 1500, skipLink: 1600, toast: 1700, tooltip: 1800, &#125;,&#125;) ‍ ChakraUI框架的断点是基于移动优先的min最小宽度来设置的。","permalink":"http://example.com/2022/12/03/ChakraUI-%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"firebase","slug":"firebase","permalink":"http://example.com/tags/firebase/"}],"title":"Firebase学习笔记之Auth和storage","date":"2022/11/10","text":"这里主要记录下Auth这块的使用。功能上基本同之前的NextAuth差不多。但是Firebase并不是一个单一的权限系统，和数据等很多功能整合在一起了，所以使用上会比NextAuth单一的功能强很多。 开通Authentication 在控制面板中点击Authentication模块。进入到Authentication的配置。在users的选项卡下，首先会让你设置登录方法，点击该按钮。 ​ 进入到设置登录方法选项卡，可以看到Firebase提供了基础的邮箱和电话登录，和一些常用的国外第三方登录。我们一般选择邮件登录。 ​ 然后再电子邮件地址&#x2F;密码方法中选择，使用电子邮件和密码的方式登录。然后保存。 ​ 点击保存按钮，后在users选项卡页面下，就可以看到用户列表，只是现在是个空的。 ​ 我们添加上一个用户，等会在项目中使用该用户进行登录。由于这里只提供了一个用户基础配置，后续用户的信息还需要导Firebase的Firestore中继续补充，我们稍后再说。 ‍ Auth这块，一起来学习三个登录方式，通过邮件和密码、Google账号和Github账号，由于之前已经在Strapi用户登录鉴权的文章中说过如何鉴权，所以本文不做过多的说明。 因为Auth和Firestore不是一个模块，所以方法也需要使用firebase/auth来进行引用。所以我们在之前的基础上增加getAuth的引用，并进行初始化。 1234567891011121314151617181920212223// firebase-config.jsimport &#123; initializeApp &#125; from &#x27;firebase/app&#x27;import &#123; getFirestore, collection &#125; from &#x27;firebase/firestore&#x27;import &#123; getAuth &#125; from &#x27;firebase/auth&#x27;const firebaseConfig = &#123; apiKey: &#x27;AIzaSyAKrb_8yZJvjPIWfEWrFp3-sNiPGDHLu3E&#x27;, authDomain: &#x27;fir-9-dojo-45a52.firebaseapp.com&#x27;, projectId: &#x27;fir-9-dojo-45a52&#x27;, storageBucket: &#x27;fir-9-dojo-45a52.appspot.com&#x27;, messagingSenderId: &#x27;318947200672&#x27;, appId: &#x27;1:318947200672:web:1caac86ca52696090343c5&#x27;&#125;// 初始化Firebaseconst app = initializeApp(firebaseConfig)// 初始化数据服务export const db = getFirestore(app)// 初始化权限export const auth = getAuth(app) ‍ 基础版Auth同样也分两个版本，基础版，我们只实现简单的邮件&#x2F;密码，注册、登录、登出、Google登录、Github登录。 ‍ Auth数据交互同样，与Firebase Auth的数据交互我们放到store中。在store目录下新建一个auth.store.js的文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// src/store/auth.store.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; auth, db &#125; from &#x27;firebaseConfig&#x27;import &#123; setDoc, doc, serverTimestamp &#125; from &#x27;firebase/firestore&#x27;import &#123; createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, GithubAuthProvider&#125; from &#x27;firebase/auth&#x27;export const authStore = proxy(&#123; user: null, isLogin: false&#125;)// 登录事件观察const unsubAuth = onAuthStateChanged(auth, user =&gt; &#123; console.log(&#x27;user auth state&#x27;, user) if (user) &#123; localStorage.setItem(&#x27;user&#x27;, JSON.stringify(user)) authStore.user = user authStore.isLogin = true &#125; else &#123; localStorage.removeItem(&#x27;user&#x27;) authStore.user = null authStore.isLogin = false &#125;&#125;)export const authAction = &#123; // 注册 signUp: async (email, password) =&gt; &#123; await createUserWithEmailAndPassword(auth, email, password) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;, // 登录 signIn: async (email, password) =&gt; &#123; await signInWithEmailAndPassword(auth, email, password) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;, // 登出 signOut: async () =&gt; &#123; await signOut(auth) .then(() =&gt; &#123; window.location.href = &#x27;/login&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) unsubAuth() &#125;, // Google登录 googleSignIn: async () =&gt; &#123; const provider = new GoogleAuthProvider() await signInWithPopup(auth, provider) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;, // Github登录 githubSignIn: async () =&gt; &#123; const provider = new GithubAuthProvider() await signInWithPopup(auth, provider) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;&#125; 我们来看下登录权限这块的几个方法。 createUserWithEmailAndPassword()：创建与指定电子邮件地址和密码关联的新用户帐户。成功创建用户帐户后，该用户也将登录到您的应用程序。如果帐户已存在或密码无效，则用户帐户创建可能会失败。 参数： auth，授权，接收身份验证的实例。传入初始化的身份实例即可。 email，邮件，登录使用的邮件，毕竟是邮件和密码登录。 password​，密码。 回调​，返回一个用户凭证。 这里我们传入邮件和密码，如果成功后，跳转到home页面，如果失败，则打印错误。 123456789signUp: async (email, password) =&gt; &#123; await createUserWithEmailAndPassword(auth, email, password) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;)&#125; ‍ signInWithEmailAndPassword()：使用电子邮件和密码异步登录。如果电子邮件地址和密码不匹配，则会失败并显示错误。 参数： auth，授权，同注册。 email，邮件，同注册。 password，密码，同注册。 回调​，返回一个用户凭证。 登录和注册基本差不多，就是方法名称不一样，入参和出参都一样。 123456789signIn: async (email, password) =&gt; &#123; await signInWithEmailAndPassword(auth, email, password) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;)&#125;, ‍ signOut()：注销当前用户。 参数： auth​，授权，同注册。 登出就更简单了，但是要注意登出后需要进行的一些动作处理。这里，我们有一个unsubAuth()，和我们下面说到的onAuthStateChanged有关，此处暂且不表。 12345678910signOut: async () =&gt; &#123; await signOut(auth) .then(() =&gt; &#123; window.location.href = &#x27;/login&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) unsubAuth()&#125; ‍ 下面第三方登录的三个方法需要放到一起来说。 GoogleAuthProvider()：谷歌身份验证实例。 signInWithPopup()：使用弹窗登录。 signInWithRedirect()：使用跳转地址登录。 signInWithPopup()和signInWithRedirect()只是形式不同，一个是会弹一个小窗，到第三方平台，你登录后，小窗关闭这边再跳转。一个是直接在浏览器里跳转过去，你登录后再跳转回来。两个的参数都相同。 参数： auth，授权。 providerId​，程序标识实例。 因为Firebase是谷歌的产品，所以内部已经打通，不需要你去申请第三方的AppId和密钥，但是Github就会需要。我们看到Github和谷歌的登录方法都差不多，只是程序标识实例不一样。 123456789101112131415161718192021googleSignIn: async () =&gt; &#123; const provider = new GoogleAuthProvider() await signInWithPopup(auth, provider) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;)&#125;githubSignIn: async () =&gt; &#123; const provider = new GithubAuthProvider() await signInWithPopup(auth, provider) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;)&#125; 所以，这里只说下Github的AppId和密钥如何申请。 这里有三个步骤： 去Firebase的Authentication中的Sign-in method标签页中选择Github，先拿到回调网址。 ​ 再去Github上将项目注册为开发人员的应用。获取客户端ID、和客户端密钥。应用名称随便写，主页URL，写http://localhost:5173即可。Authorization callback URL，就将之前拿到的回调网址粘贴上去。提交即可。 ​ 然后从跳转的页面拿到客户端id 和 密钥 粘贴回 Firebase的Github页面即可。 最后来看下登录权限这块的最后一个方法。 onAuthStateChanged()：添加对用户登录状态更改的观察者。这个类似Firestore中的onSnapshot，参考onSnapshot即可。最后返回这个方法，进行退订。 12345onAuthStateChanged ( nextOrObserver : Observer &lt; any &gt; | ( ( a : User | null ) =&gt; any ), error ? : ( a : Error ) =&gt; any, completed ? : firebase.Unsubscribe ) : firebase.Unsubscribe 我们使用这个观察者代码，来设置store中的user和isLogin的值和localstorage中的user，在登出时，执行这个观察方法，进行退订。 123456789101112const unsubAuth = onAuthStateChanged(auth, user =&gt; &#123; console.log(&#x27;user auth state&#x27;, user) if (user) &#123; localStorage.setItem(&#x27;user&#x27;, JSON.stringify(user)) authStore.user = user authStore.isLogin = true &#125; else &#123; localStorage.removeItem(&#x27;user&#x27;) authStore.user = null authStore.isLogin = false &#125;&#125;) ‍ 界面数据交互Register代码很简单，拿到邮箱和密码提交，将邮箱密码传递给signUp方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// src/pages/Register.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; authStore, authAction &#125; from &#x27;@/store/auth.store&#x27;const Register = () =&gt; &#123; const snap = useSnapshot(authStore) const [user, setUser] = useState(&#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125;) const handleSubmit = async () =&gt; &#123; await authAction.signUp(user.email, user.password) setUser(&#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125;) &#125; return ( &lt;div className=&#x27;w-srceen h-full&#x27;&gt; &#123;snap.message ? ( &lt;div className=&#x27;toast toast-end toast-top top-20&#x27;&gt; &lt;div className=&#x27;alert alert-success py-2 text-white&#x27;&gt; &lt;span&gt;&#123;snap.message&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ) : null&#125; &#123;snap.errorMessage ? ( &lt;div className=&#x27;toast toast-end toast-top top-20&#x27;&gt; &lt;div className=&#x27;alert alert-error py-2 text-white&#x27;&gt; &lt;div&gt; &lt;span&gt;&#123;snap.errorMessage&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) : null&#125; &lt;div className=&#x27;w-[400px] mx-auto mt-40 border rounded-md&#x27;&gt; &lt;div className=&#x27;mb-4 h-10 flex justify-start items-center text-sm text-gray800 bg-gray-200 px-4&#x27;&gt; 注册 Register &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center px-4 mb-4&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27; className=&#x27;text-sm text-gray-500&#x27;&gt; 邮箱 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;flex-1 ml-2 h-8 border hover:border-gray-400 text-sm text-gray-800 rounded-sm w-full outline-none px-4&#x27; value=&#123;user.email&#125; onChange=&#123;e =&gt; setUser(&#123; ...user, email: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center px-4 mb-4&#x27;&gt; &lt;label htmlFor=&#x27;password&#x27; className=&#x27;text-sm text-gray-500&#x27;&gt; 密码 &lt;/label&gt; &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27; className=&#x27;flex-1 ml-2 h-8 border hover:border-gray-400 text-sm text-gray-800 rounded-sm w-full outline-none px-4&#x27; value=&#123;user.password&#125; onChange=&#123;e =&gt; setUser(&#123; ...user, password: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-end items-center h-10 px-4 mb-4&#x27;&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;px-4 py-2 text-sm text-white bg-blue-500 hover:bg-blue-800 rounded-md&#x27; onClick=&#123;handleSubmit&#125; &gt; 注册 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Register ‍ Login这个页面也很简单，拿到邮箱和密码，提交给signIn方法，完成邮箱密码登录。 绑定googleSignIn方法给Google登录的按钮。 绑定githubSignIn方法给Github登录的按钮。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// src/pages/Login.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; authStore, authAction &#125; from &#x27;@/store/auth.store&#x27;const Login = () =&gt; &#123; const navigate = useNavigate() const snap = useSnapshot(authStore) const [user, setUser] = useState(&#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125;) const handleSubmit = async () =&gt; &#123; const userToken = localStorage.getItem(&#x27;user&#x27;) await authAction.signIn(user.email, user.password) setUser(&#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125;) &#125; const handleGoogleSignIn = async () =&gt; &#123; await authAction.googleSignIn() &#125; const handleGithubSignIn = async () =&gt; &#123; await authAction.githubSignIn() &#125; return ( &lt;div className=&#x27;w-srceen h-full&#x27;&gt; &lt;div className=&#x27;w-[400px] mx-auto mt-40 border rounded-md&#x27;&gt; &lt;div className=&#x27;mb-4 h-10 flex justify-start items-center text-sm text-gray800 bg-gray-200 px-4&#x27;&gt; 登录 Login &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center px-4 mb-4&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27; className=&#x27;text-sm text-gray-500&#x27;&gt; 邮箱 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;flex-1 ml-2 h-8 border hover:border-gray-400 text-sm text-gray-800 rounded-sm w-full outline-none px-4&#x27; value=&#123;user.email&#125; onChange=&#123;e =&gt; setUser(&#123; ...user, email: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center px-4 mb-4&#x27;&gt; &lt;label htmlFor=&#x27;password&#x27; className=&#x27;text-sm text-gray-500&#x27;&gt; 密码 &lt;/label&gt; &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27; className=&#x27;flex-1 ml-2 h-8 border hover:border-gray-400 text-sm text-gray-800 rounded-sm w-full outline-none px-4&#x27; value=&#123;user.password&#125; onChange=&#123;e =&gt; setUser(&#123; ...user, password: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-end items-center h-10 px-4 mb-4&#x27;&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;mr-4 px-4 py-2 text-sm text-white bg-gray-700 hover:bg-gray-900 rounded-md&#x27; onClick=&#123;handleGithubSignIn&#125; &gt; Github登录 &lt;/button&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;mr-4 px-4 py-2 text-sm text-white bg-blue-500 hover:bg-blue-900 rounded-md&#x27; onClick=&#123;handleGoogleSignIn&#125; &gt; Google登录 &lt;/button&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;px-4 py-2 text-sm text-white bg-blue-500 hover:bg-blue-800 rounded-md&#x27; onClick=&#123;handleSubmit&#125; &gt; 登录 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Login ‍ 升级版升级版我们也是基于基础版的问题，做的扩展，因为Auth只使用了邮箱和密码登录，但是没有给到其他的东西。比如用户的姓名、昵称、头像。这些东西怎么关联。我们将在升级版中完成在注册账号的同时在Firestore中新建一个用户集合，并将用户邮箱作为文档，补充用户名、昵称、头像、创建时间。 ‍ Auth数据交互还是store的代码，我们只在signUp方法上做了调整。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// src/store/auth.store.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; auth, db &#125; from &#x27;firebaseConfig&#x27;import &#123; setDoc, doc, serverTimestamp &#125; from &#x27;firebase/firestore&#x27;import &#123; createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, GithubAuthProvider&#125; from &#x27;firebase/auth&#x27;export const authStore = proxy(&#123; user: null, isLogin: false&#125;)const unsubAuth = onAuthStateChanged(auth, user =&gt; &#123; console.log(&#x27;user auth state&#x27;, user) if (user) &#123; localStorage.setItem(&#x27;user&#x27;, JSON.stringify(user)) authStore.user = user authStore.isLogin = true &#125; else &#123; localStorage.removeItem(&#x27;user&#x27;) authStore.user = null authStore.isLogin = false &#125;&#125;)export const authAction = &#123; signUp: async (email, password) =&gt; &#123; const res = await createUserWithEmailAndPassword(auth, email, password).catch(error =&gt; &#123; console.log(error.message) &#125;) await setDoc(doc(db, &#x27;users&#x27;, email), &#123; uid: res.user.uid, username: &#x27;&#x27;, nickname: &#x27;&#x27;, avatarImage: &#x27;&#x27;, createAt: serverTimestamp() &#125;) &#125;, signIn: async (email, password) =&gt; &#123; await signInWithEmailAndPassword(auth, email, password) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;, signOut: async () =&gt; &#123; await signOut(auth) .then(() =&gt; &#123; window.location.href = &#x27;/login&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) unsubAuth() &#125;, googleSignIn: async () =&gt; &#123; const provider = new GoogleAuthProvider() await signInWithPopup(auth, provider) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;, githubSignIn: async () =&gt; &#123; const provider = new GithubAuthProvider() await signInWithPopup(auth, provider) .then(() =&gt; &#123; window.location.href = &#x27;/home&#x27; &#125;) .catch(error =&gt; &#123; console.log(error.message) &#125;) &#125;&#125; 我们单独看下调整的代码。 前面的的代码还是一样，通过createUserWithEmailAndPassword方法，创建一个用户，并返回给一个变量。因为是Promise，所以，在后面我们await 一个setDoc，同时在users下创建一个email的文档。字段有uid、username、nickname、avatarImage、createAt。 因为setDoc会判断如果没有这个集合、文档、字段他就会创建相应的内容。 123456789101112signUp: async (email, password) =&gt; &#123; const res = await createUserWithEmailAndPassword(auth, email, password).catch(error =&gt; &#123; console.log(error.message) &#125;) await setDoc(doc(db, &#x27;users&#x27;, email), &#123; uid: res.user.uid, username: &#x27;&#x27;, nickname: &#x27;&#x27;, avatarImage: &#x27;&#x27;, createAt: serverTimestamp() &#125;)&#125;, ‍ 然后我们创建一个user.store.js的页面在store​下，来处理用户资料修改的数据。 这里头像存储，会涉及到Firebase的storage，以及之前学习过的Firestore中的getDoc和updateDoc。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// src/store/user.store.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; storage, db &#125; from &#x27;firebaseConfig&#x27;import &#123; setDoc, doc, serverTimestamp, updateDoc, getDoc &#125; from &#x27;firebase/firestore&#x27;import &#123; ref, uploadBytesResumable, getDownloadURL &#125; from &#x27;firebase/storage&#x27;export const userStore = proxy(&#123; username: &#x27;&#x27;, nickname: &#x27;&#x27;, avatarImage: &#x27;&#x27;, progress: &#x27;&#x27;, avatarUrl: &#x27;&#x27;&#125;)export const userAction = &#123; uploadAvatar: file =&gt; &#123; const name = new Date().getTime() + file.name const storageRef = ref(storage, name) const uploadTask = uploadBytesResumable(storageRef, file) uploadTask.on( &#x27;state_changed&#x27;, snapshot =&gt; &#123; const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100 console.log(&#x27;Upload is &#x27; + progress + &#x27;% done&#x27;) userStore.progress = progress switch (snapshot.state) &#123; case &#x27;paused&#x27;: console.log(&#x27;Upload is paused&#x27;) break case &#x27;running&#x27;: console.log(&#x27;Upload is running&#x27;) break default: break &#125; &#125;, error =&gt; &#123; console.log(error) &#125;, () =&gt; &#123; getDownloadURL(uploadTask.snapshot.ref).then(downloadURL =&gt; &#123; userStore.avatarUrl = downloadURL &#125;) &#125; ) &#125;, getUserProfile: async email =&gt; &#123; const userRef = doc(db, &#x27;users&#x27;, email) return await getDoc(userRef).then(user =&gt; &#123; console.log(&#x27;get profile success ~&#x27;) userStore.username = user.data().username userStore.nickname = user.data().nickname userStore.avatarUrl = user.data().avatarImage &#125;) &#125;, updateUserProfile: async (email, profile) =&gt; &#123; const userRef = doc(db, &#x27;users&#x27;, email) return await updateDoc(userRef, &#123; ...profile &#125;) &#125;&#125; storage需要在Firebase的config文件中初始化以下，这里就只贴相关代码不做完整粘贴了。 12345678910// firebase-config.jsimport &#123; initializeApp &#125; from &#x27;firebase/app&#x27;import &#123; getStorage &#125; from &#x27;firebase/storage&#x27;// 初始化Firebaseconst app = initializeApp(firebaseConfig)// 初始化存储export const storage = getStorage(app) 然后我们再来看下user.store​中头像上传的方法。 uploadBytesResumable()：将数据上传到该对象的位置。上传可以暂停和恢复，并公开进度更新。 参数： ref，存储参考。 data，要上传的数据。 metadata​，要上传的元数据。 回调​，上传任务。 ‍ 基本流程 给头像图片一个新名称，使用时间戳 + 文件名称 然后通过ref()这个方法，找到需要对应的路径，类似于Firestore中的collection​。 然后通过uploadBytesResumable()，这个方法进行文件上传，他的on()​方法，会返回上传的进度。 然后上传方法之后返回错误和回调，回调会返回上传的地址，我们将它设置给store的avatarImage。 12345678910111213141516171819202122232425262728293031uploadAvatar: file =&gt; &#123; const name = new Date().getTime() + file.name const storageRef = ref(storage, name) const uploadTask = uploadBytesResumable(storageRef, file) uploadTask.on( &#x27;state_changed&#x27;, snapshot =&gt; &#123; const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100 console.log(&#x27;Upload is &#x27; + progress + &#x27;% done&#x27;) userStore.progress = progress switch (snapshot.state) &#123; case &#x27;paused&#x27;: console.log(&#x27;Upload is paused&#x27;) break case &#x27;running&#x27;: console.log(&#x27;Upload is running&#x27;) break default: break &#125; &#125;, error =&gt; &#123; console.log(error) &#125;, () =&gt; &#123; getDownloadURL(uploadTask.snapshot.ref).then(downloadURL =&gt; &#123; userStore.avatarUrl = downloadURL &#125;) &#125; )&#125; ‍ 界面数据交互界面效果 ​ ‍ 在pages下新增一个Profile.jsx​页面。 这里的流程大概说下，代码很简单。 进入页面通过useEffect，获取用户信息，如果没有用户信息，就是空白。如果有用户信息，就将用户信息填入表单项，头像加载到图片。 如果上传了头像，会从store中拿到上传的图片地址avatarUrl，显示在头像图片处。如果修改了用户名或昵称，点击保存，就会将这些数据保存到Firestore的users集合下的当前用户邮箱文档中的对应字段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// src/pages/Profile.jsximport React, &#123; useState, useEffect &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; userStore, userAction &#125; from &#x27;@/store/user.store&#x27;import &#123; authStore &#125; from &#x27;@/store/auth.store&#x27;const Profile = () =&gt; &#123; const userSnap = useSnapshot(userStore) const authSnap = useSnapshot(authStore) const [file, setFile] = useState(&#x27;&#x27;) const [pro, setPro] = useState(&#123; username: &#x27;&#x27;, nickname: &#x27;&#x27; &#125;) useEffect(() =&gt; &#123; file &amp;&amp; userAction.uploadAvatar(file) &#125;, [file]) const loadProfile = () =&gt; &#123; userAction.getUserProfile(authSnap.user.email) &#125; useEffect(() =&gt; &#123; loadProfile() setPro(&#123; username: userSnap.username, nickname: userSnap.nickname &#125;) &#125;, [userSnap]) const handleUpdateProfile = async () =&gt; &#123; const profile = &#123; username: pro.username, nickname: pro.nickname, avatarImage: userSnap.avatarUrl &#125; userAction.updateUserProfile(authSnap.user.email, profile) console.log(&#x27;update profile success~&#x27;) &#125; return ( &lt;div className=&#x27;w-full h-full bg-gray-100&#x27;&gt; &lt;div className=&#x27;flex flex-col mx-auto py-5 max-w-5xl h-full&#x27;&gt; &lt;div className=&#x27;w-full h-10&#x27;&gt;用户资料&lt;/div&gt; &lt;div className=&#x27;p-5 bg-white rounded-md flex justify-between items-start&#x27;&gt; &lt;div className=&#x27;w-4/12 flex flex-col justify-center items-start&#x27;&gt; &lt;div className=&#x27;avatar w-full flex justify-center&#x27;&gt; &lt;div className=&#x27;w-16 rounded-full&#x27;&gt; &lt;img src=&#123; userSnap.avatarUrl || (file ? URL.createObjectURL(file) : &#x27;./src/assets/avatar.jpg&#x27;) &#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;w-full flex justify-center mt-4&#x27;&gt; &lt;label htmlFor=&#x27;file&#x27; className=&#x27;btn btn-sm btn-outline font-normal text-sm rounded-md&#x27; &gt; 上传头像 &lt;/label&gt; &lt;input type=&#x27;file&#x27; id=&#x27;file&#x27; onChange=&#123;e =&gt; setFile(e.target.files[0])&#125; className=&#x27;hidden&#x27; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;flex-1 flex flex-col&#x27;&gt; &lt;div className=&#x27;w-full flex justify-start items-center mb-4&#x27;&gt; &lt;label htmlFor=&#x27;username&#x27; className=&#x27;text-sm text-gray-500 w-14&#x27;&gt; 用户名 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27; className=&#x27;input input-bordered input-sm w-full max-w-xs&#x27; value=&#123;pro.username&#125; onChange=&#123;e =&gt; setPro(&#123; ...pro, username: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;w-full flex justify-start items-center mb-4&#x27;&gt; &lt;label htmlFor=&#x27;username&#x27; className=&#x27;text-sm text-gray-500 w-14&#x27;&gt; 昵称 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;nickname&#x27; className=&#x27;input input-bordered input-sm w-full max-w-xs&#x27; value=&#123;pro.nickname&#125; onChange=&#123;e =&gt; setPro(&#123; ...pro, nickname: e.target.value &#125;)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;w-full flex justify-start items-center&#x27;&gt; &lt;div className=&#x27;w-14&#x27;&gt;&lt;/div&gt; &lt;button className=&#x27;btn btn-sm rounded-md font-normal text-sm&#x27; // disabled=&#123;userSnap.progress !== null &amp;&amp; userSnap.progress &lt; 100&#125; onClick=&#123;handleUpdateProfile&#125; &gt; 保存 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Profile ‍ 好了，升级版就此也完成了，此处其实还有鉴权部分的内容，我们这里略过。 Firebase是一个可以帮前端解决数据、权限等方面的好工具，但是也很麻烦，文档难读，需要✈️。 当我花了差不多一周的时间学完这个，花了两天整理完学习笔记，然后看到了一个叫Supabase的家伙，靠~ 从界面到文档感觉都比Firebase更好。相比supabase还是个开源的。当然官方也有托管，免费版提供的内容比Firebase略差点，毕竟谷歌家大业大。接下来开始学习Supabase吧~","permalink":"http://example.com/2022/11/10/Firebase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BAuth%E5%92%8Cstorage/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"firebase","slug":"firebase","permalink":"http://example.com/tags/firebase/"}],"title":"Firebase学习笔记之Firestore","date":"2022/11/10","text":"Firebase是Google的一个线上数据服务，提供在线的数据库和权限、资源存储等。这次一起来学习一下。 教程可以参考 The Net Ninja 大神的Firebase 9 Tutorial 因为Firebase的内容太多，我们分了两个部分。这个部分是数据的CURD。 ‍ 添加Firebase项目因为是个在线的服务，所以现需要去谷歌Firebase官网去添加项目。以下为添加项目步骤： 进入官网https://firebase.google.com。 登录后，在首页点击开始使用或者右上角的控制台，进入控制面板页面。 在控制面板点击添加项目。 然后创建项目名称，点击确定。 然后会提示是否需要添加谷歌分析，选择关闭，点击创建项目。 项目创建完成后，点击继续按钮，进入项目控制面板。 选择项目的类型，我们使用的是web应用。 ​ 点击网页应用后，开始注册应用，填写网页应用名称。 点击注册应用按钮。会生成项目的SDK。 ​ 按照要求，在项目中安装Firebase的包，复制配置内容到项目，并且开始使用它提供的config内容。 点击继续前往控制台按钮，在网页应用项目的首页，可以看到这个项目中的应用。点击按钮，可以查看这个网页应用项目中的所有应用，点击我们刚创建的项目后的图标。可以进入项目的配置管理。 在项目设置页面中，常规选项卡下，我们可以看到之前系统生成到SDK。至此项目添加完毕。 ‍ 项目中配置Firebase 安装Firebase的包。 1pnpm add firebase 在项目根目录下添加一个firebase-config.js的配置文件。为了个更好的保护config中的内容，不会被滥用，我们将config的内容添加到.env文件中。然后再添加过来。 vite的导入和webpack的.env配置方式不一样。 vite的添加到.env文件中需要使用VITE_开头，在项目中使用import.meta.env.VITE_​引用。 webpack的添加到.env文件中需要使用REACT_APP_开头，在项目使用process.env.REACT_APP_引用。 123456789101112131415// firebase-config.jsimport &#123; initializeApp &#125; from &#x27;firebase/app&#x27;const firebaseConfig = &#123; apiKey: import.meta.env.VITE_APP_KEY, authDomain: import.meta.env.VITE_AUTH_DOMAIN, projectId: import.meta.env.VITE_PROJECT_ID, storageBucket: import.meta.env.VITE_STORAGE_BUCKET, messagingSenderId: import.meta.env.VITE_MESSAGING_SENDER_ID, appId: import.meta.env.VITE_APP_ID&#125;// 初始化Firebaseconst app = initializeApp(firebaseConfig) ‍ 连接Firestore在firebase-config.js文件中导入getFiresotre。 123456789101112131415161718// firebase-config.jsimport &#123; initializeApp &#125; from &#x27;firebase/app&#x27;import &#123; getFirestore &#125; from &#x27;firebase/firestore&#x27;const firebaseConfig = &#123; apiKey: import.meta.env.VITE_APP_KEY, authDomain: import.meta.env.VITE_AUTH_DOMAIN, projectId: import.meta.env.VITE_PROJECT_ID, storageBucket: import.meta.env.VITE_STORAGE_BUCKET, messagingSenderId: import.meta.env.VITE_MESSAGING_SENDER_ID, appId: import.meta.env.VITE_APP_ID&#125;// 初始化Firebaseconst app = initializeApp(firebaseConfig)// 初始化Firestore服务export const db = getFirestore(app) 至此，基础配置我们已经处理完成。下面就开始业务方面的操作。 Firebase的Firestore，其实是Firebase中Cloud Firestore中的业务。我们通过两个阶段来完成一个简单的CURD示例。为了更好的使用我们将与Firestore交互的都放到store中，方便数据的在各个模块间进行调用。 ‍ 基础版如果只需要简单的数据交互，从Firestore中添加、更新、删除、获取所有数据、获取单个数据。我们就不需要使用到store了。 示例为一个书籍列表增删改查，我们先来看下怎么从Firebase中设置数据结构。 ‍ 设置Firestore数据结构创建完下面，我们在项目面板的页面找到Cloud Firestore的板块。点击进入。 ‍ 进入后，我们到了Cloud Firestore的管理页面，但是目前尚无内容，所以点击 创建数据库按钮，就可以开始设置我们需要的数据内容了。另外在左侧的菜单栏中会记录已经使用的模块。 ‍ 点击 创建数据库 后，会弹出创建数据库引导。 选择数据库模式，我们选择以测试数据开始。方便后面数据连接使用。点击下一步。 ‍ 来到数据位置，我们可以选择亚洲的数据服务，随便选择一个即可。然后点击启用，就配置好了数据库。 ​ ‍ 稍等一会，待系统完成数据预配置。就自动进入到数据管理界面。 ​ 这里 点击 开始收集，这里可以理解为 Firestore 是一个数据库的表，但是他这里称为集合。数据库中所有的表的数据，都称为文档。 我们输入 books，点击下一步，就会让我们来创创建集合中的文档。我们直接创建一个文档内容，作为初始数据。 ‍ ‍ 点击 保存 后，就可以在管理界面看到集合及其下级的文档了。这个数据结构很清晰。 以上就是在Firestore创建基本数据结构的流程。下面我开始业务的编码。 ‍ Firestore数据交互我们创建一个services的目录，并添加books.service.js的文件，作为处理Firestore业务的文件。 123456789101112131415161718192021222324252627282930313233343536// src/services/books.service.js// 连接Firestore的数据服务import &#123; db &#125; from &#x27;../../firebase-config&#x27;// Firestore提供的数据方法import &#123; collection, getDocs, getDoc, addDoc, updateDoc, deleteDoc, doc &#125; from &#x27;firebase/firestore&#x27;const bookCollectionRef = collection(db, &#x27;books&#x27;)const booksAction = &#123; // 添加书籍 addBook: async newBook =&gt; &#123; return await addDoc(bookCollectionRef, newBook) &#125;, // 更新书籍 updateBook: async (id, updateBook) =&gt; &#123; const docBook = doc(db, &#x27;books&#x27;, id) return await updateDoc(docBook, updateBook) &#125;, // 删除书籍 deleteBook: async id =&gt; &#123; const docBook = doc(db, &#x27;books&#x27;, id) return await deleteDoc(docBook) &#125;, // 获取所有书籍 getAllBooks: async () =&gt; &#123; return await getDocs(bookCollectionRef) &#125;, // 获取单本书籍 getBook: async id =&gt; &#123; const docBook = doc(db, &#x27;books&#x27;, id) return await getDoc(docBook) &#125;&#125;export default booksAction 我们先来看看Firestore提供的几个数据操作的方法。 **collection()**：获取引用指定路径的集合实例。通过这个方法，可以获取到我们在Firestore中集合的位置。我们将位置指向books。 1const bookCollectionRef = collection(db, &#x27;books&#x27;) **doc()**：获取引用指定路径的文档实例。通过这个方法，可以获取到我们在Firestore中文档的位置。因为文档创建默认使用的是id作为索引，所以最后一个参数为id。后面我们也可以通过setDoc来创建集合中文档的索引。 1const docBook = doc(db, &#x27;books&#x27;, id) **getDocs()**：执行集合所有文档的查询。传入集合的位置，就可以返回所有集合。 参数： query需要查询哪个集合bookCollectionRef。 123getAllBooks: async () =&gt; &#123; return await getDocs(bookCollectionRef)&#125;, **getDoc()**：执行文档的查询。传入文档的索引即可。 参数： reference，需要查询哪个文档docBook。 1234getBook: async id =&gt; &#123; const docBook = doc(db, &#x27;books&#x27;, id) return await getDoc(docBook)&#125; **addDoc()**：使用指定的数据添加新文档，并自动分配文档id。 参数： reference，需要添加到哪个集合bookCollectionRef。 data，添加的文档数据newBook。 123addBook: async newBook =&gt; &#123; return await addDoc(bookCollectionRef, newBook)&#125; **updateDoc()**：更新文档中指定的字段，如果文档不存在将更新失败。 参数： reference，指定需要更新的文档docBook。 data，需要更新的文档字段数据updateBook。 1234updateBook: async (id, updateBook) =&gt; &#123; const docBook = doc(db, &#x27;books&#x27;, id) return await updateDoc(docBook, updateBook)&#125; **deleteDoc()**：删除指定的文档。 参数： reference：需要删除的文档docBook。 1234deleteBook: async id =&gt; &#123; const docBook = doc(db, &#x27;books&#x27;, id) return await deleteDoc(docBook)&#125; ‍ 以上为Firestore的数据操作。接下来一起看下怎么在界面中使用这些数据操作的方法。 界面效果： ​ ‍ 界面数据交互界面分为三个部分，Add、List、index​。 BookList1234567891011121314151617// src/pages/BookList/index.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import List from &#x27;@/pages/List/List&#x27;import Add from &#x27;@/pages/List/Add&#x27;const BookList = () =&gt; &#123; const [id, setId] = useState(&#x27;&#x27;) return ( &lt;div className=&#x27;max-w-5xl mx-auto&#x27;&gt; &lt;Add bookId=&#123;id&#125; /&gt; &lt;List setBookId=&#123;setId&#125; /&gt; &lt;/div&gt; )&#125;export default BookList 因为没有使用store作为数据传递，就只能在Add组件和List组件的公共页面来传递id。通过List组件传递的id，在Add组件中查询修改的文档索引。 ‍ Add因为使用了tailwindcss来写样式所以html模板的结构会有些乱。可以参考界面效果。 这个组件主要实现三个功能： 获取需要添加的数据。 通过从List组件中传递过来的id，来查询对应的文档。并设置到对应的表单项上。 对添加的数据进行保存判断，如果没有获取到传递的id，就是添加新数据，如果有获取到传递过来的id就是更新数据。 注意事项： 需要对传递过来的id进行判断，通过useEffect方法的触发条件来产生副作用，将通过id查询到的文档数据填入到表单中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// src/pages/BookList/Add.jsximport React, &#123; useState, useEffect &#125; from &#x27;react&#x27;import bookAction from &#x27;@/services/books.service&#x27;const Add = props =&gt; &#123; const [title, setTitle] = useState(&#x27;&#x27;) const [author, setAuthor] = useState(&#x27;&#x27;) const [errorMessage, setErrorMessage] = useState(&#x27;&#x27;) const handleSubmit = async () =&gt; &#123; if (title.trim() === &#x27;&#x27; || author.trim() === &#x27;&#x27;) &#123; setErrorMessage(&#x27;请输入书名或作者&#x27;) return &#125; const book = &#123; title, author &#125; if (props.bookId !== undefined &amp;&amp; props.bookId !== &#x27;&#x27;) &#123; await bookAction.updateBook(props.bookId, book) &#125; else &#123; await bookAction.addBook(book) &#125; setTitle(&#x27;&#x27;) setAuthor(&#x27;&#x27;) &#125; const handleGetBook = async () =&gt; &#123; const abook = await bookAction.getBook(props.bookId) console.log(abook.data()) setTitle(abook.data().title) setAuthor(abook.data().author) &#125; useEffect(() =&gt; &#123; if (props.bookId !== undefined &amp;&amp; props.bookId !== &#x27;&#x27;) &#123; console.log(props.bookId) handleGetBook() &#125; &#125;, [props.bookId]) return ( &lt;div className=&#x27;w-full flex justify-between items-center my-10&#x27;&gt; &#123;errorMessage !== &#x27;&#x27; ? ( &lt;div className=&#x27;alert alert-error max-w-xl rounded-md absolute top-10 right-10&#x27;&gt; &lt;div&gt; &lt;span className=&#x27;text-white text-sm&#x27;&gt;&#123;errorMessage&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ) : null&#125; &lt;div className=&#x27;w-full flex justify-start items-center&#x27;&gt; &lt;label htmlFor=&#x27;title&#x27; className=&#x27;w-14 h-10 flex justify-start items-center&#x27;&gt; 书名 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;title&#x27; className=&#x27;input input-bordered w-full max-w-xs input-sm rounded-md&#x27; value=&#123;title&#125; onChange=&#123;e =&gt; setTitle(e.target.value)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;w-full flex justify-start items-center ml-4&#x27;&gt; &lt;label htmlFor=&#x27;author&#x27; className=&#x27;w-14 h-10 flex justify-start items-center&#x27;&gt; 作者 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;author&#x27; className=&#x27;input input-bordered w-full max-w-xs input-sm rounded-md&#x27; value=&#123;author&#125; onChange=&#123;e =&gt; setAuthor(e.target.value)&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;w-full flex justify-start items-center ml-4&#x27;&gt; &lt;button className=&#x27;btn btn-sm rounded-md font-normal&#x27; type=&#x27;submit&#x27; onClick=&#123;handleSubmit&#125;&gt; 保存 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Add ‍ ListList组件主要实现三个功能。 获取Firestore中的数据，并展示。 通过数据的id进行文档的删除。 通过数据的id，传递给Add组件，执行文档的获取，以便进行修改更新该文档的数据。 注意事项： 集合数据的获取，有两种方式，一种是在Firestore数据交互时，获取到数据，通过forEach遍历出来，后面的示例中，将使用这个方式。还有一种是现在的方式，在界面交互时，通过map的方式讲数据遍历出来。 Firestore的数据在获取后，头需要通过data()方法展示出啦。 返回的集合数据，需要注意数据结构，id是放在文档数据之外的。没有和文档数据放在一起。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// src/pages/BookList/List.jsximport React, &#123; useEffect, useState &#125; from &#x27;react&#x27;import booksAction from &#x27;@/services/books.service&#x27;import &#123; doc &#125; from &#x27;firebase/firestore&#x27;const List = props =&gt; &#123; const [books, setBooks] = useState([]) const getBooks = async () =&gt; &#123; const data = await booksAction.getAllBooks() setBooks(data.docs.map(doc =&gt; (&#123; ...doc.data(), id: doc.id &#125;))) &#125; useEffect(() =&gt; &#123; getBooks() &#125;, []) const handleDeleteBook = async id =&gt; &#123; await booksAction.deleteBook(id) getBooks() &#125; return ( &lt;div&gt; &lt;div className=&#x27;border rounded-lg&#x27;&gt; &lt;table className=&#x27;table w-full&#x27;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;books?.map(book =&gt; ( &lt;tr key=&#123;book.id&#125;&gt; &lt;th&gt;&#123;book.id&#125;&lt;/th&gt; &lt;td&gt;&#123;book.title&#125;&lt;/td&gt; &lt;td&gt;&#123;book.author&#125;&lt;/td&gt; &lt;td&gt; &lt;button className=&#x27;btn btn-sm mr-4 font-normal rounded-md&#x27; onClick=&#123;() =&gt; props.setBookId(book.id)&#125; &gt; 修改 &lt;/button&gt; &lt;button className=&#x27;btn btn-error btn-sm text-white font-normal rounded-md&#x27; onClick=&#123;() =&gt; handleDeleteBook(book.id)&#125; &gt; 删除 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; ))&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default List ‍ 通过这个简单的示例，可以看到使用Firebase提供的方法，实现CURD还是很简单的。 但我们也可以发现几个问题： 列表的数据没有按添加顺序排序，默认是通过id​进行排序的，但是他的id并不是顺序数字，只是一个唯一的字符串，不存在排序顺序条件。 数据更新以后需要刷新才能看到更新的数据。当然也可以通过调用查询方法再更新后再查一次。但修改、删除也都需要调用此方法，很麻烦。Firestore​有更好的方法。 ‍ 升级版升级版，我们将通过onSnapshop、query、where、orderBy、serverTimestamp​方法来实现自动更新列表，按添加时间进行排序，按作者查询书籍的功能。 ‍ 界面效果： ​ ‍ Firestore数据交互升级版中我们使用valtio这个简单的状态库作为store。所以我们在src下新建一个store的目录，下面添加books.store.js文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// src/store/books.store.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;import &#123; db &#125; from &#x27;firebaseConfig&#x27;import &#123; collection, getDoc, addDoc, updateDoc, deleteDoc, doc, onSnapshot, query, where, orderBy, serverTimestamp&#125; from &#x27;firebase/firestore&#x27;export const bookStore = proxy(&#123; books: [], // 所有书籍 bookId: &#x27;&#x27; // 需要查询的单本数据id&#125;)const docRef = collection(db, &#x27;books&#x27;)export const bookAction = &#123; getBooks: async keyword =&gt; &#123; if (keyword === &#x27;&#x27; || keyword === undefined) &#123; const q = query(docRef, orderBy(&#x27;createAt&#x27;, &#x27;desc&#x27;)) await onSnapshot( q, snapshot =&gt; &#123; let books = [] snapshot.docs.forEach(book =&gt; &#123; books.push(&#123; id: book.id, ...book.data() &#125;) &#125;) bookStore.books = books &#125;, error =&gt; &#123; console.log(error.message) &#125; ) &#125; else &#123; const q = query(docRef, where(&#x27;author&#x27;, &#x27;==&#x27;, keyword), orderBy(&#x27;createAt&#x27;, &#x27;desc&#x27;)) await onSnapshot( q, snapshot =&gt; &#123; let books = [] snapshot.docs.forEach(book =&gt; &#123; books.push(&#123; id: book.id, ...book.data() &#125;) &#125;) bookStore.books = books &#125;, error =&gt; &#123; console.log(error.message) &#125; ) &#125; &#125;, getBook: id =&gt; &#123; const bookRef = doc(db, &#x27;books&#x27;, id) return getDoc(bookRef) &#125;, updateBook: (id, book) =&gt; &#123; const bookRef = doc(db, &#x27;books&#x27;, id) return updateDoc(bookRef, book) &#125;, deleteBook: id =&gt; &#123; const bookRef = doc(db, &#x27;books&#x27;, id) return deleteDoc(bookRef) &#125;, addBook: book =&gt; &#123; return addDoc(docRef, &#123; ...book, createAt: serverTimestamp() &#125;) &#125;, setBookId: id =&gt; &#123; bookStore.bookId = id &#125;&#125; 这里我们单独看下新增的几个方法。 **query()**：创建一个不可变的查询实例。就是一个查询方法，两个参数，一个查询的集合是什么，使用collection，一个是查询的范围，可以使用where、orderBy等。query可以与onSnapshop搭配使用。 参数： query，查询的集合docRef。 queryConstraint，查询的约束条件where和orderBy​。 1const q = query(docRef, where(&#x27;author&#x27;, &#x27;==&#x27;, keyword), orderBy(&#x27;createAt&#x27;, &#x27;desc&#x27;)) **where()**：创建一个查询约束，强制文档必须包含指定的字段，并且该值应满足所有约束。说人话，配合query使用的查询条件。 参数： fieldPath，查询的字段。 opStr，查询运算符，包括：&lt;、&lt;=、==、&gt;、&gt;=、!=、array-contains、array-contains-any、in、not-in。具体需要去看下Firestore的文档，这里不展开说明。 value，值，满足条件（约束）的值。 说明： where(&#39;author&#39;, &#39;==&#39;, keyword)从这个示例就可以理解为，当author这个字段满足等于==传入的keyword​的这个参数时，约束就得以满足。 ‍ **orderBy()**：创建一个查询约束，该约束指定字段对查询结果进行排序，可以选择按降序desc或升序asc。 参数： fieldPath，排序的字段。 directionStr，排序的方向，默认为升序。 说明： orderBy(&#39;createAt&#39;, &#39;desc&#39;)可以理解为，按创建时间降序排序。 ‍ **onSnapshot()**：附加事件侦听器，简单来说就是对事件进行订阅，当侦听的对象事件变化时，就提供对应的回调。示例中我们对获取数据进行侦听，当获取的数据增加、被删除、被查询他都返回对应的回调。 参数： query，就是上面我们说的查询约束。 options，可以传递给onSnapshot()的选项对象，要控制在结果中包含哪些类型的更改。这个我们基本没用，官方也没有具体的解释说明。 observer，观察对象的回调，包括： 12345export declare function onSnapshot&lt;T&gt;(query: Query&lt;T&gt;, options: SnapshotListenOptions, observer: &#123; next?: (snapshot: QuerySnapshot&lt;T&gt;) =&gt; void; error?: (error: FirestoreError) =&gt; void; complete?: () =&gt; void;&#125;): Unsubscribe; 可以通过调用调用时返回的函数来取消侦听器。 ‍ 我们来一起看下较之前基础版变化比较大的这个获取书籍的方法。 这个方法，通过传入的keyword来进行判断，如果没有关键字，则直接按查询条件query(docRef, orderBy(&#39;createAt&#39;, &#39;desc&#39;))按创建时间降序排序，从books中进行数据查询，获取所有结果。 如果有关键字，就按查询条件query(docRef, where(&#39;author&#39;, &#39;==&#39;, keyword), orderBy(&#39;createAt&#39;, &#39;desc&#39;))，找到符合关键字keyword的author字段中匹配的内容。然后按创建时间倒序排序，从books集合中查询出所有结果。 这里使用了forEach方法，在获取到侦听的查询结果只有，就将数据放到一个数组中传递给store中的books值。通过获取store中的books值就可以拿到所有书籍。 另外这里有个坑，一定要在有排序的查询中，返回一个错误消息，因为首次查询Firestore会通过错误返回一个排序的地址，需要让你点击过去，在Firestore中进行排序索引，如果没有这个错误消息，就会一直报错提示。建立字段索引后，就可以按照索引进行排序。 12345678910111213141516171819202122232425262728293031323334const docRef = collection(db, &#x27;books&#x27;)getBooks: async keyword =&gt; &#123; if (keyword === &#x27;&#x27; || keyword === undefined) &#123; const q = query(docRef, orderBy(&#x27;createAt&#x27;, &#x27;desc&#x27;)) await onSnapshot( q, snapshot =&gt; &#123; let books = [] snapshot.docs.forEach(book =&gt; &#123; books.push(&#123; id: book.id, ...book.data() &#125;) &#125;) bookStore.books = books &#125;, error =&gt; &#123; console.log(error.message) &#125; ) &#125; else &#123; const q = query(docRef, where(&#x27;author&#x27;, &#x27;==&#x27;, keyword), orderBy(&#x27;createAt&#x27;, &#x27;desc&#x27;)) await onSnapshot( q, snapshot =&gt; &#123; let books = [] snapshot.docs.forEach(book =&gt; &#123; books.push(&#123; id: book.id, ...book.data() &#125;) &#125;) bookStore.books = books &#125;, error =&gt; &#123; console.log(error.message) &#125; ) &#125;&#125; 以上与Firestore的数据交互基本完成，我们来一起看下界面数据交互。 ‍ 界面数据交互界面这里因为多了查询，所以在原来的基础上增加了一个Search.jsx查询组件。 ‍ RealTimeList这里可以看到界面更加简洁，没有了基础版的id传递。因为我们用store传递数据。 123456789101112131415161718// src/pages/RealTimeList/index.jsximport React from &#x27;react&#x27;import AddBook from &#x27;./Add&#x27;import List from &#x27;./List&#x27;import Search from &#x27;./Search&#x27;const BookList = () =&gt; &#123; return ( &lt;div className=&#x27;max-w-5xl mx-auto&#x27;&gt; &lt;AddBook /&gt; &lt;Search /&gt; &lt;List /&gt; &lt;/div&gt; )&#125;export default BookList ‍ Add这里有几个改变 使用useRef来获取title和author的内容，比useState简单很多。 另外并不需要通过父组件传递id，直接从store中获取，列表中需要查询的id，并赋值给表单项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// src/pages/RealTimeList/Add.jsximport React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; bookStore, bookAction &#125; from &#x27;@/store/books.store&#x27;const Add = () =&gt; &#123; const snap = useSnapshot(bookStore) const titleRef = useRef() const authorRef = useRef() const handleSubmit = async () =&gt; &#123; const title = titleRef.current.value const author = authorRef.current.value const book = &#123; title, author &#125; if (snap.bookId !== undefined &amp;&amp; snap.bookId !== &#x27;&#x27;) &#123; await bookAction.updateBook(snap.bookId, book) &#125; else &#123; await bookAction.addBook(book) &#125; titleRef.current.value = &#x27;&#x27; authorRef.current.value = &#x27;&#x27; console.log(&#x27;add book success&#x27;) &#125; const handleGetBook = async () =&gt; &#123; const book = await bookAction.getBook(snap.bookId) titleRef.current.value = book.data().title authorRef.current.value = book.data().author &#125; useEffect(() =&gt; &#123; if (snap.bookId !== undefined &amp;&amp; snap.bookId !== &#x27;&#x27;) &#123; handleGetBook(snap.bookId) &#125; &#125;, [snap.bookId]) return ( &lt;div className=&#x27;w-full grid grid-cols-3 gap-4 my-10 pb-10 border-b&#x27;&gt; &lt;div className=&#x27;flex justify-start items-center&#x27;&gt; &lt;label htmlFor=&#x27;title&#x27; className=&#x27;flex justify-start items-center mr-5&#x27;&gt; 书名 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;title&#x27; className=&#x27;flex-1 input input-bordered w-full max-w-xs input-sm rounded-md&#x27; ref=&#123;titleRef&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center mr-5&#x27;&gt; &lt;label htmlFor=&#x27;author&#x27; className=&#x27;h-10 flex justify-start items-center mr-5&#x27;&gt; 作者 &lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;author&#x27; className=&#x27;flex-1 input input-bordered w-full max-w-xs input-sm rounded-md&#x27; ref=&#123;authorRef&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;flex justify-start items-center&#x27;&gt; &lt;button className=&#x27;btn btn-sm rounded-md font-normal&#x27; type=&#x27;submit&#x27; onClick=&#123;handleSubmit&#125;&gt; 保存 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default Add ‍ Search这个是升级版新增的组件，功能也很简单，就是获取到搜索中的keyword内容传给store。列表在根据传入的keyword，响应相应的查询内容。 123456789101112131415161718192021222324252627282930313233// src/pages/RealTimeList/Search.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; bookAction, bookStore &#125; from &#x27;@/store/books.store&#x27;const Search = () =&gt; &#123; const snap = useSnapshot(bookStore) const [keyword, setKeyword] = useState(&#x27;&#x27;) const handleSearch = () =&gt; &#123; bookAction.getBooks(keyword) &#125; return ( &lt;&gt; &lt;div className=&#x27;form-control my-5 pb-5 border-b&#x27;&gt; &lt;div className=&#x27;input-group&#x27;&gt; &lt;input type=&#x27;text&#x27; placeholder=&#x27;Search…&#x27; className=&#x27;input input-bordered input-sm&#x27; value=&#123;keyword&#125; onChange=&#123;e =&gt; setKeyword(e.target.value)&#125; /&gt; &lt;button className=&#x27;btn btn-square btn-sm text-sm font-normal w-16&#x27; onClick=&#123;handleSearch&#125;&gt; 搜索 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/&gt; )&#125;export default Search ‍ List这里的数据获取变成了从store中获取，其他的都没变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// src/pages/RealTimeList/List.jsximport React, &#123; useEffect, useState &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; bookStore, bookAction &#125; from &#x27;@/store/books.store&#x27;const List = () =&gt; &#123; const snap = useSnapshot(bookStore) useEffect(() =&gt; &#123; bookAction.getBooks() &#125;, []) const handleDeleteBook = async id =&gt; &#123; await bookAction.deleteBook(id) console.log(&#x27;delete book success&#x27;) &#125; return ( &lt;div className=&#x27;overflow-x-auto border rounded-lg&#x27;&gt; &lt;table className=&#x27;table table-compact w-full&#x27;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;snap.books?.map(book =&gt; ( &lt;tr key=&#123;book.id&#125;&gt; &lt;td&gt;&#123;book.id&#125;&lt;/td&gt; &lt;td&gt;&#123;book.title&#125;&lt;/td&gt; &lt;td&gt;&#123;book.author&#125;&lt;/td&gt; &lt;td&gt; &lt;button className=&#x27;btn btn-sm mr-4 font-normal rounded-md&#x27; onClick=&#123;() =&gt; bookAction.setBookId(book.id)&#125; &gt; 修改 &lt;/button&gt; &lt;button className=&#x27;btn btn-error btn-sm text-white font-normal rounded-md&#x27; onClick=&#123;() =&gt; handleDeleteBook(book.id)&#125; &gt; 删除 &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; ))&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; )&#125;export default List ‍ 至此就基本完成了本次Firebase中Firestore的基础学习。官方的文档非常难以阅读。","permalink":"http://example.com/2022/11/10/Firebase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BFirestore/","photos":[]},{"tags":[{"name":"api","slug":"api","permalink":"http://example.com/tags/api/"}],"title":"网易云音乐常用API","date":"2022/11/03","text":"经常会拿网易云音乐的API做些测试，每次找接口都要找半天，索性自己整理下经常会用到的，方便以后使用。都是大神们的接口，仅做分类整理。 baseURL1https://netease-cloud-music-api-one-peach.vercel.app 发现DiscoverBanner说明 : 调用此接口 , 可获取 banner( 轮播图 ) 数据 可选参数 : type:资源类型,对应以下类型,默认为 0 即 PC 12340: pc1: android2: iphone3: ipad 接口地址 : /banner 调用例子 : /banner, /banner?type=2 ‍ 推荐歌单说明 : 调用此接口 , 可获取推荐歌单 可选参数 : limit: 取出数量 , 默认为 30 (不支持 offset) 接口地址 : /personalized 调用例子 : /personalized?limit=1 ‍ 推荐音乐说明 : 调用此接口 , 可获取推荐新音乐 可选参数 : limit: 取出数量 , 默认为 10 (不支持 offset) 接口地址 : /personalized/newsong 调用例子 : /personalized/newsong ‍ 独家发送说明 : 调用此接口 , 可获取独家放送 接口地址 : /personalized/privatecontent 调用例子 : /personalized/privatecontent ‍ 独家放送列表说明 : 调用此接口 , 可获取独家放送列表 可选参数 : limit : 返回数量 , 默认为 60 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*60, 其中 60 为 limit 的值 , 默认为 0 接口地址 : /personalized/privatecontent/list 调用例子 : /personalized/privatecontent/list?limit=1&amp;offset=2 ‍ 最新专辑说明 : 调用此接口 ，获取云音乐首页新碟上架数据 接口地址 : /album/newest 调用例子 : /album/newest ‍ 热门歌手说明 : 调用此接口 , 可获取热门歌手数据 可选参数 : limit: 取出数量 , 默认为 50 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*50, 其中 50 为 limit 的值 , 默认 为 0 接口地址 : /top/artists 调用例子 : /top/artists?offset=0&amp;limit=30 ‍ 推荐MV说明 : 调用此接口 , 可获取推荐 mv 接口地址 : /personalized/mv 调用例子 : /personalized/mv ‍ 推荐电台说明 : 调用此接口 , 可获取推荐电台 接口地址 : /personalized/djprogram 调用例子 : /personalized/djprogram ‍ 推荐节目说明 : 调用此接口 , 可获取推荐电台 接口地址 : /program/recommend 调用例子 : /program/recommend ‍ 所有榜单说明 : 调用此接口,可获取所有榜单 接口地址 : /toplist 调用例子 : /toplist ‍ 每日推荐歌单（需登录）说明 : 调用此接口 , 可获得每日推荐歌单 ( 需要登录 ) 接口地址 : /recommend/resource 调用例子 : /recommend/resource ‍ 每日推荐歌曲（需登录）说明 : 调用此接口 , 可获得每日推荐歌曲 ( 需要登录 ) 接口地址 : /recommend/songs 调用例子 : /recommend/songs ‍ 私人FM（需登录）说明 : 私人 FM( 需要登录 ) 接口地址 : /personal_fm 调用例子 : /personal_fm ‍ ‍ 歌单歌单分类说明 : 调用此接口,可获取歌单分类,包含 category 信息 接口地址 : /playlist/catlist 调用例子 : /playlist/catlist ‍ 热门歌单分类说明 : 调用此接口,可获取歌单分类,包含 category 信息 接口地址 : /playlist/hot 调用例子 : /playlist/hot ‍ 歌单说明 : 调用此接口 , 可获取网友精选碟歌单 可选参数 : order: 可选值为 ‘new’ 和 ‘hot’, 分别对应最新和最热 , 默认为 ‘hot’ cat: tag, 比如 “ 华语 “、” 古风 “ 、” 欧美 “、” 流行 “, 默认为 “全部”,可从歌单分类接口获取(&#x2F;playlist&#x2F;catlist) limit: 取出歌单数量 , 默认为 50 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*50, 其中 50 为 limit 的值 接口地址 : /top/playlist 调用例子 : /top/playlist?limit=10&amp;order=new ‍ 精品歌单标签列表说明 : 调用此接口 , 可获取精品歌单标签列表 接口地址 : /playlist/highquality/tags 调用例子 : /playlist/highquality/tags ‍ 精品歌单说明 : 调用此接口 , 可获取精品歌单 可选参数 : cat: tag, 比如 “ 华语 “、” 古风 “ 、” 欧美 “、” 流行 “, 默认为 “全部”,可从精品歌单标签列表接口获取(/playlist/highquality/tags) limit: 取出歌单数量 , 默认为 50 before: 分页参数,取上一页最后一个歌单的 updateTime 获取下一页数据 接口地址 : /top/playlist/highquality 调用例子 : /top/playlist/highquality?before=1503639064232&amp;limit=3 ‍ 歌单详情说明 : 歌单能看到歌单名字, 但看不到具体歌单内容 , 调用此接口 , 传入歌单 id, 可 以获取对应歌单内的所有的音乐(未登录状态只能获取不完整的歌单,登录后是完整的)，但是返回的 trackIds 是完整的，tracks 则是不完整的，可拿全部 trackIds 请求一次 song/detail 接口获取所有歌曲的详情 (https://github.com/Binaryify/NeteaseCloudMusicApi/issues/452) 必选参数 : id : 歌单 id 可选参数 : s : 歌单最近的 s 个收藏者,默认为 8 接口地址 : /playlist/detail 调用例子 : /playlist/detail?id=24381616 ‍ 歌单详情动态说明 : 调用后可获取歌单详情动态部分,如评论数,是否收藏,播放数 必选参数 : id : 歌单 id 接口地址 : /playlist/detail/dynamic 调用例子 : /playlist/detail/dynamic?id=24381616 ‍ 歌单所有歌曲说明 : 由于网易云接口限制，歌单详情只会提供 10 首歌，通过调用此接口，传入对应的歌单id，即可获得对应的所有歌曲 必选参数 : id : 歌单 id 可选参数 : limit : 限制获取歌曲的数量，默认值为当前歌单的歌曲数量 可选参数 : offset : 默认值为0 接口地址 : /playlist/track/all 调用例子 : /playlist/track/all?id=24381616&amp;limit=10&amp;offset=1 注：关于offset，你可以这样理解，假设你当前的歌单有100首歌 你传入limit&#x3D;10&amp;offset&#x3D;0等价于limit&#x3D;10，你会得到第1-10首歌曲 你传入limit&#x3D;10&amp;offset&#x3D;1，你会得到第2-11首歌曲 如果你设置limit&#x3D;10&amp;offset&#x3D;2，你就会得到第3-12首歌曲 ‍ 获取音乐URL说明 : 使用歌单详情接口后 , 能得到的音乐的 id, 但不能得到的音乐 url, 调用此接口, 传入的音乐 id( 可多个 , 用逗号隔开 ), 可以获取对应的音乐的 url,未登录状态或者非会员返回试听片段(返回字段包含被截取的正常歌曲的开始时间和结束时间) 注 : 部分用户反馈获取的 url 会 403,hwaphon找到的解决方案是当获取到音乐的 id 后，将 https://music.163.com/song/media/outer/url?id=id.mp3 以 src 赋予 Audio 即可播放 必选参数 : id : 音乐 id 可选参数 : br: 码率,默认设置了 999000 即最大码率,如果要 320k 则可设置为 320000,其他类推 接口地址 : /song/url 调用例子 : /song/url?id=33894312 /song/url?id=405998841,33894312 ‍ 获取音乐URL 新版说明 : 使用注意事项同上 必选参数 : id : 音乐 id level: 播放音质等级, 分为 standard &#x3D;&gt; 标准,higher &#x3D;&gt; 较高, exhigh&#x3D;&gt;极高, lossless&#x3D;&gt;无损, hires&#x3D;&gt;Hi-Res 接口地址 : /song/url/v1 调用例子 : /song/url/v1?id=33894312&amp;level=exhigh /song/url/v1?id=405998841,33894312&amp;level=lossless ‍ 音乐是否可用说明: 调用此接口,传入歌曲 id, 可获取音乐是否可用,返回 &#123; success: true, message: &#39;ok&#39; &#125; 或者 &#123; success: false, message: &#39;亲爱的,暂无版权&#39; &#125; 必选参数 : id : 歌曲 id 可选参数 : br: 码率,默认设置了 999000 即最大码率,如果要 320k 则可设置为 320000,其他类推 接口地址 : /check/music 调用例子 : /check/music?id=33894312 ‍ 歌单更新播放量说明 : 调用后可更新歌单播放量 必选参数 : id : 歌单 id 接口地址 : /playlist/update/playcount 调用例子 : /playlist/update/playcount?id=24381616 ‍ 歌手歌手分类说明 : 调用此接口,可获取歌手分类列表 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 : 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 initial: 按首字母索引查找参数,如 /artist/list?type=1&amp;area=96&amp;initial=b 返回内容将以 name 字段开头为 b 或者拼音开头为 b 为顺序排列, 热门传-1,#传 0 type 取值: 1234-1:全部1:男歌手2:女歌手3:乐队 area 取值: 123456-1:全部7华语96欧美8:日本16韩国0:其他 接口地址 : /artist/list 调用例子 : /artist/list?type=1&amp;area=96&amp;initial=b /artist/list?type=2&amp;area=2&amp;initial=b ‍ 歌手热门50首歌曲说明 : 调用此接口,可获取歌手热门 50 首歌曲 必选参数 : id : 歌手 id 接口地址 : /artist/top/song 调用例子 : /artist/top/song?id=6452 ‍ 歌手全部歌曲说明 : 调用此接口,可获取歌手全部歌曲 必选参数 : id : 歌手 id 可选参数 : order : hot ,time 按照热门或者时间排序 limit: 取出歌单数量 , 默认为 50 offset: 偏移数量 , 用于分页 , 如 :( 评论页数 -1)*50, 其中 50 为 limit 的值 接口地址 : /artist/songs 调用例子 : /artist/songs?id=6452 ‍ 歌手单曲说明 : 调用此接口 , 传入歌手 id, 可获得歌手部分信息和热门歌曲 必选参数 : id: 歌手 id, 可由搜索接口获得 接口地址 : /artists 调用例子 : /artists?id=6452 ‍ 歌手MV说明 : 调用此接口 , 传入歌手 id, 可获得歌手 mv 信息 , 具体 mv 播放地址可调 用/mv传入此接口获得的 mvid 来拿到 , 如 : /artist/mv?id=6452,/mv?mvid=5461064 必选参数 : id: 歌手 id, 可由搜索接口获得 接口地址 : /artist/mv 调用例子 : /artist/mv?id=6452 ‍ 歌手专辑说明 : 调用此接口 , 传入歌手 id, 可获得歌手专辑内容 必选参数 : id: 歌手 id 可选参数 : limit: 取出数量 , 默认为 30 offset: 偏移数量 , 用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认 为 0 接口地址 : /artist/album 调用例子 : /artist/album?id=6452&amp;limit=5 ( 周杰伦 ) ‍ 歌手描述说明 : 调用此接口 , 传入歌手 id, 可获得歌手描述 必选参数 : id: 歌手 id 接口地址 : /artist/desc 调用例子 : /artist/desc?id=6452 ( 周杰伦 ) ‍ 歌手详情说明 : 调用此接口 , 传入歌手 id, 可获得获取歌手详情 必选参数 : id: 歌手 id 接口地址 : /artist/detail 调用例子 : /artist/detail?id=11972054 (Billie Eilish) ‍ 专辑新碟上架说明 : 调用此接口 , 可获取新碟上架列表 , 如需具体音乐信息需要调用获取专辑列表接 口 /album , 然后传入 id, 如 /album?id=32311 可选参数 : area: ALL:全部,ZH:华语,EA:欧美,KR:韩国,JP:日本 type : new:全部 hot:热门,默认为 new year : 年,默认本年 month : 月,默认本月 接口地址 : /top/album 调用例子 : /top/album?offset=0&amp;limit=30&amp;year=2019&amp;month=6 ‍ 全部新碟说明 : 登录后调用此接口 ,可获取全部新碟 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 area : ALL:全部,ZH:华语,EA:欧美,KR:韩国,JP:日本 接口地址 : /album/new 调用例子 : /album/new?area=KR&amp;limit=10 ‍ ‍ 榜单所有榜单说明 : 调用此接口,可获取所有榜单 接口地址 : /toplist 调用例子 : /toplist ‍ 榜单详情说明: 请使歌单详情接口,传入排行榜 id 获取排行榜详情数据(排行榜也是歌单的一种) ‍ 榜单摘要说明 : 调用此接口,可获取所有榜单内容摘要 接口地址 : /toplist/detail 调用例子 : /toplist/detail ‍ 歌手榜说明 : 调用此接口 , 可获取排行榜中的歌手榜 可选参数 : 12345type : 地区1: 华语2: 欧美3: 韩国4: 日本 接口地址 : /toplist/artist 调用例子 : /toplist/artist ‍ ‍ 搜索搜索说明 : 调用此接口 , 传入搜索关键词可以搜索该音乐 &#x2F; 专辑 &#x2F; 歌手 &#x2F; 歌单 &#x2F; 用户 , 关键词可以多个 , 以空格隔开 , 如 “ 周杰伦 搁浅 “( 不需要登录 ), 可通过 /song/url 接口传入歌曲 id 获取具体的播放链接 必选参数 : keywords : 关键词 可选参数 : limit : 返回数量 , 默认为 30 offset : 偏移数量，用于分页 , 如 : 如 :( 页数 -1)*30, 其中 30 为 limit 的值 , 默认为 0 type: 搜索类型；默认为 1 即单曲 , 取值意义 : 1: 单曲, 10: 专辑, 100: 歌手, 1000: 歌单, 1002: 用户, 1004: MV, 1006: 歌词, 1009: 电台, 1014: 视频, 1018:综合, 2000:声音(搜索声音返回字段格式会不一样) 接口地址 : /search 或者 /cloudsearch(更全) 调用例子 : /search?keywords=海阔天空 /cloudsearch?keywords=海阔天空 ‍ 默认搜索关键词说明 : 调用此接口 , 可获取默认搜索关键词 接口地址 : /search/default ‍ 热搜列表 简略说明 : 调用此接口,可获取热门搜索列表 接口地址 : /search/hot 调用例子 : /search/hot ‍ 热搜列表 详细说明 : 调用此接口,可获取热门搜索列表 接口地址 : /search/hot/detail 调用例子 : /search/hot/detail ‍ 搜索建议说明 : 调用此接口 , 传入搜索关键词可获得搜索建议 , 搜索结果同时包含单曲 , 歌手 , 歌单信息 必选参数 : keywords : 关键词 可选参数 : type : 如果传 ‘mobile’ 则返回移动端数据 接口地址 : /search/suggest 调用例子 : /search/suggest?keywords=海阔天空 /search/suggest?keywords=海阔天空&amp;type=mobile ‍ 搜索多重匹配说明 : 调用此接口 , 传入搜索关键词可获得搜索结果 必选参数 : keywords : 关键词 接口地址 : /search/multimatch 调用例子 : /search/multimatch?keywords=海阔天空","permalink":"http://example.com/2022/11/03/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%B8%B8%E7%94%A8API/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"styled-components","slug":"styled-components","permalink":"http://example.com/tags/styled-components/"}],"title":"Styled-components中使用媒体查询","date":"2022/10/29","text":"styled-components和emotion中作媒体查询很麻烦，不如scss中的mixin来的简单。从emotion上找到一个包facepaint，能在一定程度上优化代码，减少代码量，但也不能像正常写css那样去写样式了，只能用驼峰的方式写成对象形式的样式。我们来分别看下这三种方式的媒体查询： ‍ Scss12345678910111213141516171819202122232425// scss/_breakproint.scss@mixin mobile &#123; @media only screen and (max-width: 575.98px) &#123; @content; &#125;&#125;@mixin tablet &#123; @media only screen and (max-width: 991.98px) &#123; @content; &#125;&#125;// app.scss@use &quot;./scss/&quot; as *;body &#123; @include tablet &#123; font-size: 80%; &#125; @include mobile &#123; font-size: 60%; &#125;&#125; ‍ Styled-components123456789101112131415161718192021222324// styles/variable.jsconst breakpoints = [576, 992]const mq = breakpoints.map(bp =&gt; `@media (min-width: $&#123;bp&#125;px)`)export default &#123; mq &#125;// app.jsimport styled from &#x27;styled-components&#x27;import v from &#x27;@/styles/variable&#x27;const AppWrap = styled.div` width: 100vw; height: 100vh; $&#123;&#123; [v.mq[0]]: &#123; fontSize: &#x27;40px&#x27; &#125;, [v.mq[1]]: &#123; fontSize: &#x27;60px&#x27; &#125; &#125;&#125;` ‍ Facepaint首先需要安装下包 1pnpm add facepaint 使用 1234567891011121314151617181920// src/styles/variable.jsimport facepaint from &#x27;facepaint&#x27;const mediaQuery = facepaint([ &#x27;@media(max-width: 991.98px)&#x27;, &#x27;@media(max-width: 575.98px)&#x27;])// app.jsimport styled from &#x27;styled-components&#x27;import v from &#x27;@/styles/variable&#x27;const AppWrap = styled.div` width: 100vw; height: 100vh; $&#123;v.mediaQuery(&#123; backgroundColor: [&#x27;#fff&#x27;, &#x27;#ccc&#x27;, &#x27;#000&#x27;] &#125;)&#125;;`","permalink":"http://example.com/2022/10/29/Styled-components%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"auth0","slug":"auth0","permalink":"http://example.com/tags/auth0/"}],"title":"Auth0身份验证","date":"2022/10/27","text":"Auth0是一个第三方身份验证的工具。通过配置可以调用Auth0的注册、登录，配置指定回调地址就可以很快实现身份验证的功能。 ‍ 注册、设置Auth0 基础部分很简单，首先到Auth0注册一个账号，直接用Github或者Google的账号就可以直接登录。 然后在进入到Dashboard以后在左侧栏找到Application应用模块下的应用列表。 ​ 然后添加应用。添加应用的名字，选择使用的应用类型，根据下面的说明 我们选择第二个单页网页应用。 添加成功后，在应用面板中第二个标签页settings中可以看到Auth0的基础信息，包含域名Domain和客户IDClient ID，这两个是需要在项目中添加登录时配置的。 然后往下，在Application URIs中可以看到应用登录的登录端点、回调链接、注销网址等，我们在这里配置下允许的回调网址Allowed Callback URLs和运行注销网址。因为会用到vite和next端口不一致，可以使用英文逗号进行分割。填写完成保存修改。 然后在上面第四个标签页连接Connections中可以看到可以使用的链接方式，和已经添加的第三方链接信息。这里可以控制连接源。 在左侧的菜单栏中第四个模块认证Authentication中第一个是配置默认登录，一般为使用邮箱登录。第二个是社交Social，可以选择第三方的登录，里面的内容很多可以仔细研究下。 这里添加好第三方社交的连接，需要到应用中开启下，否则默认是关闭的。 ‍ 项目使用安装1pnpm add @auth0/auth0-react 以下以vite项目为例。 ‍ Main安装好后在入口文件中配置Auth0的Provider。但首先我们把之前的Domain和Client ID配置到.env文件中。在入口文件中进行引用。 123456789101112131415// src/main.jsimport React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import App from &#x27;@/App&#x27;import &#123; Auth0Provider &#125; from &#x27;@auth0/auth0-react&#x27;import &#x27;@/index.css&#x27;const domain = import.meta.env.VITE_AUTH0_DOMAINconst clientId = import.meta.env.VITE_AUTH0_CLIENT_IDReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( &lt;Auth0Provider domain=&#123;domain&#125; clientId=&#123;clientId&#125; redirectUri=&#123;window.location.origin&#125;&gt; &lt;App /&gt; &lt;/Auth0Provider&gt; redirectUri：是在Auth0在身份验证通过后将用户重新定向到应用程序的URL。可以在之前配置中找到对应的字段配置值。window.location.origin是默认原来的页面。 ‍ AppAuth0的登录很简单，就是一个登录按钮，点击跳转到他们的登录页面进行登录，成功了就再跳转回来。 先 123456789101112131415161718192021222324// src/App.jsimport &#123; useAuth0 &#125; from &quot;@auth0/auth0-react&quot;;import React from &quot;react&quot;;const App = () =&gt; &#123; const &#123; user, isAuthenticated, isLoading &#125; = useAuth0(); if (isLoading) &#123; return &lt;div&gt;Loading ...&lt;/div&gt;; &#125; return ( isAuthenticated &amp;&amp; ( &lt;div&gt; &lt;LoginButton /&gt; &lt;LogoutButton /&gt; &lt;Profile /&gt; &lt;/div&gt; ) );&#125;;export default App; ‍ Login在登录组件中需要做好验证，如果没验证显示。 1234567891011121314151617// src/components/Login.jsximport React from &#x27;react&#x27;import &#123; useAuth0 &#125; from &#x27;@auth0/auth0-react&#x27;const Login = () =&gt; &#123; const &#123; loginWithRedirect, isAuthenticated &#125; = useAuth0() return ( !isAuthenticated &amp;&amp; ( &lt;button onClick=&#123;() =&gt; loginWithRedirect()&#125;&gt; 登录 &lt;/button&gt; ) )&#125;export default Login ‍ Logout也是在组件中作好验证，如果验证通过显示。 1234567891011121314151617// src/components/Logout.jsximport React from &#x27;react&#x27;import &#123; useAuth0 &#125; from &#x27;@auth0/auth0-react&#x27;const LogoutButton = () =&gt; &#123; const &#123; logout, isAuthenticated &#125; = useAuth0() return ( isAuthenticated &amp;&amp; ( &lt;button onClick=&#123;() =&gt; logout()&#125;&gt; 登出 &lt;/button&gt; ) )&#125;export default LogoutButton ‍ Profile登录后可以通过user获取到用户信息，在Auth0的配置中可以配置拿到什么信息，进行什么操作的关联。 12345678910111213141516171819202122232425// src/components/Profile.jsximport React from &#x27;react&#x27;import &#123; useAuth0 &#125; from &#x27;@auth0/auth0-react&#x27;const Profile = () =&gt; &#123; const &#123; user, isAuthenticated &#125; = useAuth0() return ( isAuthenticated &amp;&amp; ( &lt;article&gt; &lt;div&gt; &lt;div&gt; &lt;img src=&#123;user.picture&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;div&gt;&#123;user.name&#125;&lt;/div&gt; &lt;div&gt;&#123;user.nickname&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; ) )&#125;export default Profile ‍ 总结以上简单几步就完成了身份验证的功能，并且还可以通过Auth0对验证进行很强大的配置。之前有用到Google的验证，麻烦的一批，最后验证还不能用同一个谷歌账号，只好作罢。Auth0也让我看到一个简单的验证可以做的这么简单且强大。","permalink":"http://example.com/2022/10/27/Auth0%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"react-query","slug":"react-query","permalink":"http://example.com/tags/react-query/"}],"title":"React Query学习笔记","date":"2022/10/21","text":"终于二刷了 Codevolution 大佬的这个系列，感觉比第一次确实是有了更多的理解。配合之前的foromik使用杠杠滴~ 教程地址：React Query Tutorial for Beginners ReactQuery 官方地址：ReactQuery 部分中文文档地址：Tanstact Query 中文文档 React Query 是什么？ 是用于在 React 应用中获取数据的库(library) 为什么使用 React Query？ 由于 React 是一个 UI 库，没有特定的数据获取模式。 可以使用useEffect这个钩子函数获取数据，使用useState来维护组件状态，如数据的加载（loading）、错误（error）、结果数据（data）等等。 如果整个应用程序都需要数据状态管理，我们可以使用状态库管理比如Redux、Mobx。 但大多数状态管理库都适用于处理客户端状态，比如主题的开关等。 状态库不适合处理异步或服务器状态，比如 Redux 中的异步处理需要借助第三方的thunk和saga才能处理异步的状态。 而使用 ReactQuery 可以更好的管理异步数据加载的状态、错误、结果数据等。类似的 Redux 为了更好的处理异步数据请求，在除了简化模板代码的 ReduxToolkit 后，又整了个 RTK Query，就是来对标 ReactQuery 的。但还是很多不如 ReactQuery。 ‍ 以下为几个请求状态库的对比。 比较 | React Query vs SWR vs Apollo vs RTK Query vs React Router ‍ 安装&amp;配置ReactQuery 的 v4 以上版本和之前的版本安装有些不一样，我们都按 v4 版本的来。 1pnpm add @tanstack/react-query 安装完成后我们需要对项目进行配置，通过 QueryClientProvider 将查询到的状态通过 Provider 传递给其他页面。 12345678910111213141516171819202122232425// app.jsimport React from &#x27;react&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import &#123; QueryClientProvider, QueryClient &#125; from &#x27;@tanstack/react-query&#x27;import RootRoute from &#x27;@/router&#x27;import RootStyle from &#x27;@/styles/base.style&#x27;import Layout from &#x27;@/components/Layout&#x27;const queryClient = new QueryClient()const App = () =&gt; &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;BrowserRouter&gt; &lt;RootStyle /&gt; &lt;Layout&gt; &lt;RootRoute /&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; &lt;/QueryClientProvider&gt; )&#125;export default App const queryClient = new QueryClient()这里可以设置 ReactQuery 的一些默认配置，我们稍后会提到。 ‍ 获取数据配置完成就可以使用 ReactQuery 了。我们先对比下之前如何获取数据。 之前的做法123456789101112131415161718192021222324252627282930313233// src/pages/SuperHero/index.jsximport React, &#123; useState, useEffect &#125; from &#x27;react&#x27;import axios from &#x27;axios&#x27;const SuperHero = () =&gt; &#123; const [isLoading, setIsLoading] = useState(true) const [data, setData] = useState([]) useEffect(() =&gt; &#123; axios(&#x27;http://localhost:4000/superheros&#x27;).then(res =&gt; &#123; setData(res.data) setIsLoading(false) &#125;) &#125;, []) if (isLoading) &#123; return &lt;div&gt;加载中...&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;SuperHero&lt;/h4&gt; &#123;data?.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default SuperHero ‍ 使用 ReactQuery 的做法1234567891011121314151617181920212223242526// src/pages/RQSuperHero/index.jsximport React from &#x27;react&#x27;import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const RQSuperHero = () =&gt; &#123; const fetcher = () =&gt; axios(&#x27;http://localhost:4000/superheros&#x27;) const &#123; data, isLoading &#125; = useQuery([&#x27;rqsuperhero&#x27;], fetcher) if (isLoading) &#123; return &lt;div&gt;加载中...&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &#123;data?.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default RQSuperHero 肉眼可见的代码减少了，复杂度也低了，ReactQuery 通过 fetcher 这个请求函数就直接返回了数据和加载状态，但是他给的远远不止这些。我们后面会有更多了解。 这里需要注意useQuery后面的括号中最少需要两个参数 第一个是查询键，必须是唯一的。以前的版本只需要一个可以序列化的参数，所以可以使用字符串，但 v4 版本后必须放到数组中。 第二个是请求函数，一般我们可以配置到这个useQuery的方法外面统一管理。 useQuery可以返回给我们获取数据的中间加载状态isLoading和加载之后的数据data ‍ 获取请求时的错误将请求地址写错，达到出错的效果。 ‍ 之前的做法12345678910111213141516171819202122232425262728293031323334353637383940414243// src/pages/SuperHero/index.jsximport React, &#123; useState, useEffect &#125; from &#x27;react&#x27;import axios from &#x27;axios&#x27;const SuperHero = () =&gt; &#123; const [isLoading, setIsLoading] = useState(true) const [error, setError] = useState(&#x27;&#x27;) const [data, setData] = useState([]) useEffect(() =&gt; &#123; axios(&#x27;http://localhost:4000/superheros1&#x27;) .then(res =&gt; &#123; setData(res.data) setIsLoading(false) &#125;) .catch(error =&gt; &#123; setError(error.message) setIsLoading(false) &#125;) &#125;, []) if (isLoading) &#123; return &lt;div&gt;加载中...&lt;/div&gt; &#125; if (error) &#123; return &lt;div&gt;出错了： &#123;error&#125;&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;SuperHero&lt;/h4&gt; &#123;data?.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default SuperHero ‍ ReactQuery 的做法123456789101112131415161718192021222324252627282930// src/pages/RQSuperHero/index.jsximport React from &#x27;react&#x27;import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const RQSuperHero = () =&gt; &#123; const fetcher = () =&gt; axios(&#x27;http://localhost:4000/superheros1&#x27;) const &#123; data, isLoading, isError, error &#125; = useQuery([&#x27;rqsuperhero&#x27;], fetcher) if (isLoading) &#123; return &lt;div&gt;加载中&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &#123;data?.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default RQSuperHero isError是获取数据出错的状态，error可以获取出错后返回地的错误消息message 当发生错误时，ReactQuery 默认还是会去请求三次，如果还是错误才会返回错误消息。 ‍ 开发工具 DevTools安装 1pnpm add @tanstack/react-query-devtools 配置 12345678910111213141516171819202122232425import React from &#x27;react&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import &#123; QueryClientProvider, QueryClient &#125; from &#x27;@tanstack/react-query&#x27;import &#123; ReactQueryDevtools &#125; from &#x27;@tanstack/react-query-devtools&#x27;import RootRoute from &#x27;@/router&#x27;import RootStyle from &#x27;@/styles/base.style&#x27;import Layout from &#x27;@/components/Layout&#x27;const queryClient = new QueryClient()const App = () =&gt; &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;BrowserRouter&gt; &lt;RootStyle /&gt; &lt;ReactQueryDevtools initialIsOpen=&#123;false&#125; position=&#x27;bottom-right&#x27; /&gt; &lt;Layout&gt; &lt;RootRoute /&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; &lt;/QueryClientProvider&gt; )&#125;export default App 参数说明： initialIsOpen：是否开启调试工具，默认是开启，为了不影响我们这里设置关闭。 position：调试工具的显示位置，默认为左下，设置到右下，才是我们比较习惯的地方。 ‍ 点击右下角的图标就可以看到这个开发工具的样子了。 左侧的rqsuperhero就是我们使用ReactQuery的查询键。点击可以看到右侧相关的一些数据情况。 最上面有一排按钮，分别是：新鲜的fresh、正在获取的fetching、暂停的paused、陈旧的stale、闲置的inactive。这几个状态就是ReactQuery对数据请求和响应的状态处理，后面在ReactQuery配置中会提到这些。 ​ ReactQuery DevTools用的不多，仅做介绍。 ‍ 缓存ReactQuery 默认缓存时间为 5 分钟。当 ReactQuery 首次获取到数据后就会通过查询键对数据进行缓存。 当数据没有发生变化时，ReactQuery 每次获取数据会与缓存中的数据对比，如没有变化，则从缓存中返回数据。 如果发生变化则会在后台对变化的数据缓存进行更新。所以已经更新的数据会直接从缓存中获取，并不会显示对应的加载状态。 当数据缓存时间过后，再次查询数据时则会发生数据请求，而不会在缓存中获取数据。我们可以在 useQuery 中配置该次请求的缓存时间。 123const &#123; data, isLoading, isError, error &#125; = useQuery([&#x27;rqsuperhero&#x27;], fetcher, &#123; cacheTime: 5000&#125;) 查询缓存的好处就是减少对不一定经常更新的数据的网络请求数量。 ‍ 陈旧时间如果用户对看到过时的数据也没影响，使用缓存显示查询结果，而不需要在后台重新获取数据。但是对更新频繁的数据，我需要实时获取变化情况，缓存则会影响我们，那么可以设置陈旧时间，让数据可以在一段时间内保持新鲜，但过期后，数据就变成陈旧的数据，需要重新发起请求获取。 123const &#123; data, isLoading, isError, error, isFetching &#125; = useQuery([&#x27;rqsuperhero&#x27;], fetcher, &#123; staleTime: 30000&#125;) 我们可以设置staleTime陈旧时间，30 秒后数据就会变为陈旧数据，如果再查看数据或者有ReactQuery的更新事件触发，则会发起请求更新缓存。ReactQuery​ 有很多事件来触发更新，比如浏览器页面失去焦点后再次获取到焦点，会触发更新等等，后面会介绍到。 如果我们设置staleTime: 0则会每次查看数据或触发更新事件时数据就会更新。 ‍ 获取数据ReactQuery 给了几个触发获取数据的配置，我们来看下。 当挂载时获取数据，refetchOnMount： 设置为 true，如果数据过时，则在加载组件时 获取数据。true 是默认值。 设置为 false，将禁用组件加载获取数据。 设置为 always，则将始终在加载组件时获取数据。 设置为函数，则该函数执行的获取结果得到一个布尔值作为设置的值(query) =&gt; boolean。 当浏览器窗口获取到焦点时获取数据，refetchOnWindowFocus： 设置为 true，如果数据过时，则在浏览器窗口获取到焦点时获取数据，true 是默认值。 设置为 false，则在浏览器窗口获取到焦点时，不会获取数据。 设置为 always，则始终在浏览器窗口获取到焦点时获取数据。 设置为函数，则该函数执行的获取结果得到一个布尔值作为设置的值(query) =&gt; boolean。 在时间间隔内连续获取数据，refetchInterval： 设置为数字，则以毫秒为单位，在该时间范围内连续获取数据。 设置为函数，则该函数的执行结果得到一个数值作为获取数据的时间范围(data, query) =&gt; number | false。 默认值为 false 在后台连续获取数据的时间间隔，refetchIntervalInBackground： 设置为 true，则在浏览器标签页或窗口处于后台时获取数据。 默认值为 false 当重新连接时获取数据，refetchOnReconnect： 设置为 true，如果数据过时，则在重新连接时获取数据。 设置为 false，则不会在重新连接时获取数据。 设置为函数，则该函数执行的获取结果得到一个布尔值作为设置的值(query) =&gt; boolean。 默认值为 networkOnline（true) 12345678const &#123; data, isLoading, isError, error, isFetching &#125; = useQuery([&#x27;rqsuperhero&#x27;], fetcher, &#123; staleTime: 0, refetchOnMount: true, refetchOnWindowFocus: true, refetchInterval: false, refetchIntervalInBackground: false, refetchOnReconnect: true&#125;) ‍ 通过事件的方式获取数据 首先需要将通过挂载组件、浏览器获取焦点等就获取数据的方式禁用，我们可以设置enabled: false将禁止查询行为自动运行。 然后通过从useQuery中解析出来的refetch方法获取数据。 12345678910111213141516171819202122232425262728const &#123; data, isLoading, isError, error, isFetching, refetch &#125; = useQuery( [&#x27;rqsuperhero&#x27;], fetcher, &#123; enabled: false &#125;)if (isLoading || isFetching) &#123; return &lt;div&gt;加载中&lt;/div&gt;&#125;if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt;&#125;return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &lt;button onClick=&#123;refetch&#125;&gt;Fetch Super Hero&lt;/button&gt; &#123;data?.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;/div&gt;) ‍ 成功或失败的回调函数ReactQuery 的第三个参数中可以配置当获取数据成功或失败时的回调函数。有些数据在获取成功后我们需要存到 store 中，就可以使用这个方法。 123456789101112const &#123; data, isLoading, isError, error, isFetching, refetch &#125; = useQuery( [&#x27;rqsuperhero&#x27;], fetcher, &#123; onSuccess: data =&gt; &#123; console.log(&#x27;获取数据成功&#x27;, data) &#125;, onError: error =&gt; &#123; console.log(&#x27;获取数据失败&#x27;, error.message) &#125; &#125;) ‍ 转换或筛选查询数据可以使用select方法对数据进行加工，返回我们需要返回的结果。 比如：在示例中加入了女性超级英雄。我们可以筛选超级英雄的性别，将女超级英雄查询出来。然后只返回女超级英雄的名字。 12345678910111213141516171819const &#123; data, isLoading, isError, error, isFetching, refetch &#125; = useQuery( [&#x27;rqsuperhero&#x27;], fetcher, &#123; select: data =&gt; &#123; const femaleHero = data.data.filter(hero =&gt; hero.gender === &#x27;female&#x27;).map(hero =&gt; hero.name) return femaleHero &#125; &#125;)return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &#123;data?.map((hero, index) =&gt; ( &lt;div key=&#123;hero&#125;&gt;&#123;hero&#125;&lt;/div&gt; ))&#125; &lt;/div&gt;) ‍ 通过参数查询最简单的例子就是查看详情了。 路由加上详情的配置，通过heroId来查询 123456789// src/router/index.jsxconst routes = [ &#123; path: &#x27;/&#x27;, element: &lt;Navigate to=&#x27;/home&#x27; /&gt; &#125;, &#123; path: &#x27;/home&#x27;, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;/sh&#x27;, element: &lt;SuperHero /&gt; &#125;, &#123; path: &#x27;/rqsh&#x27;, element: &lt;RQSuperHero /&gt; &#125;, &#123; path: &#x27;/rqsh/:heroId&#x27;, element: &lt;RQSuperHeroPersonal /&gt; &#125;] 在列表页加上链接 123456789101112131415161718192021222324252627282930313233// src/pages/RQSuperHero/index.jsximport React from &#x27;react&#x27;import &#123; Link &#125; from &#x27;react-router-dom&#x27;import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const RQSuperHero = () =&gt; &#123; const fetcher = () =&gt; axios(&#x27;http://localhost:4000/superheros&#x27;) const &#123; data, isLoading, isError, error, isFetching &#125; = useQuery([&#x27;rqsuperhero&#x27;], fetcher) if (isLoading || isFetching) &#123; return &lt;div&gt;加载中&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &#123;data?.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &lt;Link to=&#123;`/rqsh/$&#123;hero.id&#125;`&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/Link&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default RQSuperHero 在pages目录下添加一个RQSuperHeroPersonal文件。 1234567891011121314151617181920212223242526272829303132// src/pages/RQSuperHeroPersonal/index.jsximport React from &#x27;react&#x27;import &#123; useParams &#125; from &#x27;react-router-dom&#x27;import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const RQSuperHeroPersonal = () =&gt; &#123; const &#123; heroId &#125; = useParams() const fetcher = heroId =&gt; axios(`http://localhost:4000/superheros/$&#123;heroId&#125;`) const &#123; data, isLoading, isError, error &#125; = useQuery([&#x27;rqsuperheropersonal&#x27;, heroId], () =&gt; fetcher(heroId) ) if (isLoading) &#123; return &lt;div&gt;加载中&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;div&gt; &#123;data?.data.id&#125;. &#123;data?.data.name&#125; - &#123;data?.data.alterEgo&#125; - &#123;data?.data.gender&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default RQSuperHeroPersonal 使用参数查询时需要注意，需要将参数放入查询键的数组中。并且，查询函数需要写成箭头函数形式用于传递参数。 ‍ 并行查询如果页面上有多组数据需要并行同时查询，可以使用useQueries来进行查询。 我们在示例的db.json中加入DC Super Hero。这样就有两组超级英雄需要一起来查询。 新建一个RQSuperHeroLeague的页面。配置好路由。 12345678910111213141516171819202122232425262728293031323334353637// src/pages/RQSuperHeroLeague/index.jsximport React from &#x27;react&#x27;import &#123; Link &#125; from &#x27;react-router-dom&#x27;import &#123; useQueries &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const SuperHeroLeague = () =&gt; &#123; const fetchMarvalHero = () =&gt; axios(&#x27;http://localhost:4000/superheros&#x27;) const fetchDcHero = () =&gt; axios(&#x27;http://localhost:4000/dcsuperheros&#x27;) const results = useQueries(&#123; queries: [ &#123; queryKey: [&#x27;marvalsuperhero&#x27;], queryFn: fetchMarvalHero &#125;, &#123; queryKey: [&#x27;dcsuperhero&#x27;], queryFn: fetchDcHero &#125; ] &#125;) return ( &lt;div&gt; &lt;h2&gt;Super Hero League&lt;/h2&gt; &lt;div&gt; &#123;results?.map((league, index) =&gt; ( &lt;ul key=&#123;index&#125;&gt; &#123;league.data?.data.map(hero =&gt; ( &lt;li key=&#123;hero.id&#125;&gt; &#123;hero.id&#125;. &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default SuperHeroLeague 这种并行查询，会把查询的结果放到一个数组中，在获取数据时会同时发起查询，同时返回一个数组，将两组查询结果作为两个对象放到数组中，useQuery的返回结果和回调方法也分别放到对象中了。 这种并行的操作，有点不好取出isLoading等数据状态。 ‍ 从属查询在 API 查询中，经常会有通过一个关联 ID 查询相关的内容。比如：通过一个学生的邮箱，查询学生学习的课程，我们将以此为示例。 先添加用户信息和关联课程信息 1234567891011121314db.json&#123; &quot;users&quot;: [ &#123; &quot;id&quot;: &quot;p1@example.com&quot;, &quot;channelId&quot;: &quot;c1&quot; &#125;, &#123; &quot;id&quot;: &quot;p2@example.com&quot;, &quot;channelId&quot;: &quot;c2&quot; &#125;, &#123; &quot;id&quot;: &quot;p3@example.com&quot;, &quot;channelId&quot;: &quot;c3&quot; &#125; ], &quot;channels&quot;: [ &#123; &quot;id&quot;: &quot;c1&quot;, &quot;courses&quot;: [&quot;Html&quot;, &quot;Css&quot;, &quot;Javascript&quot;] &#125;, &#123; &quot;id&quot;: &quot;c2&quot;, &quot;courses&quot;: [&quot;Node&quot;, &quot;Expess&quot;, &quot;Koa&quot;] &#125;, &#123; &quot;id&quot;: &quot;c3&quot;, &quot;courses&quot;: [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;] &#125; ]&#125; ‍ 然后添加对应的路由，添加页面Users。 1234567891011121314151617181920212223242526272829303132333435363738394041// src/pages/Users/index.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const getUserEmail = email =&gt; axios(`http://localhost:4000/users/$&#123;email&#125;`)const getCourses = channelId =&gt; axios(`http://localhost:4000/channels/$&#123;channelId&#125;`)const Users = () =&gt; &#123; const [email, setEmail] = useState(&#x27;p1@example.com&#x27;) const &#123; data: user &#125; = useQuery([&#x27;user&#x27;, email], () =&gt; getUserEmail(email)) const channelId = user?.data.channelId const &#123; data: courses &#125; = useQuery([&#x27;courses&#x27;, channelId], () =&gt; getCourses(channelId), &#123; enabled: !!channelId &#125;) return ( &lt;div&gt; &lt;div&gt; User:&#123;&#x27; &#x27;&#125; &lt;select value=&#123;email&#125; onChange=&#123;e =&gt; setEmail(e.target.value)&#125;&gt; &lt;option value=&#x27;p1@example.com&#x27;&gt;p1&lt;/option&gt; &lt;option value=&#x27;p2@example.com&#x27;&gt;p2&lt;/option&gt; &lt;option value=&#x27;p3@example.com&#x27;&gt;p3&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; Courses:&#123;&#x27; &#x27;&#125; &#123;courses?.data?.courses.map((course, index) =&gt; ( &lt;span key=&#123;index&#125; style=&#123;&#123; marginRight: &#x27;10px&#x27; &#125;&#125;&gt; &#123;course&#125; &lt;/span&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default Users 先将用户的email作为查询条件。所以将几个用户信息做了一个受控的select​ 下拉框。可以选择用户，通过用户匹配对应的email。 通过将email​ 的值，传入到第一个查询的useQuery中，把参数传入getUserEmail，获取到对应对学生channelId。 然后再将channelId传入到第二个查询useQuery中，把参数传入getCourses，获取到学生对应的课程信息。通过配置enabled: !!channelId，达到依赖查询，只要channelId有值才会更新。 这样就可以通过匹配user的邮箱来查询对应的课程。需要注意map的路径层级。 ‍ ‍ 初始化查询数据主要用于当网络较慢时，通过查询缓存中的数据，优先展示缓存中的数据，而不是显示长时间的 loading 来影响查询体验。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// src/pages/RQSuperHeroPersonal/index.jsximport React from &#x27;react&#x27;import &#123; useParams &#125; from &#x27;react-router-dom&#x27;import &#123; useQuery, QueryClient &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const RQSuperHeroPersonal = () =&gt; &#123; const queryClient = new QueryClient() const &#123; heroId &#125; = useParams() const fetcher = heroId =&gt; axios(`http://localhost:4000/superheros/$&#123;heroId&#125;`) const &#123; data, isLoading, isError, error &#125; = useQuery( [&#x27;rqsuperheropersonal&#x27;, heroId], () =&gt; fetcher(heroId), &#123; initialData: () =&gt; &#123; const hero = queryClient .getQueriesData([&#x27;rqsuperhero&#x27;]) ?.data?.find(hreo =&gt; hero.id === parseInt(heroId)) if (hero) &#123; return &#123; data: hero &#125; &#125; else &#123; return undefined &#125; &#125; &#125; ) if (isLoading) &#123; return &lt;div&gt;加载中&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; console.log(data) return ( &lt;div&gt; &lt;div&gt; &#123;data?.data.id&#125;. &#123;data?.data.name&#125; - &#123;data?.data.alterEgo&#125; - &#123;data?.data.gender&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default RQSuperHeroPersonal 需要先引入QueryClient，在当前useQuery中配置initialData，让当前页面的查询可以使用单独的 QueryClient 配置。 然后通过匹配缓存中的hero的id是否与查询参数中的heroId，将数据匹配给data​。 ‍ 分页分页需要通过 ReactQuery 传递两个参数给到请求函数，一个是每页显示多少条数据的pageSize，一个是当前页码pageNumber。 json-server​ 的两个分页参数是_limit和_page，分别对应这两个参数。 使用useState做这两个参数对状态管理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// src/pages/RQDCSuperHero/index.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const fetchHero = (limit, pageNumber) =&gt; axios(&#123; url: `http://localhost:4000/dcsuperheros`, params: &#123; _limit: limit, _page: pageNumber &#125; &#125;)const RQDCSuperHero = () =&gt; &#123; const [pagination, setPagination] = useState(&#123; pageSize: 2, pageNumber: 1 &#125;) const &#123; isLoading, isError, error, data, isFetching &#125; = useQuery( [&#x27;dcheros&#x27;, pagination.pageSize, pagination.pageNumber], () =&gt; fetchHero(pagination.pageSize, pagination.pageNumber), &#123; keepPreviousData: true &#125; ) if (isLoading) &#123; return &lt;div&gt;加载中...&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &#123;data?.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setPagination(&#123; ...pagination, pageNumber: pagination.pageNumber - 1 &#125;)&#125; disabled=&#123;pagination.pageNumber === 1&#125; &gt; &#123;isFetching ? &#x27;翻页中...&#x27; : &#x27;上一页&#x27;&#125; &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setPagination(&#123; ...pagination, pageNumber: pagination.pageNumber + 1 &#125;)&#125; disabled=&#123;pagination.pageNumber === 5&#125; &gt; &#123;isFetching ? &#x27;翻页中...&#x27; : &#x27;下一页&#x27;&#125; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default RQDCSuperHero ReactQuery的第三个参数配置keepPreviousData: true，可以让之前浏览的页面缓存，后退时会通过缓存展示，提高浏览体验。 ‍ 无限分页点击加载这个会用到一个新的方法useInfiniteQuery，使用和 useQuery 类似，但有些许不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// src/pages/RQDCInfiniteSuperHero/index.jsximport React from &#x27;react&#x27;import &#123; useInfiniteQuery &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const fetchHero = (&#123; pageParam = 1 &#125;) =&gt; axios(&#123; url: `http://localhost:4000/dcsuperheros`, params: &#123; _limit: 2, _page: pageParam &#125; &#125;)const RQDCInfiniteSuperHero = () =&gt; &#123; const &#123; data, isLoading, isError, error, fetchNextPage, isFetchingNextPage, hasNextPage &#125; = useInfiniteQuery([&#x27;infinitedcsuperhero&#x27;], fetchHero, &#123; getNextPageParam: (lastPage, pages) =&gt; &#123; if (pages.length &lt; 5) &#123; return pages.length + 1 &#125; else &#123; return undefined &#125; &#125; &#125;) if (isLoading) &#123; return &lt;div&gt;加载中...&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h4&gt;RQSuperHero&lt;/h4&gt; &#123;data?.pages?.map(page =&gt; page.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.id&#125;. &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; )) )&#125; &#123;isFetchingNextPage ? &#x27;加载中...&#x27; : null&#125; &lt;button disabled=&#123;!hasNextPage&#125; onClick=&#123;() =&gt; fetchNextPage()&#125;&gt; 加载更多 &lt;/button&gt; &lt;/div&gt; )&#125;export default RQDCInfiniteSuperHero 这里我们先看第三个参数里的getNextPageParam这个方法。 当收到查询到的新数据时，此函数将接受无限分页数据列表的最后一页的数据lastPage和所有页面的数据allPages。 然后这个方法，返回一个变量pageParam，这个变量作为最后一页的参数传递个查询函数。 返回undefined，则表示没有下一页可用。 ‍ 所以当getNextPageParam这个方法，通过判断，是否达到最后一页了，来做递增计算。然后通过返回值pageParam，将翻页变量传递给fetchHero这个请求方法，进行数据翻页，加载到allPage，返回给页面。 这里的坑：一定要用 ReactQuery 给的这个pageParam返回参数作为翻页的参数并且给定初始值。 ‍ 所以整个流程是通过useInfiniteQuery中返回的fetchNextPage方法来触发，第三个参数中的getNextPageParam，返回一个pageParam给到请求函数获取下一页的请求。返回到pages中，通过返回的data.pages就可以获取到所有加载的数据。 ‍ 上面这种判断方法比较局限，一般正式的 API 会返回数据总数，那么就可以计算出最后一页是多少。所以通常会通过判断lastPage是否是最后一页来做返回。以下为常用做法。 1234567getNextPageParam: (lastPage, allPages) =&gt; &#123; if (lastPage.page &lt; lastPage.total_pages) &#123; return lastPage + 1 &#125; else &#123; return undefined &#125;&#125; 然后需要注意返回的数据，是放到data的pages里，pages是一个数组，数组里包含每页的数据，数据是一个对象。所以在pages做map后，还需要在下级做个map获取每页的数据。这里相当于使用了reduce做了一个累加。有新的分页就push到数组中。后面我们还会使用一个插件，来增强这个体验，滚动到页面底部就自动加载。 ‍ 滚动底部自动加载这里使用了SWAPI的数据，否则没有那么多数据加载。 自动加载使用了一个插件 react-infinite-scroll-component。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// src/pages/SWInfinitePeople/index.jsximport React from &#x27;react&#x27;import &#123; useInfiniteQuery &#125; from &#x27;@tanstack/react-query&#x27;import InfiniteScroll from &#x27;react-infinite-scroll-component&#x27;import axios from &#x27;axios&#x27;const fetchPeople = url =&gt; axios(url)const SWInfinitePeople = () =&gt; &#123; const initialUrl = &#x27;https://swapi.dev/api/people/?page=1&#x27; const &#123; data, isLoading, isError, error, fetchNextPage, hasNextPage &#125; = useInfiniteQuery( [&#x27;swip&#x27;], (&#123; pageParam = initialUrl &#125;) =&gt; fetchPeople(pageParam), &#123; getNextPageParam: (lastPage, _allPages) =&gt; &#123; if (lastPage.data.next) &#123; return lastPage.data.next &#125; else &#123; return undefined &#125; &#125; &#125; ) if (isLoading) &#123; return &lt;div&gt;加载中...&lt;/div&gt; &#125; if (isError) &#123; return &lt;div&gt;出错了 &#123;error.message&#125;&lt;/div&gt; &#125; const dataLength = data.pages.reduce((acc, page) =&gt; acc + page.data.results.length, 0) return ( &lt;div&gt; &lt;h4&gt;The Star Wars&lt;/h4&gt; &lt;InfiniteScroll dataLength=&#123;dataLength&#125; next=&#123;fetchNextPage&#125; hasMore=&#123;hasNextPage || false&#125; loader=&#123;&lt;div&gt;加载中...&lt;/div&gt;&#125; endMessage=&#123;&lt;p&gt;到底了&lt;/p&gt;&#125; &gt; &#123;data?.pages?.map(page =&gt; page.data.results.map(people =&gt; &lt;PeopleCard key=&#123;people.name&#125; &#123;...people&#125; /&gt;) )&#125; &lt;/InfiniteScroll&gt; &lt;/div&gt; )&#125;const PeopleCard = (&#123; name, mass, skin_color, hair_color, height &#125;) =&gt; &#123; return ( &lt;div style=&#123;&#123; marginBottom: &#x27;16px&#x27;, padding: &#x27;0 24px 16px 24px&#x27;, border: &#x27;1px solid #ddd&#x27; &#125;&#125;&gt; &lt;h3&gt; &#123;name&#125; - &#123;mass&#125; &lt;/h3&gt; &lt;div&gt;Hiehgt: &#123;height&#125;&lt;/div&gt; &lt;div&gt;SkinColor: &#123;skin_color&#125;&lt;/div&gt; &lt;div&gt;HairColor: &#123;hair_color&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default SWInfinitePeople 因为 SWAPI 返回的的数据结果中有下一页next和上一页previous的完整路径，所以就直接拿到这个路径传给请求函数fetchPeople​。 因为useInfiniteQuery的pageParam需要一个初始值，所以设置一个常量为initialUrl，放入第一页的URL​。 然后再getNextPageParams中通过lastPage来获取下一页。传给pageParam。 将单条数据提取出来，做成一个组件PeopleCard来渲染。将值传给组件就可以了。 InfiniteScroll这里需要传入几个参数，前三个基本是必填参数。 dataLength：数据的长度，我们通过 reduce 来计算下 pages 里面的 data 下 resultes 的数据长度之和，就是每次加载的数据长度。 next：到达底部后调用的函数。使用useInfiniteQuery返回的fetchNextPage就可以了。 hasMore：是否还有更多数据，通过useInfiniteQuery返回的hasNextPage就可以了，如果返回undefined则显示false​。 loader：是加载时显示的内容。 endMessage：是加载到最底部显示的内容。 ‍ 修改 Mutationsmutation主要用于创建、更新、修改、删除数据。ReactQuery 中使用useMutation这个钩子函数。 ‍ 简单添加我们添加一组超级英雄到列表，将获取列表和添加都放到一个 hooks 里。 12345678910111213141516// src/hooks/useSuperHero.jsimport React from &#x27;react&#x27;import &#123; useQuery, useMutation, QueryClient &#125; from &#x27;@tanstack/react-query&#x27;import axios from &#x27;axios&#x27;const fetchHero = async () =&gt; await axios(&#x27;http://localhost:4000/dcsuperheros&#x27;)const addHero = async hero =&gt; await axios.post(&#x27;http://localhost:4000/dcsuperheros&#x27;, hero)export const useFetchSuperHero = (onSuccess, onError) =&gt; &#123; return useQuery([&#x27;fetch/superheros&#x27;], fetchHero, &#123; onSuccess, onError &#125;)&#125;export const useAddSuperHero = hero =&gt; &#123; return useMutation(addHero)&#125; 然后我们在到页面引用对应的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// src/pages/RQAddSuperHero.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useFetchSuperHero, useAddSuperHero &#125; from &#x27;@/hooks/useSuperHero.js&#x27;const RQAddSuperHero = () =&gt; &#123; const [name, setName] = useState(&#x27;&#x27;) const [alterEgo, setAlterEgo] = useState(&#x27;&#x27;) const onSuccess = data =&gt; &#123; console.log(&#123; data &#125;) &#125; const onError = error =&gt; &#123; console.log(&#123; error &#125;) &#125; const &#123; data, isLoading, refetch &#125; = useFetchSuperHero(onSuccess, onError) const &#123; mutate &#125; = useAddSuperHero() const handleSubmit = () =&gt; &#123; const hero = &#123; name, alterEgo &#125; mutate(hero) setName(&#x27;&#x27;) setAlterEgo(&#x27;&#x27;) &#125; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return ( &lt;&gt; &lt;h2&gt;RQAddSuperHero&lt;/h2&gt; &lt;div&gt; &lt;input type=&#x27;text&#x27; value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt; &lt;input type=&#x27;text&#x27; value=&#123;alterEgo&#125; onChange=&#123;e =&gt; setAlterEgo(e.target.value)&#125; /&gt; &lt;button onClick=&#123;handleSubmit&#125;&gt;添加&lt;/button&gt; &lt;button onClick=&#123;refetch&#125;&gt;刷新列表&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &#123;data?.data.map(hero =&gt; ( &lt;div key=&#123;hero.id&#125;&gt; &#123;hero.id&#125;. &#123;hero.name&#125; - &#123;hero.alterEgo&#125; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/&gt; )&#125;export default RQAddSuperHero useMutation这个方法返回一个mutate方法，这个就是用来接收提交的数据的方法。 useMutation同样可以返回data、isLoading、isError、error，但是在与useQuery同时使用时，需要注意修改为别名，以免变量名冲突。 useMutation的回调onSuccess和onError通常可以用于提交数据成功以后获取到 API 返回的数据如何操作。稍后我们看下如何在登录时使用。 ‍ 这里的坑：在将useQuery和useMutation放到同一个页面里使用时，会报 React Hooks 的错误，按照教程放到一个单独的 hooks 在引用才解决这个问题。 ‍ 登录示例这里案例 API 使用的是RealWorld的项目 API，使用了formik作为表单数据接收和表单数据校验，使用useMutation提交数据到 API，拿到 APi 返回的用户信息，在onSuccess后将用户信息存入 store，跳转到首页。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import React from &#x27;react&#x27;import &#123; Link, useNavigate &#125; from &#x27;react-router-dom&#x27;import &#123; Formik, Form, Field, ErrorMessage &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import &#123; useMutation &#125; from &#x27;@tanstack/react-query&#x27;import userApis from &#x27;@/service/apis/user&#x27;import &#123; userAction &#125; from &#x27;@/store/user&#x27;import &#123; LoginWrap, FormError &#125; from &#x27;./style&#x27;const Login = () =&gt; &#123; const navigate = useNavigate() const initialValues = &#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125; const validationSchema = Yup.object(&#123; email: Yup.string().email(&#x27;请输入正确的邮箱格式&#x27;).required(&#x27;请输入邮箱&#x27;), password: Yup.string().required(&#x27;请输入密码&#x27;) &#125;) const onSubmit = values =&gt; &#123; mutate(values) &#125; const &#123; isLoading, isError, error, mutate &#125; = useMutation([&#x27;user/login&#x27;], userApis.postLogin, &#123; onSuccess: data =&gt; &#123; userAction.login(&#123; token: data.token, user: &#123; ...data &#125; &#125;) navigate(&#x27;/&#x27;) &#125;, onError: error =&gt; &#123; console.log(JSON.stringify(error)) &#125; &#125;) return ( &lt;LoginWrap&gt; &lt;div className=&#x27;page-container&#x27;&gt; &lt;div className=&#x27;log-block&#x27;&gt; &lt;div className=&#x27;log-sidebar&#x27;&gt; &lt;div className=&#x27;log-sidebar-text&#x27;&gt; &lt;h2&gt;Real World&lt;/h2&gt; 为了消除开发领域的知识不平等，建立了开放式协作的问答社区。欢迎你加入并贡献自己的智慧。 &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;log-container&#x27;&gt; &lt;p className=&#x27;log-tips&#x27;&gt; 还没有账号，去&lt;Link to=&#x27;/register&#x27;&gt;注册&lt;/Link&gt; &lt;/p&gt; &lt;div className=&#x27;log-text&#x27;&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;small&gt;Real World Login&lt;/small&gt; &#123;isError ? ( &lt;ul className=&#x27;error-messages&#x27;&gt; &#123;Object.entries(error).map(([key, messages]) =&gt; messages.map(message =&gt; ( &lt;li key=&#123;`$&#123;key&#125; $&#123;message&#125;`&#125;&gt; &#123;key&#125; &#123;message&#125; &lt;/li&gt; )) )&#125; &lt;/ul&gt; ) : null&#125; &lt;/div&gt; &lt;Formik initialValues=&#123;initialValues&#125; onSubmit=&#123;onSubmit&#125; validationSchema=&#123;validationSchema&#125; &gt; &lt;Form className=&#x27;log-form&#x27;&gt; &lt;div className=&#x27;log-form-item&#x27;&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;log-form-input&#x27; placeholder=&#x27;请输入电子邮箱&#x27; /&gt; &lt;ErrorMessage name=&#x27;email&#x27; component=&#123;FormError&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;log-form-item&#x27;&gt; &lt;Field type=&#x27;password&#x27; name=&#x27;password&#x27; className=&#x27;log-form-input&#x27; placeholder=&#x27;请输入密码&#x27; /&gt; &lt;ErrorMessage name=&#x27;password&#x27; component=&#123;FormError&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;log-form-item&#x27;&gt; &lt;button className=&#x27;log-form-btn&#x27; type=&#x27;submit&#x27; disabled=&#123;isLoading &amp;&amp; true&#125;&gt; &#123;isLoading ? &#x27;登录中...&#x27; : &#x27;登录&#x27;&#125; &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/Formik&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/LoginWrap&gt; )&#125;export default Login ‍ 主动查询失效上面的示例中，我们查询后还需要通过点击按钮，通过useQuery的refetch​ 来触发列表刷新。 在 ReactQuery 中可以使用QueryClient中的invalidateQueries方法可以主动标记查询过时，在通过useQuery查询数据，这时这会因为数据过时而主动重新获取数据。 12345678910// sec/hooks/useSuperHero.jsexport const useAddSuperHero = () =&gt; &#123; const queryClient = new QueryClient() return useMutation(addHero, &#123; onSuccess: () =&gt; &#123; queryClient.invalidateQueries([&#x27;super-heros&#x27;]) &#125; &#125;)&#125; ‍ 更新缓存数据通过上面的示例，提交超级英雄的表单后，会发起一个 201 的网络请求，然后返回一个所有数据的 200 响应。 我们可以通过QueryClient中的 setQueryData 来直接更新查询的缓存数据，而不必浪费网络响应，节约资源。 12345678910111213141516// src/hooks/useSuperHero.jsexport const useAddSuperHero = () =&gt; &#123; const queryClient = new QueryClient() return useMutation(addHero, &#123; onSuccess: () =&gt; &#123; // queryClient.invalidateQueries([&#x27;super-heros&#x27;]) queryClient.setQueryData([&#x27;super-heros&#x27;], oldQueryData =&gt; &#123; return &#123; ...oldQueryData, data: [...oldQueryData.data, data.data] &#125; &#125;) &#125; &#125;)&#125; ‍ 乐观更新乐观更新其实也是种获取数据体验上的优化，如果能获取数据成功，就展示新获取的数据，如果没有获取数据成功，就展示缓存中的陈旧数据。 123456789101112131415161718192021222324// src/hooks/useSuperHero.jsexport const useAddSuperHero = () =&gt; &#123; const queryClient = new QueryClient() return useMutation(addHero, &#123; onMutate: async newHero =&gt; &#123; await queryClient.cancelQueries([&#x27;super-heros&#x27;]) const previousHeroData = queryClient.getQueryData([&#x27;super-heros&#x27;]) queryClient.setQueryData([&#x27;super-heros&#x27;], oldQueryData =&gt; &#123; return &#123; ...oldQueryData, data: [...oldQueryData.data, &#123; id: oldQueryData?.data?.length + 1, ...newHero &#125;] &#125; &#125;) return &#123; previousHeroData &#125; &#125;, onError: (_err, _newTodo, context) =&gt; &#123; queryClient.setQueryData([&#x27;super-heros&#x27;], context.previousHeroData) &#125;, onSettled: () =&gt; &#123; queryClient.invalidateQueries([&#x27;super-heros&#x27;]) &#125; &#125;)&#125; 使用乐观更新，就需要三个步骤： 先使用onMutate在获取数据mutate调用时使用cancelQueries取消相关的查询。然后通过getQueryData拿到保存之前状态的数据快照。然后使用setQueryData执行乐观更新。返回具有具有快照数据的上下文对象&#123; previousHeroData &#125;。 如果修改失败onError，则使用onMutate返回的上下文进行回滚。 使用onSettled来代替onSuccess，他表示在错误或成功之后的操作，通过主动查询失败重新获取数据。 ‍ 总结ReactQuery 基本上能满足绝大部分的数据获取、提交的需求，同时简化数据获取的状态以及缓存的管理。上述内容基本满足业务的绝大部分需求，更多功能在遇到了再去查查官方文档。","permalink":"http://example.com/2022/10/21/React-Query%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"formik","slug":"formik","permalink":"http://example.com/tags/formik/"}],"title":"Formik学习笔记之二","date":"2022/10/18","text":"这部分主要是示例练习。将input、textarea、select、radio、checkbox、data封装成Formik的组件，在使用时简化操作，并在几个简单的案例中使用。 ‍ 基础结构FormikControl是封装的Formik组件。 FormikContainer是演示的文档。 由于主要是使用演示的文档，所以没有将组件样式一起做封装。 1234567891011121314src/ components/ FormikControl/ - index.jsx - Checkbox.jsx - DatePicker.jsx - Input.jsx - Radio.jsx - Select.jsx - Textarea.jsx pages/ FormikContainer/ - index.jsx - style.js ‍ 组件部分FormikControl下的index.jsx主要用于根据传入的props来调用不同的组件，并将props传下去。 123456789101112131415161718192021222324252627282930// /src/components/FormikControl/index.jsximport React from &#x27;react&#x27;import Checkbox from &#x27;./Checkbox&#x27;import DatePicker from &#x27;./DatePicker&#x27;import Input from &#x27;./Input&#x27;import Radio from &#x27;./Radio&#x27;import Select from &#x27;./Select&#x27;import Textarea from &#x27;./Textarea&#x27;const FomikControl = (&#123; control, ...rest &#125;) =&gt; &#123; switch (control) &#123; case &#x27;input&#x27;: return &lt;Input &#123;...rest&#125; /&gt; case &#x27;textarea&#x27;: return &lt;Textarea &#123;...rest&#125; /&gt; case &#x27;select&#x27;: return &lt;Select &#123;...rest&#125; /&gt; case &#x27;radio&#x27;: return &lt;Radio &#123;...rest&#125; /&gt; case &#x27;checkbox&#x27;: return &lt;Checkbox &#123;...rest&#125; /&gt; case &#x27;date&#x27;: return &lt;DatePicker &#123;...rest&#125; /&gt; default: return null &#125;&#125;export default FomikControl ‍ Input1234567891011121314151617// src/components/FormikControl/Input.jsximport React from &#x27;react&#x27;import &#123; Field, ErrorMessage &#125; from &#x27;formik&#x27;import &#123; ErrorText &#125; from &#x27;@/pages/FormikContainer/style&#x27;const Input = (&#123; label, name, ...rest &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt; &lt;Field id=&#123;name&#125; name=&#123;name&#125; &#123;...rest&#125; /&gt; &lt;ErrorMessage name=&#123;name&#125; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; )&#125;export default Input ‍ Textarea1234567891011121314151617// src/components/FormikControl/Textarea.jsximport React from &#x27;react&#x27;import &#123; Field, ErrorMessage &#125; from &#x27;formik&#x27;import &#123; ErrorText &#125; from &#x27;@/pages/FormikContainer/style&#x27;const Textarea = (&#123; label, name, ...rest &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt; &lt;Field as=&#x27;textarea&#x27; id=&#123;name&#125; name=&#123;name&#125; &#123;...rest&#125; /&gt; &lt;ErrorMessage name=&#123;name&#125; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; )&#125;export default Textarea ‍ Select1234567891011121314151617181920212223// src/components/FormikControl/Select.jsximport React from &#x27;react&#x27;import &#123; Field, ErrorMessage &#125; from &#x27;formik&#x27;import &#123; ErrorText &#125; from &#x27;@/pages/FormikContainer/style&#x27;const Select = (&#123; label, name, options, ...rest &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt; &lt;Field as=&#x27;select&#x27; id=&#123;name&#125; name=&#123;name&#125; &#123;...rest&#125;&gt; &#123;options.map(option =&gt; ( &lt;option key=&#123;option.value&#125; value=&#123;option.value&#125;&gt; &#123;option.key&#125; &lt;/option&gt; ))&#125; &lt;/Field&gt; &lt;ErrorMessage name=&#123;name&#125; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; )&#125;export default Select ‍ Radio123456789101112131415161718192021222324252627282930313233343536// src/components/FormikControl/Radio.jsximport React from &#x27;react&#x27;import &#123; Field, ErrorMessage &#125; from &#x27;formik&#x27;import &#123; ErrorText &#125; from &#x27;@/pages/FormikContainer/style&#x27;const Radio = (&#123; label, name, options, ...rest &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt; &lt;Field name=&#123;name&#125; &#123;...rest&#125;&gt; &#123;(&#123; field &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-option-group&#x27;&gt; &#123;options.map(option =&gt; ( &lt;div className=&#x27;form-option-item&#x27; key=&#123;option.key&#125;&gt; &lt;input type=&#x27;radio&#x27; id=&#123;option.value&#125; &#123;...field&#125; value=&#123;option.value&#125; checked=&#123;field.value === option.value&#125; /&gt; &lt;label htmlFor=&#123;option.value&#125;&gt;&#123;option.key&#125;&lt;/label&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; ) &#125;&#125; &lt;/Field&gt; &lt;ErrorMessage name=&#123;name&#125; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; )&#125;export default Radio ‍ Checkboxcheckbox的坑： 在input上的checked上需要根据fielde.value判断是否包含option.value的值，需要用Boolean包裹得到一个布尔值，给到checked 123456789101112131415161718192021222324252627282930313233343536// src/components/FormikControl/Checkbox.jsximport React from &#x27;react&#x27;import &#123; Field, ErrorMessage &#125; from &#x27;formik&#x27;import &#123; ErrorText &#125; from &#x27;@/pages/FormikContainer/style&#x27;const Checkbox = (&#123; label, name, options, ...rest &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt; &lt;Field name=&#123;name&#125; &#123;...rest&#125;&gt; &#123;(&#123; field &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-option-group&#x27;&gt; &#123;options.map(option =&gt; ( &lt;div className=&#x27;form-option-item&#x27; key=&#123;option.key&#125;&gt; &lt;input type=&#x27;checkbox&#x27; id=&#123;option.value&#125; &#123;...field&#125; value=&#123;option.value&#125; checked=&#123;Boolean(field.value.includes(option.value))&#125; /&gt; &lt;label htmlFor=&#123;option.value&#125;&gt;&#123;option.key&#125;&lt;/label&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; ) &#125;&#125; &lt;/Field&gt; &lt;ErrorMessage name=&#123;name&#125; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; )&#125;export default Checkbox ‍ DatePickerdatepicker是用了react-datepicker这个插件，但似乎比较久远了，样式在演示中有错位，但不影响结果。 123456789101112131415161718192021222324252627282930313233// src/components/FormikControl/DatePicker.jsximport React from &#x27;react&#x27;import &#123; Field, ErrorMessage &#125; from &#x27;formik&#x27;import &#123; ErrorText &#125; from &#x27;@/pages/FormikContainer/style&#x27;import DateView from &#x27;react-datepicker&#x27;import &#x27;react-datepicker/dist/react-datepicker.css&#x27;const DatePicker = (&#123; label, name, ...rest &#125;) =&gt; &#123; return ( &lt;div className=&#x27;form-control&#x27;&gt; &lt;label htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;/label&gt; &lt;Field name=&#123;name&#125; &#123;...rest&#125;&gt; &#123;(&#123; field, form &#125;) =&gt; &#123; const &#123; setFieldValue &#125; = form const &#123; value &#125; = field return ( &lt;DateView id=&#123;name&#125; &#123;...field&#125; &#123;...rest&#125; selected=&#123;value&#125; onChange=&#123;date =&gt; setFieldValue(name, date)&#125; /&gt; ) &#125;&#125; &lt;/Field&gt; &lt;ErrorMessage name=&#123;name&#125; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; )&#125;export default DatePicker ‍ 演示页面‍ 演示一需要注意的两个问题： checkbox的初始值需要为空数组。因为可以放入多个值。 checkbox的验证必选，不能使用required，只能用array的min来设置最少选择一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// src/pages/FormikContainer/index.jsximport React from &#x27;react&#x27;import &#123; Formik, Form &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import FormikControl from &#x27;@/components/FormikControl&#x27;import &#123; FormikContainerWrap &#125; from &#x27;./style&#x27;const FormikContainer = () =&gt; &#123; const selectOptions = [ &#123; key: &#x27;请选择&#x27;, value: &#x27;&#x27; &#125;, &#123; key: &#x27;选项一&#x27;, value: &#x27;option1&#x27; &#125;, &#123; key: &#x27;选项二&#x27;, value: &#x27;option2&#x27; &#125;, &#123; key: &#x27;选项三&#x27;, value: &#x27;option3&#x27; &#125; ] const radioOptions = [ &#123; key: &#x27;选项一&#x27;, value: &#x27;radio1&#x27; &#125;, &#123; key: &#x27;选项二&#x27;, value: &#x27;radio2&#x27; &#125;, &#123; key: &#x27;选项三&#x27;, value: &#x27;radio3&#x27; &#125; ] const checkboxOptions = [ &#123; key: &#x27;选项一&#x27;, value: &#x27;checkbox1&#x27; &#125;, &#123; key: &#x27;选项二&#x27;, value: &#x27;checkbox2&#x27; &#125;, &#123; key: &#x27;选项三&#x27;, value: &#x27;checkbox3&#x27; &#125; ] const initialValues = &#123; email: &#x27;&#x27;, description: &#x27;&#x27;, selectOption: &#x27;&#x27;, radioOption: &#x27;&#x27;, checkboxOption: [], birthDate: &#x27;&#x27; &#125; const validationSchema = Yup.object(&#123; email: Yup.string().email(&#x27;请输入正确的邮箱格式&#x27;).required(&#x27;请输入邮箱&#x27;), description: Yup.string().required(&#x27;请输入简介&#x27;), selectOption: Yup.string().required(&#x27;请选择下拉option&#x27;), radioOption: Yup.string().required(&#x27;请选择单选option&#x27;), checkboxOption: Yup.array().min(1, &#x27;请选择多选option&#x27;), birthDate: Yup.date().required(&#x27;请选择日期&#x27;).nullable() &#125;) const onSubmit = values =&gt; &#123; console.log(&#x27;formik data: &#x27;, values) &#125; return ( &lt;FormikContainerWrap&gt; &lt;Formik initialValues=&#123;initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;formik =&gt; &#123; return ( &lt;Form&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;email&#x27; label=&#x27;邮箱&#x27; name=&#x27;email&#x27; /&gt; &lt;FormikControl control=&#x27;textarea&#x27; label=&#x27;简介&#x27; name=&#x27;description&#x27; /&gt; &lt;FormikControl control=&#x27;select&#x27; label=&#x27;下拉选项&#x27; name=&#x27;selectOption&#x27; options=&#123;selectOptions&#125; /&gt; &lt;FormikControl control=&#x27;radio&#x27; label=&#x27;单选&#x27; name=&#x27;radioOption&#x27; options=&#123;radioOptions&#125; /&gt; &lt;FormikControl control=&#x27;checkbox&#x27; label=&#x27;多选&#x27; name=&#x27;checkboxOption&#x27; options=&#123;checkboxOptions&#125; /&gt; &lt;FormikControl control=&#x27;date&#x27; label=&#x27;生日&#x27; name=&#x27;birthDate&#x27; /&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;button className=&#x27;form-btn&#x27; type=&#x27;submit&#x27;&gt; 提交 &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; ) &#125;&#125; &lt;/Formik&gt; &lt;/FormikContainerWrap&gt; )&#125;export default FormikContainer ‍ 演示二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// src/pages/Login/index.jsximport React from &#x27;react&#x27;import &#123; Formik, Form &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import FormikControl from &#x27;@/comonents/FormikControl&#x27;import &#123; FormikContainerWrap &#125; from &#x27;@/pages/FormikContainer/style&#x27;const Login = () =&gt; &#123; const initialValues = &#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125; const validationSchema = Yup.object(&#123; email: Yup.string().email(&#x27;请输入正确的邮箱&#x27;).required(&#x27;请输入邮箱&#x27;), password: Yup.string() .min(6, &#x27;请输入6位以上的密码&#x27;) .max(12, &#x27;密码最多12位&#x27;) .required(&#x27;请输入密码&#x27;) &#125;) const onSubmit = values =&gt; &#123; console.log(&#x27;formit Values: &#x27;, values) &#125; return ( &lt;FormikContainerWrap&gt; &lt;Formik initialValues=&#123;initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;formik =&gt; ( &lt;Form&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;email&#x27; label=&#x27;邮箱&#x27; name=&#x27;email&#x27; /&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;password&#x27; label=&#x27;密码&#x27; name=&#x27;password&#x27; /&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;button className=&#x27;form-btn&#x27; type=&#x27;submit&#x27; disabled=&#123;!(formik.dirty &amp;&amp; formik.isValid)&#125; &gt; 登录 &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; )&#125; &lt;/Formik&gt; &lt;/FormikContainerWrap&gt; )&#125;export default Login ‍ 演示三此演示中需要注意验证方法重复密码的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// src/pages/Register/index.jsximport React from &#x27;react&#x27;import &#123; Formik, Form &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import FormikControl from &#x27;@/components/FormikControl&#x27;import &#123; FormikContainerWrap &#125; from &#x27;../FormikContainer/style&#x27;const Register = () =&gt; &#123; const options = [ &#123; key: &#x27;email&#x27;, value: &#x27;emailMoc&#x27; &#125;, &#123; key: &#x27;phone&#x27;, value: &#x27;phoneMoc&#x27; &#125; ] const initialValues = &#123; email: &#x27;&#x27;, password: &#x27;&#x27;, comfilmPassword: &#x27;&#x27;, modOfContact: &#x27;&#x27;, phone: &#x27;&#x27; &#125; const validationSchema = Yup.object(&#123; email: Yup.string().email(&#x27;请输入正确邮箱&#x27;).required(&#x27;请输入邮箱&#x27;), password: Yup.string() .min(6, &#x27;请输入6-12位描&#x27;) .max(12, &#x27;请输入6-12位密码&#x27;) .required(&#x27;请输入密码&#x27;), confirmPassword: Yup.string() .oneOf([Yup.ref(&#x27;password&#x27;), &#x27;&#x27;], &#x27;与密码输入不一致&#x27;) .required(&#x27;请确认密码&#x27;), modOfContact: Yup.string().required(&#x27;请选择联系方式&#x27;), phone: Yup.string().when(&#x27;modOfContact&#x27;, &#123; is: &#x27;phoneMoc&#x27;, then: Yup.string().required(&#x27;请输入电话&#x27;) &#125;) &#125;) const onSubmit = values =&gt; &#123; console.log(&#x27;formik values: &#x27;, values) &#125; return ( &lt;FormikContainerWrap&gt; &lt;Formik initialValues=&#123;initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;formik =&gt; ( &lt;Form&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;email&#x27; label=&#x27;邮箱&#x27; name=&#x27;email&#x27; /&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;password&#x27; label=&#x27;密码&#x27; name=&#x27;password&#x27; /&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;password&#x27; label=&#x27;确认密码&#x27; name=&#x27;confirmPassword&#x27; /&gt; &lt;FormikControl control=&#x27;radio&#x27; label=&#x27;联系方式&#x27; name=&#x27;modOfContact&#x27; options=&#123;options&#125; /&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;text&#x27; label=&#x27;电话&#x27; name=&#x27;phone&#x27; /&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;button className=&#x27;form-btn&#x27; type=&#x27;submit&#x27; disabled=&#123;!(formik.dirty &amp;&amp; formik.isValid)&#125; &gt; 注册 &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; )&#125; &lt;/Formik&gt; &lt;/FormikContainerWrap&gt; )&#125;export default Register ‍ 演示四同样需要注意验证规则中多选对后面选项的影响。如果选择联系方式为邮件，则后面的电话为非必填，如果选择联系方式为电话，则后面的电话必填。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// src/pages/EnrollmentForm/index.jsximport React from &#x27;react&#x27;import &#123; Formik, Form &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import FormikControl from &#x27;@/components/FormikControl&#x27;import &#123; FormikContainerWrap &#125; from &#x27;../FormikContainer/style&#x27;const EnrollmentForm = () =&gt; &#123; const selectOptions = [ &#123; key: &#x27;请选择&#x27;, value: &#x27;&#x27; &#125;, &#123; key: &#x27;React&#x27;, value: &#x27;react&#x27; &#125;, &#123; key: &#x27;Vue&#x27;, value: &#x27;vue&#x27; &#125;, &#123; key: &#x27;Angular&#x27;, value: &#x27;angular&#x27; &#125; ] const checkboxOptions = [ &#123; key: &#x27;Html&#x27;, value: &#x27;html&#x27; &#125;, &#123; key: &#x27;CSS&#x27;, value: &#x27;css&#x27; &#125;, &#123; key: &#x27;Javascript&#x27;, value: &#x27;javascript&#x27; &#125; ] const initialValues = &#123; email: &#x27;&#x27;, bio: &#x27;&#x27;, coures: &#x27;&#x27;, skills: [], couresDate: &#x27;&#x27; &#125; const validationSchema = Yup.object(&#123; email: Yup.string().email(&#x27;请输入正确的邮箱&#x27;).required(&#x27;请输入邮箱&#x27;), bio: Yup.string().required(&#x27;请输入简历&#x27;), coures: Yup.string().required(&#x27;请选择课程&#x27;), skills: Yup.array().min(1, &#x27;请选择掌握的技能&#x27;), couresDate: Yup.date().required(&#x27;请选择课程日期&#x27;).nullable() &#125;) const onSubmit = values =&gt; &#123; console.log(&#x27;formik values: &#x27;, values) &#125; return ( &lt;FormikContainerWrap&gt; &lt;Formik initialValues=&#123;initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;formik =&gt; ( &lt;Form&gt; &lt;FormikControl control=&#x27;input&#x27; type=&#x27;email&#x27; label=&#x27;邮箱&#x27; name=&#x27;email&#x27; /&gt; &lt;FormikControl control=&#x27;textarea&#x27; label=&#x27;简历&#x27; name=&#x27;bio&#x27; /&gt; &lt;FormikControl control=&#x27;select&#x27; label=&#x27;课程&#x27; name=&#x27;coures&#x27; options=&#123;selectOptions&#125; /&gt; &lt;FormikControl control=&#x27;checkbox&#x27; label=&#x27;技能&#x27; name=&#x27;skills&#x27; options=&#123;checkboxOptions&#125; /&gt; &lt;FormikControl control=&#x27;date&#x27; label=&#x27;课程日期&#x27; name=&#x27;couresDate&#x27; /&gt; &lt;div className=&#x27;form-control&#x27;&gt; &lt;button className=&#x27;form-btn&#x27; type=&#x27;submit&#x27; disabled=&#123;!formik.isValid&#125;&gt; 注册 &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; )&#125; &lt;/Formik&gt; &lt;/FormikContainerWrap&gt; )&#125;export default EnrollmentForm ‍","permalink":"http://example.com/2022/10/18/Formik%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"formik","slug":"formik","permalink":"http://example.com/tags/formik/"}],"title":"Formik学习笔记之一","date":"2022/10/18","text":"继续挖Codevolution大佬的教程。form在很多场景都会用到，最少都是一个登录注册。使用Formik可以大大简化数据收集以及表单验证的过程。油管上大佬教程的地址奉上： React Formik Tutorial 结合react-query提交表单数据很犀利。 Formik是一个React的表单库，他的目标是解决三个问题： 获取表单项的状态值。 表单项的验证和错误消息提示。 处理表单数据提交。 ‍ 安装1pnpm add formik ‍ 基础使用通过Formik提供的钩子函数useFormik可以快速上手。 代码一次性贴上，逐块说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import React from &#x27;react&#x27;import &#123; useFormik &#125; from &#x27;formik&#x27;import &#123; FormPageWrap &#125; from &#x27;./style&#x27;const FormPage = () =&gt; &#123; const initialValues = &#123; name: &#x27;&#x27;, email: &#x27;&#x27;, channel: &#x27;&#x27; &#125; const onSubmit = values =&gt; &#123; console.log(&#x27;values&#x27;, values) &#125; const validate = values =&gt; &#123; let errors = &#123;&#125; if (!values.name) &#123; errors.name = &#x27;用户名不能为空&#x27; &#125; if (!values.email) &#123; errors.email = &#x27;邮箱不能为空&#x27; &#125; else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,4&#125;$/i.test(values.email)) &#123; errors.email = &#x27;请输入正确的邮箱格式&#x27; &#125; if (!values.channel) &#123; errors.channel = &#x27;频道不能为空&#x27; &#125; return errors &#125; const formik = useFormik(&#123; initialValues, onSubmit, validate &#125;) console.log(&#x27;validate&#x27;, formik.touched) return ( &lt;FormPageWrap&gt; &lt;div className=&#x27;page-container&#x27;&gt; &lt;form onSubmit=&#123;formik.handleSubmit&#125;&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;name&#x27;&gt;用户名&lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; value=&#123;formik.values.name&#125; onChange=&#123;formik.handleChange&#125; onBlur=&#123;formik.handleBlur&#125; placeholder=&#x27;&#x27; /&gt; &#123;formik.touched.name &amp;&amp; formik.errors.name ? ( &lt;div className=&#x27;form-error&#x27;&gt;&#123;formik.errors.name&#125;&lt;/div&gt; ) : null&#125; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27;&gt;邮箱&lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;form-input&#x27; value=&#123;formik.values.email&#125; onChange=&#123;formik.handleChange&#125; onBlur=&#123;formik.handleBlur&#125; placeholder=&#x27;&#x27; /&gt; &#123;formik.touched.email &amp;&amp; formik.errors.email ? ( &lt;div className=&#x27;form-error&#x27;&gt;&#123;formik.errors.email&#125;&lt;/div&gt; ) : null&#125; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;channel&#x27;&gt;频道&lt;/label&gt; &lt;input type=&#x27;text&#x27; name=&#x27;channel&#x27; className=&#x27;form-input&#x27; value=&#123;formik.values.channel&#125; onChange=&#123;formik.handleChange&#125; onBlur=&#123;formik.handleBlur&#125; placeholder=&#x27;&#x27; /&gt; &#123;formik.touched.channel &amp;&amp; formik.errors.channel ? ( &lt;div className=&#x27;form-error&#x27;&gt;&#123;formik.errors.channel&#125;&lt;/div&gt; ) : null&#125; &lt;/div&gt; &lt;div className=&#x27;form-item single&#x27;&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27;&gt; 提交 &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/FormPageWrap&gt; )&#125;export default FormPage ‍ 初始化数据使用Formik提供的initialValues对象。 12345const initialValues = &#123; name: &#x27;simz&#x27;, email: &#x27;&#x27;, channel: &#x27;&#x27;&#125; 然后需要在表单向上进行受控绑定。将value绑定formik.values.[表单项name]，将onChange绑定formik.handleChange。即可完成受控组件处理。 1234567&lt;input type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; value=&#123;formik.values.name&#125; onChange=&#123;formik.handleChange&#125;/&gt; ‍ 表单提交数据使用Formik提供的onSubmit方法。 123const onSubmit = values =&gt; &#123; console.log(&#x27;values&#x27;, values)&#125; 然后需要处理两个地方。 将提交表单的type设置为submit，否则会报警告。 1&lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27;&gt;提交&lt;/button&gt; 将表单标签的onSubmit绑定为formik.handleSubmit。 1&lt;form onSubmit=&#123;formik.handleSubmit&#125;&gt;&lt;/form&gt; 这样在提交表单后可以通过values获取表单数据。 ‍ 表单验证使用Formik提供的validate方法。 通过values绑定的表单项名称进行验证。最后返回错误信息。 12345678910111213141516const validate = values =&gt; &#123; let errors = &#123;&#125; if (!values.name) &#123; errors.name = &#x27;用户名不能为空&#x27; &#125; if (!values.email) &#123; errors.email = &#x27;邮箱不能为空&#x27; &#125; else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,4&#125;$/i.test(values.email)) &#123; errors.email = &#x27;请输入正确的邮箱格式&#x27; &#125; if (!values.channel) &#123; errors.channel = &#x27;频道不能为空&#x27; &#125; return errors&#125; 然后在表单项下方设置错误信息。 1&#123;formik.errors.name ? &lt;div className=&#x27;form-error&#x27;&gt;&#123;formik.errors.name&#125;&lt;/div&gt; : null&#125; ‍ 修改表单验证方式默认表单验证为提交表单时显示错误。可以通过在表单项上绑定onBlur事件为formik.handleBlur来修改表单验证方式修改为失去焦点后进行验证。 12345678&lt;input type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; value=&#123;formik.values.name&#125; onChange=&#123;formik.handleChange&#125; onBlur=&#123;formik.handleBlur&#125;/&gt; 这样还有个问题，就是在一个表单项失去焦点后，所有表单项的错误都会显示出来，即使还没开始输入的表单项也会报错，所以需要使用formik.touched这个来协作使用。 formik.touched，可以在表单有焦点后，再失去时才会对表单项进行验证。这样就能阻止没有开始输入的表单项报错。所以在错误信息提示时进行并集绑定。控制显示错误信息的时机。 1&#123;formik.touched.name &amp;&amp; formik.errors.name ? &lt;div className=&#x27;form-error&#x27;&gt;&#123;formik.errors.name&#125;&lt;/div&gt; : null&#125; ‍ 进阶使用进阶主要通过一些包和api减少代码，提高使用效率。 ‍ 验证规则优化上面的代码中，表单的验证规则都需要自己来定义判断，Formik提供了一个yup的prop，可以通过yup预置的一些验证规则，快速的来完成验证。 ‍ 安装1pnpm add yup 如何使用？ 引用yup。 使用formik中的validationSchema方法Yup​。 yup的验证规则可以在其github查看。yup。 Yup的规则和写法比较简单，根据内置的规则填写限制和对应的错误提示。 1234567891011121314151617181920212223242526272829import React from &#x27;react&#x27;import &#123; useFormik &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import &#123; FormPageWrap &#125; from &#x27;./style&#x27;const FormPage = () =&gt; &#123; // 省略代码若干... const validationSchema = Yup.object(&#123; name: Yup.string().required(&#x27;用户名不能为空！&#x27;), email: Yup.string().email(&#x27;请输入正确的邮箱格式！&#x27;).required(&#x27;邮箱不能为空！&#x27;), channel: Yup.number() .min(3, &#x27;请输入大于3的数字！&#x27;) .max(10, &#x27;请输入小于10的数字！&#x27;) .required(&#x27;频道不能为空！&#x27;) &#125;) const formik = useFormik(&#123; initialValues, onSubmit, validationSchema &#125;) // 省略代码若干...&#125;export default FormPage ‍ 模板代码的优化表单项上的表单模板太多要写一大堆value、onChange、onBlur，这些属性来做成受控组件。formik也可以使用props来解决这个问题。 123456789101112131415161718// 使用前&lt;input type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; value=&#123;formik.values.name&#125; onChange=&#123;formik.handleChange&#125; onBlur=&#123;formik.handleBlur&#125; placeholder=&#x27;&#x27;/&gt;// 使用后&lt;input type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; &#123;...formik.getFieldProps(&#x27;name&#x27;)&#125;/&gt; 目前为止我们可以看到还是需要给表单、每个表单项写一些模板代码，来获取props。formik提供了一些组件来减少模板代码。 使用Formik、Form、Field、ErrorMessage，这四个组件来替换原来的一些属性标签。 可以看到代码从原来的86行减少到了56行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React from &#x27;react&#x27;import &#123; Formik, Form, Field, ErrorMessage &#125; from &#x27;formik&#x27;import * as Yup from &#x27;yup&#x27;import &#123; FormPageWrap &#125; from &#x27;./style&#x27;const FormPage = () =&gt; &#123; const initialValues = &#123; name: &#x27;&#x27;, email: &#x27;&#x27;, channel: &#x27;&#x27; &#125; const onSubmit = values =&gt; &#123; console.log(&#x27;values&#x27;, values) &#125; const validationSchema = Yup.object(&#123; name: Yup.string().required(&#x27;用户名不能为空！&#x27;), email: Yup.string().email(&#x27;请输入正确的邮箱格式！&#x27;).required(&#x27;邮箱不能为空！&#x27;), channel: Yup.number() .min(3, &#x27;请输入大于3的数字！&#x27;) .max(10, &#x27;请输入小于10的数字！&#x27;) .required(&#x27;频道不能为空！&#x27;) &#125;) return ( &lt;FormPageWrap&gt; &lt;Formik initialValues=&#123;initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125;&gt; &lt;div className=&#x27;page-container&#x27;&gt; &lt;Form&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;name&#x27;&gt;用户名&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; /&gt; &lt;ErrorMessage name=&#x27;name&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27;&gt;邮箱&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;form-input&#x27; /&gt; &lt;ErrorMessage name=&#x27;email&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;channel&#x27;&gt;频道&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;channel&#x27; className=&#x27;form-input&#x27; /&gt; &lt;ErrorMessage name=&#x27;channel&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item single&#x27;&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27;&gt; 提交 &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/div&gt; &lt;/Formik&gt; &lt;/FormPageWrap&gt; )&#125;export default FormPage 接下来看下单个组件的使用。 ‍ Field可以通过以下几种方式来渲染表单标签。 as可以渲染input、select、textarea、有效的HTML元素、自定义的React组件。 1234567&lt;Field as=&#x27;textarea&#x27; name=&#x27;comment&#x27; className=&#x27;form-textare&#x27;/&gt;// &lt;textarea name=&quot;comment&quot; class=&quot;form-textarea&quot;&gt;&lt;/textarea&gt; children的方式渲染组件。这种跟最开始的直接在表单标签上编写代码一样了。可以处理一些自定义的组件。 12345678910&lt;Field name=&#x27;address&#x27;&gt; &#123;(&#123; field, meta, form &#125;) =&gt; &#123; return ( &lt;&gt; &lt;input type=&#x27;text&#x27; className=&#x27;form-input&#x27; placeholder=&#x27;&#x27; &#123;...field&#125; /&gt; &#123;meta.touched &amp;&amp; meta.error &amp;&amp; &lt;div className=&#x27;error&#x27;&gt;&#123;meta.error&#125;&lt;/div&gt;&#125; &lt;/&gt; ) &#125;&#125;&lt;/Field&gt; component的方式渲染input、select、textarea、自定义的React组件。 1234&lt;Field component=&#x27;select&#x27; name=&#x27;gender&#x27; className=&#x27;form-input&#x27;&gt; &lt;option value=&#x27;男&#x27;&gt;男&lt;/option&gt; &lt;option value=&#x27;女&#x27;&gt;女&lt;/option&gt;&lt;/Field&gt; ‍ ErrorMessage和Field组件类似，也可以通过标签、组件、子组件的方式来渲染。让我们一起看下。 children的方式渲染。 123&lt;ErrorMessage name=&#x27;name&#x27;&gt; &#123;msg =&gt; &lt;div className=&#x27;form-error&#x27;&gt;&#123;msg&#125;&lt;/div&gt;&#125;&lt;/ErrorMessage&gt; ‍ render方式渲染，和children基本类似，就是一个放在单标签组件里面，一个放在双标签里面的区别。 1234&lt;ErrorMessage name=&#x27;email&#x27; render=&#123;msg =&gt; &lt;div className=&#x27;form-error&#x27;&gt;&#123;msg&#125;&lt;/div&gt;&#125;/&gt; ‍ component的方式渲染，可以用几种方式来实现。html标签、react组件、样式化的组件。 12345678910111213141516171819// html标签组件&lt;ErrorMessage component=&quot;span&quot; name=&quot;channel&quot; /&gt;// react组件const ErrorText = (&#123; children &#125;) =&gt; &#123; return &lt;div className=&#x27;form-error&#x27;&gt;&#123;children&#125;&lt;/div&gt;&#125;&lt;ErrorMessage name=&#x27;name&#x27; component=&#123;ErrorText&#125; /&gt;// 样式化组件export const ErrorTag = styled.div` display: flex; justify-content: flex-start; align-items: center; height: 40px; font-size: 14px; color: red;`&lt;ErrorMessage name=&#x27;comment&#x27; component=&#123;ErrorTag&#125; /&gt; ‍ 说完组件用法，我们再看看提交数据的对象和数组形式。 ‍ 对象数据一些我们需要做组合的数据，比如：需要提交一组社交账号，都是社交账号，那么就可以放到对象中做成一组。 1234567891011121314151617// 初始值const initialValues = &#123; social: &#123; facebook: &#x27;&#x27;, twttier: &#x27;&#x27; &#125;, &#125;// 组件 可以使用对象方式的name&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;facebook&#x27;&gt;FaceBook Account&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;social.facebook&#x27; className=&#x27;form-input&#x27; /&gt;&lt;/div&gt;&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;twttier&#x27;&gt;Twttier Account&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;social.twttier&#x27; className=&#x27;form-input&#x27; /&gt;&lt;/div&gt; ‍ 数组数据数组的数据组合，比较多用于一个字段的多个值。比如：完整的电话，可以有国家号码+区号+电话号码。 1234567891011121314// 初始值const initialValues = &#123; phone: [&#x27;&#x27;, &#x27;&#x27;]&#125;// 组件&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;phone[0]&#x27;&gt;区号&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;phone[0]&#x27; className=&#x27;form-input&#x27; /&gt;&lt;/div&gt;&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;phone[1]&#x27;&gt;电话号码&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;phone[1]&#x27; className=&#x27;form-input&#x27; /&gt;&lt;/div&gt; ‍ FieldArray这个是用来做数组列表的组件。比如添加一组货币、一组电话等，组件提供了很多方法可以用来对组件中的子组件进行操作。 123456789101112131415161718192021222324import &#123; Formik, Form, Field, ErrorMessage, FieldArray &#125; from &#x27;formik&#x27;// 初始值const initialValues = &#123; phoneList: [&#x27;&#x27;]&#125;// 组件&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;phoneList&#x27;&gt;电话列表&lt;/label&gt; &lt;FieldArray name=&#x27;phoneList&#x27;&gt; &#123;(&#123; push, remove, form: &#123; values: &#123; phoneList &#125; &#125; &#125;) =&gt; （ &lt;div&gt; &#123;phoneList.map((phone, index) =&gt; ( &lt;div key=&#123;index&#125;&gt; &lt;Field name=&#123;`phoneList[$&#123;index&#125;]`&#125; /&gt; &#123;index &gt; 0 &amp;&amp; ( &lt;button type=&#x27;button&#x27; onClick=&#123;() =&gt; remove(index)&#125;&gt; - &lt;/button&gt; )&#125; // 当只有一组时，不显示删除 &lt;button type=&#x27;button&#x27; onClick=&#123;() =&gt; push(&#x27;&#x27;)&#125;&gt; + &lt;/button&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; ）&#125; &lt;/FieldArray&gt;&lt;/div&gt; 注意： &lt;Field name=&#123;phoneList[${index}]&#125; /&gt;这里是使用了解构出来的phoneList。 ‍ FastField这个组件是一个优化组件，官方说如果有二三十个表单项时可以使用。Field组件都是受控组件，在表单项中输入任何内容都会更新。但FastField做了优化，在组件表单项输入内容不会立即更新，但在输入其他表单项时，才会更新表单项的内容。官方文档还说了一些限制条件，没看的太明白，应该是说如果在没受到其他表单项状态影响下才能使用。 12345678910111213141516171819202122232425262728import &#123; Formik, Form, Field, ErrorMessage, FastField &#125; from &#x27;formik&#x27;// 初始值const initialValues = &#123; address: &#x27;&#x27;&#125;// 错误提示const validationSchema = Yup.object(&#123; address: Yup.string().required(&#x27;地址不能为空！&#x27;)&#125;)// 组件&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;address&#x27;&gt;地址&lt;/label&gt; &lt;FastField name=&#x27;address&#x27;&gt; &#123;(&#123; field, meta, form &#125;) =&gt; &#123; console.log(&#x27;field render&#x27;) return ( &lt;&gt; &lt;input type=&#x27;text&#x27; className=&#x27;form-input&#x27; placeholder=&#x27;&#x27; &#123;...field&#125; /&gt; &#123;meta.touched &amp;&amp; meta.error &amp;&amp; &lt;div className=&#x27;error&#x27;&gt;&#123;meta.error&#125;&lt;/div&gt;&#125; &lt;/&gt; ) &#125;&#125; &lt;/FastField&gt; &lt;ErrorMessage name=&#x27;comment&#x27; /&gt;&lt;/div&gt; ‍ 何时发生验证？可以根据需要修改值和props来控制Formik运行验证的时机。可以使用validateOnChange和validateOnBlur来进行验证。 在发生onChange事件或方法之后 handleChange setFieldValue setValues 在发送onBlur事件或方法之后 handleBlur setTouched setFieldTouched 当进行提交时 validateForm validateField ‍ 字段级的验证可以通过自定义一个验证方法vaildate，传递给字段进行验证。 1234567891011121314151617181920// 初始值const initialValues = &#123; comment: &#x27;&#x27;&#125;// 自定义验证方法const validateComment = value =&gt; &#123; let error if (!value) &#123; error = &#x27;请输入评论~~~&#x27; &#125; return error&#125;// 使用validate接收自定义验证方法&lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;comment&#x27;&gt;评论&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;comment&#x27; className=&#x27;form-input&#x27; validate=&#123;validateComment&#125; /&gt; &lt;ErrorMessage name=&#x27;comment&#x27; component=&#123;ErrorText&#125; /&gt;&lt;/div&gt; ‍ 手动触发验证将表单结构调整下，从而可以通过Formik的porps获取到对应的验证方法。 将原来的Form标签放到一个方法中，通过props传递fomik方法，我们可以打印出fomik上的各种方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;Formik initialValues=&#123;initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125;&gt; &#123;formik =&gt; &#123; console.log(&#x27;formik&#x27;, formik) return ( &lt;div className=&#x27;page-container&#x27;&gt; &lt;Form&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;name&#x27;&gt;用户名&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;name&#x27; className=&#x27;form-input&#x27; /&gt; &lt;ErrorMessage name=&#x27;name&#x27; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;email&#x27;&gt;邮箱&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;form-input&#x27; /&gt; &lt;ErrorMessage name=&#x27;email&#x27; component=&#123;ErrorTag&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;channel&#x27;&gt;频道&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;channel&#x27; className=&#x27;form-input&#x27; /&gt; &lt;ErrorMessage name=&#x27;channel&#x27; render=&#123;msg =&gt; &lt;div className=&#x27;form-error&#x27;&gt;&#123;msg&#125;&lt;/div&gt;&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;label htmlFor=&#x27;comment&#x27;&gt;评论&lt;/label&gt; &lt;Field type=&#x27;text&#x27; name=&#x27;comment&#x27; className=&#x27;form-input&#x27; validate=&#123;validateComment&#125; /&gt; &lt;ErrorMessage name=&#x27;comment&#x27; component=&#123;ErrorText&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item single&#x27;&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27;&gt; 提交 &lt;/button&gt; &lt;button type=&#x27;button&#x27; className=&#x27;form-btn&#x27; onClick=&#123;() =&gt; formik.setFieldTouched(&#x27;comment&#x27;)&#125; &gt; 查看评论 &lt;/button&gt; &lt;button type=&#x27;button&#x27; className=&#x27;form-btn&#x27; onClick=&#123;() =&gt; formik.setTouched(&#123; name: true, email: true, channel: true, comment: true &#125;) &#125; &gt; 查看全部表单 &lt;/button&gt; &lt;button type=&#x27;button&#x27; className=&#x27;form-btn&#x27; onClick=&#123;() =&gt; formik.validateField(&#x27;comment&#x27;)&#125; &gt; 验证评论 &lt;/button&gt; &lt;button type=&#x27;button&#x27; className=&#x27;form-btn&#x27; onClick=&#123;() =&gt; formik.validateForm()&#125;&gt; 验证全部表单 &lt;/button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/div&gt; ) &#125;&#125;&lt;/Formik&gt; 通过validateField和validateForm可以获取到在表单上验证的错误信息。但是由于表单之前设置了需要touched才会在界面上现实出来，通过这两个方法，我们只能在调试模式下打印出错误信息。并不会在页面上现实错误。 通过setFieldTouched和setTouched我们通过触发touched方法可以查看到表单上的错误情况。 ‍ 禁用提交按钮的三个场景？场景一需要通过所有验证规则后才可激活提交按钮，否则是禁用的。 ‍ 给提交按钮传递一个方法进行disabled的验证，如果未通过验证，则为ture，通过则为false。 需要给Formik上增加validateOnMount属性。 设置disabled=&#123;!formik.isValid&#125;，isValid表示是否验证。 12345&lt;Formik ... validateOnMount&gt; &lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27; disabled=&#123;!formik.isValid&#125;&gt; 提交 &lt;/button&gt;&lt;/Formik&gt; ‍ 场景二当填写的数据与初始数据相比没有变化，则禁用，有修改才能激活提交按钮。 ‍ 通过dirty与isValid​来进行判断。 dirty方法，是通过与初始值进行判断，是否对初始值做出了更改，如果有更改则为true没有更改则为false。 dirty​方法不需要设置Formik上的validateOnMount。 但是dirty有个小问题，就是当如果初始值都是有内容且符合验证条件的时候，这个时候它仍然会为false，造成表单无法提交。 1234567&lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27; disabled=&#123;!(formik.dirty &amp;&amp; formik.isValid)&#125;&gt; 提交&lt;/button&gt; ‍ 场景三当提交后需要等待API返回消息后才允许再次提交，所以当通过验证提交后，就需要禁用提交按钮，等待API 返回后设置再次激活按钮才可提交。 ‍ 当遇到此场景，需要使用onSubmitProps中的setSubmitting方法设置formik中的isSubmitting。 1234567891011121314151617// 提交方法 3秒后设置提交按钮激活const onSubmit = (values, onSubmitProps) =&gt; &#123; console.log(&#x27;values&#x27;, values) console.log(&#x27;onSubmitProps&#x27;, onSubmitProps) setInterval(() =&gt; &#123; onSubmitProps.setSubmitting(false) &#125;, 3000)&#125;// 提交按钮需通过验证，或返回isSubmitting的值才能激活&lt;button type=&#x27;submit&#x27; className=&#x27;form-btn&#x27; disabled=&#123;!formik.isValid || formik.isSubmitting&#125;&gt; 提交&lt;/button&gt; ‍ 修改表单初始值当需要给表单做示例，比如需要API文档中示例需要填写哪些字段值才能获取到数据，就可以加载示例值然后发起请求，查看返回结果。 设置修改的示例值 添加useState一个设置方法const [formValues, setFormValues] = useState(null)​，修改初始值。 修改Formik标签中的初始值initialValues=&#123;formValues || initialValues&#125;允许使用formValues或者initialValues。 并且在Formik上设置enableReinitialize允许修改初始值。 最后在按钮上添加点击事件，修改初始值。 注意需要将设置的值放到组件函数之外，否则会触发验证效果。 123456789101112131415161718192021222324252627// 设置修改的示例值const savedValues = &#123; name: &#x27;jacky&#x27;, email: &#x27;jacky@tom.com&#x27;, channel: &#x27;5&#x27;, comment: &#x27;Good jobs&#x27;&#125;// 使用useState设置一个修改方法，传递修改的示例值const FormPage = () =&gt; &#123; const [formValues, setFormValues] = useState(null) return ( &lt;FormPageWrap&gt; &lt;Formik initialValues=&#123;formValues || initialValues&#125; validationSchema=&#123;validationSchema&#125; onSubmit=&#123;onSubmit&#125; enableReinitialize &gt; ... &lt;button className=&#x27;form-btn&#x27; onClick=&#123;() =&gt; setFormValues(savedValues)&#125;&gt; 载入表单数据 &lt;/button&gt; &lt;/Formik&gt; &lt;/FormPageWrap&gt; )&#125; ‍ 清空表单有两种方法，通过html中类型为reset的按钮，和通过Formik中onSubmitProps的resetForm方法。 前面这种很简单不做详细说明。 看下后面的方法代码也很简单。 在提交后3秒重新激活提交按钮，并清空表单。 12345678const onSubmit = (values, onSubmitProps) =&gt; &#123; console.log(&#x27;values&#x27;, values) console.log(&#x27;onSubmitProps&#x27;, onSubmitProps) setInterval(() =&gt; &#123; onSubmitProps.setSubmitting(false) onSubmitProps.resetForm() &#125;, 3000)&#125; ‍","permalink":"http://example.com/2022/10/18/Formik%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"strapi","slug":"strapi","permalink":"http://example.com/tags/strapi/"}],"title":"Strapi用户登录鉴权","date":"2022/10/12","text":"延续之前Strapi的使用，Strapi已经做了很完整的权限，并且给了API，所以结合之前的博客内容，完成对应的登录、注册与鉴权。 之前博客在公共模式Public下是可以直接访问到对应的文章，这次我们取消Public的find和findone的权限。并给Authenticated配置对应的Post权限。在Strapi中调整完成后开始代码。 ‍ 技术栈：Valtio作为状态库。一个简单好用的玩意。 Axios作为请求工具。后续会对其进行封装。 React-query结合axios作为数据请求库。 Vite作为构建工具，并使用vite-pretty-lint快速配置ESLint和Prettier。 Styled-components作为Css In JS的样式工具。 Styled-normalize做样式初始化。 React-router-dom是路由工具。 Dayjs作为日期格式化工具。 Polished是一个对Styled-components样式加强的工具。从一个外国大佬的视频里看到的，Cool~本文并未提到。 ‍ 项目很小，用到的东西也不多。 ‍ 代码部分App12345678910111213141516171819202122232425262728// src/App.jsimport React from &#x27;react&#x27;import &#123; BrowserRouter, Routes, Route &#125; from &#x27;react-router-dom&#x27;import &#123; QueryClient, QueryClientProvider &#125; from &#x27;@tanstack/react-query&#x27;import RootRouter from &#x27;@/router&#x27;import RootStyle from &#x27;@/styles/base.style&#x27;import useAutoLogout from &#x27;@/hooks/useAutoLogout&#x27;import Layout from &#x27;@/components/Layout&#x27;const queryClient = new QueryClient() //初始化react-query的配置const App = () =&gt; &#123; useAutoLogout() return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;BrowserRouter&gt; &lt;RootStyle /&gt; &lt;Layout&gt; &lt;RootRouter /&gt; &lt;/Layout&gt; &lt;/BrowserRouter&gt; &lt;/QueryClientProvider&gt; )&#125;export default App ‍ Router由于之前使用了标签包裹进行路由鉴权，一直报hooks错误，一度没敢用这个编程式的路由，改成了写在App.js中的页面路由。后面改回去试了下又没有错误了。还是改了回来。 注意这里的坑，看到文件名称是使用了jsx没，因为用了组件标签，如果不使用jsx这里会报错。如果后面改成懒加载这里可以使用js后缀没问题。 12345678910111213141516171819202122232425262728293031323334353637383940// src/router/index.jsximport &#123; useRoutes &#125; from &#x27;react-router-dom&#x27;import CheckAuth from &#x27;@/components/CheckAuth&#x27;import Home from &#x27;@/pages/Home&#x27;import Profile from &#x27;@/pages/Profile&#x27;import Posts from &#x27;@/pages/Posts&#x27;import Login from &#x27;@/pages/Login&#x27;import Register from &#x27;@/pages/Register&#x27;const routes = [ &#123; path: &#x27;/&#x27;, element: &lt;Home /&gt; &#125;, &#123; path: &#x27;/profile&#x27;, element: ( &lt;CheckAuth&gt; &lt;Profile /&gt; &lt;/CheckAuth&gt; ) &#125;, &#123; path: &#x27;/posts&#x27;, element: ( &lt;CheckAuth&gt; &lt;Posts /&gt; &lt;/CheckAuth&gt; ) &#125;, &#123; path: &#x27;/register&#x27;, element: &lt;Register /&gt; &#125;, &#123; path: &#x27;/login&#x27;, element: &lt;Login /&gt; &#125;]const RootRouter = () =&gt; &#123; const router = useRoutes(routes) return router&#125;export default RootRouter 另外，这里使用了一个CheckAuth的路由鉴权组件。 ‍ CheckAuth12345678910111213141516171819import React from &#x27;react&#x27;import &#123; Navigate, useLocation &#125; from &#x27;react-router-dom&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; authState &#125; from &#x27;@/store&#x27;const CheckAuth = props =&gt; &#123; const snap = useSnapshot(authState) const pathname = useLocation().pathname const isToken = localStorage.getItem(&#x27;token&#x27;) return snap.isLogin &amp;&amp; isToken ? ( props.children ) : ( &lt;Navigate to=&#x27;/login&#x27; state=&#123;&#123; preLocation: pathname &#125;&#125; replace /&gt; )&#125;export default CheckAuth 这里使用isLogin是否为true和isToken是否获取到了localstorage中的token作为判断，如果都为true则可以访问后面的children子组件。如果没有访问到则会跳转到登录。 另外这里做了一个路径记录，Navigate中的state将当前路径记录，并传递给下个路由。如果登录成功，则会跳回到之前的路径。这里有点拗口，简单说就是，如果是从首页登录的登录后跳回首页。如果从用户信息页面访问因为没有权限调到了登录，登录后又会跳回到用户信息。 ‍ Headerheader这里主要做了三个功能。 根据是否登录获取到用户名称，并显示。 根据是否登录判断显示菜单。 调用store里的方法，登出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// src/components/Header/index.jsximport React from &#x27;react&#x27;import &#123; NavLink, useNavigate &#125; from &#x27;react-router-dom&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; authState, authAction &#125; from &#x27;@/store&#x27;import Maybe from &#x27;@/components/Maybe&#x27;import &#123; HeaderWrap &#125; from &#x27;./style&#x27;const Header = () =&gt; &#123; const snap = useSnapshot(authState) const navigate = useNavigate() const handleLogout = () =&gt; &#123; authAction.logout() navigate(&#x27;/&#x27;) &#125; return ( &lt;HeaderWrap&gt; &lt;nav className=&#x27;navs-block&#x27;&gt; &lt;NavLink to=&#x27;/&#x27; className=&#x27;nav-item&#x27;&gt; 首页 &lt;/NavLink&gt; &lt;Maybe state=&#123;snap.isLogin&#125;&gt; &lt;NavLink to=&#x27;/profile&#x27; className=&#x27;nav-item&#x27;&gt; 用户信息 &lt;/NavLink&gt; &lt;NavLink to=&#x27;/posts&#x27; className=&#x27;nav-item&#x27;&gt; 博客 &lt;/NavLink&gt; &lt;span className=&#x27;nav-item&#x27; onClick=&#123;handleLogout&#125;&gt; 登出 &lt;/span&gt; &lt;/Maybe&gt; &lt;Maybe state=&#123;!snap.isLogin&#125;&gt; &lt;NavLink to=&#x27;/login&#x27; className=&#x27;nav-item&#x27;&gt; 登录 &lt;/NavLink&gt; &lt;NavLink to=&#x27;/register&#x27; className=&#x27;nav-item&#x27;&gt; 注册 &lt;/NavLink&gt; &lt;/Maybe&gt; &lt;/nav&gt; &lt;div className=&#x27;userinfo-block&#x27;&gt; &lt;Maybe state=&#123;snap.isLogin&#125;&gt;&#123;snap.user.username&#125;&lt;/Maybe&gt; &lt;/div&gt; &lt;/HeaderWrap&gt; )&#125;export default Header 这里有借鉴看到国外大佬的方法做的一个小组件Maybe，这个通过state来判断是否显示子组件。同前面的鉴权组件有点类似，这个更简单直接一点通过状态来进行判断。 ‍ Maybe123456789// src/components/Maybe/index.jsximport React from &#x27;react&#x27;const Maybe = (&#123; state, children &#125;) =&gt; &#123; return &lt;&gt;&#123;state ? children : null&#125;&lt;/&gt;&#125;export default Maybe ‍ fetcher这个是用axios进行封装的请求方法。是这次我学习的主要关键点部分 通过请求拦截，给headers中的Authorization注入token，进行标识。 通过响应拦截，获取服务器传递过来的错误，并抛出，提供给react-query。 这里在查找资料时还看到应该有在响应代码为403时，要重新刷新token这次并没有做。 1234567891011121314151617181920212223242526272829303132333435// src/service/fetcher.jsimport axios from &#x27;axios&#x27;const createInstence = () =&gt; &#123; const instence = axios.create(&#123; baseURL: &#x27;http://localhost:1337/api&#x27;, timeout: 50000 &#125;) instence.interceptors.request.use(handleToken) instence.interceptors.response.use(handleResponse, handleError) return instence&#125;const handleToken = config =&gt; &#123; const token = localStorage.getItem(&#x27;token&#x27;) if (token) &#123; config.headers.Authorization = `Bearer $&#123;token&#125;` &#125; return config&#125;const handleResponse = response =&gt; &#123; return response.data&#125;const handleError = error =&gt; &#123; const &#123; message, response &#125; = error return Promise.reject(response ? response.data.error.message || message : error)&#125;const fetcher = createInstence()export default fetcher 注意handleError中的response.data.error.message结构，这个是strapi返回的错误消息。 ‍ apis这个是向strapi发起的请求。 12345678910111213141516171819202122232425262728293031323334// src/service/apis.jsimport fetcher from &#x27;./fetcher&#x27;const postRegister = async user =&gt; &#123; const response = await fetcher(&#123; method: &#x27;POST&#x27;, url: &#x27;/auth/local/register&#x27;, data: &#123; ...user &#125; &#125;) return response&#125;const postLogin = async user =&gt; &#123; const response = await fetcher(&#123; method: &#x27;POST&#x27;, url: &#x27;/auth/local&#x27;, data: &#123; ...user &#125; &#125;) return response&#125;const getPosts = async () =&gt; &#123; const response = await fetcher(&#123; url: &#x27;/posts&#x27; &#125;) return response.data&#125;export default &#123; postRegister, postLogin, getPosts&#125; ‍ store这个是本次的关键点。可以看到对比redux和mobx一对的模板代码这个valtio简洁太多。 先获取下token，看token是否存在，通过token来进行判断初始值。 因为strapi传过来的user信息是一个对象，所以需要进行序列化转成json放到localstorage。 然后封装两个方法。 login时，通过state传入登录后获取到的token和user信息，并将对应的信息存入localstorage。 记录登录的时间currentTime，与设置的到期时间进行相加得到token过期时间expirationTime保存到localstorage。在app.js中有一个useAutoLogout的hooks，通过这个来进行判断是否到期登出。最后再来说这个钩子函数。 logout时，清空store的初始值，清空localstorage中的内容。 1234567891011121314151617181920212223242526272829303132333435363738// src/store/index.jsimport &#123; proxy &#125; from &#x27;valtio&#x27;const token = localStorage.getItem(&#x27;token&#x27;)export const authState = proxy(&#123; isLogin: token ? true : false, token: token ? token : null, user: token ? JSON.parse(localStorage.getItem(&#x27;user&#x27;)) : &#123;&#125;, expirationTime: token ? Number(localStorage.getItem(&#x27;expirationTime&#x27;)) : 0 // 登录状态失效时间&#125;)export const authAction = &#123; login: state =&gt; &#123; authState.isLogin = true authState.token = state.token authState.user = state.user const currentTime = Date.now() // 当前时间 const timetout = 1000 * 60 * 60 * 24 * 7 // 有效时间 一周 authState.expirationTime = currentTime + timetout //设置失效日期 一周后失效 localStorage.setItem(&#x27;token&#x27;, state.token) localStorage.setItem(&#x27;user&#x27;, JSON.stringify(state.user)) localStorage.setItem(&#x27;expirationTime&#x27;, Number(authState.expirationTime)) &#125;, logout: state =&gt; &#123; authState.isLogin = false authState.token = null authState.user = [] authState.expirationTime = 0 localStorage.removeItem(&#x27;token&#x27;) localStorage.removeItem(&#x27;user&#x27;) localStorage.removeItem(&#x27;expirationTime&#x27;) &#125;&#125; ‍ register注册，这个相对于登录比较简单，只是将用户信息提交给strapi，如果有错误strapi就会返回过来。 通过ref获取到表单信息，这里不是受控组件了。受控组件比较麻烦，需要做防抖。否则就需要装一些包来处理抖动的问题。 通过react-query来处理表单提交的状态，并在成功后返回提示，设置登出后跳转路由。如果注册错误则返回错误信息。 通过绑定在表单上的onSubmit的handleSubmit来提交表单信息，将获取到的表单内容传递给react-query的useMutation中的一个方法，这个方法将用户信息传递给api。api里会结构用户信息传递给strapi。 由于没有用UI库，仅对返回的错误和成功的消息做了简单的样式区分和固定显示位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// src/pages/Register/index.jsximport React, &#123; useRef, useState &#125; from &#x27;react&#x27;import &#123; Link, useNavigate &#125; from &#x27;react-router-dom&#x27;import &#123; useMutation &#125; from &#x27;@tanstack/react-query&#x27;import Apis from &#x27;@/service/apis&#x27;import &#123; RegisterWrap &#125; from &#x27;./style&#x27;const Register = () =&gt; &#123; const usernameRef = useRef() const passwordRef = useRef() const emailRef = useRef() const navigate = useNavigate() const [registerMessage, setRegisterMessage] = useState(&#x27;&#x27;) const &#123; mutate, isLoading, isError, isSuccess &#125; = useMutation([&#x27;register&#x27;], Apis.postRegister, &#123; onSuccess: data =&gt; &#123; setRegisterMessage(&#x27;注册成功&#x27;) setInterval(() =&gt; &#123; navigate(&#x27;/login&#x27;) &#125;, 3000) &#125;, onError: error =&gt; &#123; setRegisterMessage(error) &#125; &#125;) const handleSubmit = e =&gt; &#123; e.preventDefault() const username = usernameRef.current.value const password = passwordRef.current.value const email = emailRef.current.value const user = &#123; username, password, email &#125; mutate(user) &#125; return ( &lt;&gt; &#123;isError &amp;&amp; ( &lt;div className=&#x27;message-box error&#x27;&gt; &lt;span&gt;&#123;registerMessage&#125;&lt;/span&gt; &lt;/div&gt; )&#125; &#123;isSuccess &amp;&amp; ( &lt;div className=&#x27;message-box&#x27;&gt; &lt;span&gt;&#123;registerMessage&#125;&lt;/span&gt; &lt;/div&gt; )&#125; &lt;RegisterWrap&gt; &lt;div className=&#x27;form-titlebar&#x27;&gt; &lt;h2&gt;注册 &lt;/h2&gt; &lt;Link to=&#x27;/login&#x27; className=&#x27;form-titlebar-link&#x27;&gt; 有账号，去登录 &lt;/Link&gt; &lt;/div&gt; &lt;form className=&#x27;form-block&#x27; onSubmit=&#123;handleSubmit&#125;&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27; className=&#x27;form-input&#x27; ref=&#123;usernameRef&#125; placeholder=&#x27;请输入用户名&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;input type=&#x27;text&#x27; name=&#x27;email&#x27; className=&#x27;form-input&#x27; ref=&#123;emailRef&#125; placeholder=&#x27;请输入邮箱&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27; className=&#x27;form-input&#x27; ref=&#123;passwordRef&#125; placeholder=&#x27;请输入密码&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;button className=&#x27;form-btn&#x27;&gt;&#123;isLoading ? &#x27;注册中...&#x27; : &#x27;注册&#x27;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/RegisterWrap&gt; &lt;/&gt; )&#125;export default Register ‍ login这里其实和register的差不多，只是有个坑。 在注册时，表单项有三个，username、email和password，登录的时候strapi可以使用username或email进行登录，所以这里的表单项字段名称改成了identifier，所以需要把username表单项的内容传给这个字段。 这里在登录后通过handleSubmit方法，将表单信息传递给react-query的useMutation中。 在成功后，需要使用store中的login方法，将数据保存到store中的对应字段。这里有个坑，strapi给的user信息，是一个对象，需要解构后存入store的user中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// src/pages/Login/index.jsximport React, &#123; useRef, useState &#125; from &#x27;react&#x27;import &#123; Link, useNavigate, useLocation &#125; from &#x27;react-router-dom&#x27;import &#123; useMutation &#125; from &#x27;@tanstack/react-query&#x27;import Apis from &#x27;@/service/apis&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; authState, authAction &#125; from &#x27;@/store&#x27;import &#123; LoginWrap &#125; from &#x27;./style&#x27;const Login = () =&gt; &#123; const usernameRef = useRef(null) const passwordRef = useRef(null) const navigate = useNavigate() const location = useLocation() console.log() const [loginMessage, setLoginMessage] = useState(&#x27;&#x27;) const snap = useSnapshot(authState) const &#123; data, isLoading, isError, isSuccess, mutate &#125; = useMutation([&#x27;login&#x27;], Apis.postLogin, &#123; onSuccess: data =&gt; &#123; authAction.login(&#123; token: data.jwt, user: &#123; ...data.user &#125; &#125;) setLoginMessage(&#x27;登录成功&#x27;) navigate(location.state?.preLocation || &#x27;/&#x27;) &#125;, onError: error =&gt; &#123; setLoginMessage(error) &#125; &#125;) const handleSubmit = e =&gt; &#123; e.preventDefault() const identifier = usernameRef.current.value const password = passwordRef.current.value const user = &#123; identifier, password &#125; mutate(user) &#125; return ( &lt;&gt; &#123;isError &amp;&amp; ( &lt;div className=&#x27;message-box error&#x27;&gt; &lt;span&gt;&#123;loginMessage&#125;&lt;/span&gt; &lt;/div&gt; )&#125; &#123;isSuccess &amp;&amp; ( &lt;div className=&#x27;message-box&#x27;&gt; &lt;span&gt;&#123;loginMessage&#125;&lt;/span&gt; &lt;/div&gt; )&#125; &lt;LoginWrap&gt; &lt;div className=&#x27;form-titlebar&#x27;&gt; &lt;h2&gt;登录 &lt;/h2&gt; &lt;Link to=&#x27;/register&#x27; className=&#x27;form-titlebar-link&#x27;&gt; 没有账号，去注册 &lt;/Link&gt; &lt;/div&gt; &lt;form className=&#x27;form-block&#x27; onSubmit=&#123;handleSubmit&#125;&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27; className=&#x27;form-input&#x27; ref=&#123;usernameRef&#125; placeholder=&#x27;请输入用户名&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27; className=&#x27;form-input&#x27; ref=&#123;passwordRef&#125; placeholder=&#x27;请输入密码&#x27; /&gt; &lt;/div&gt; &lt;div className=&#x27;form-item&#x27;&gt; &lt;button className=&#x27;form-btn&#x27;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/LoginWrap&gt; &lt;/&gt; )&#125;export default Login ‍ 剩下的Posts、Profile、Home页面就不说明了，只是权限上的区分。Posts、Profile页面是需要登录权限的。Home是没有权限的。因为已经做了路由鉴权并且在strapi中做了权限设置，基本实现了整个鉴权的过程。 ‍ useAutoLogout最后来看下自动到期的useAutoLogout，这个本身不算是一个真正的钩子，只是一个到期函数。 获取到store中的 expirationTIme，减去 当前时间，得到剩余有效时间，通过这个与一个阈值(1分钟 ：6000ms)进行判断。 如果小于1分钟则直接登出，如果到期登出。 1234567891011121314151617181920212223242526import React, &#123; useEffect &#125; from &#x27;react&#x27;import &#123; useSnapshot &#125; from &#x27;valtio&#x27;import &#123; authState, authAction &#125; from &#x27;@/store&#x27;const useAutoLogout = () =&gt; &#123; const snap = useSnapshot(authState) useEffect(() =&gt; &#123; const timeout = snap.expirationTime - Date.now() //到期时间 - 当前时间 = 剩余有效时间 if (timeout &lt; 6000) &#123; authAction.logout() //如果剩余有效时间小于1分钟，直接登出 return &#125; const timer = setTimeout(() =&gt; &#123; authAction.logout() // 到期时间后，登出 &#125;, timeout) return () =&gt; &#123; clearTimeout(timer) &#125; &#125;, [snap.expirationTime])&#125;export default useAutoLogout ‍ 总结以上介绍完了本次的学习内容。但很多都是浅尝辄止，比如axios的封装就没有很详尽，小项目差不多了，大项目还是需要考虑更多。 后续会先总结下react-query，然后结合strapi来做一个项目完整的操作下。 ‍ ‍","permalink":"http://example.com/2022/10/12/Strapi%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"strapi","slug":"strapi","permalink":"http://example.com/tags/strapi/"},{"name":"graphQL","slug":"graphQL","permalink":"http://example.com/tags/graphQL/"}],"title":"Strapi + Graphql 使用小记","date":"2022/10/08","text":"NextJs已经学了，需要搞个项目练下手，看到油管上很多NextJs+Strapi的视频，因为之前也看过相关的视频，但没有仔细研究，这次刚好十一，抓紧时间看了下。Strapi还是个很犀利的工具，感觉后面可以多用这个来做些东西。 安装项目初始化使用pnpm来安装strapi到项目react-strapi的backend目录。使用pnpm安装后，下次再安装strapi的项目速度会快很多。 12// 格式：pnpm create strapi-app [目录] --quickstartpnpm create strapi-app backend --quickstart 安装完成之后会进入到添加管理员的页面。填写完管理员信息，进入到strapi系统后台。此时页面上所有内容都是英文。可以修改相应的文件，选择到对应的界面语言为中文。 ‍ 中文化 首先在终端取消项目运行。 在backend &gt; src &gt; admin目录下找到app-example.js文件，复制一个备用。 修改app-example.js文件名称，为app.js。 然后打开文件，修改config。删除其他的语言，仅保留zh-Hans。 1234567// backend/src/admin/app.jsconst config = &#123; locales: [ &#x27;zh-Hans&#x27;, ],&#125;; 保存后，回到backend根目录。在终端运行pnpm build重新构建一个。 构建完毕后，运行pnpm dev进入到开发环境后台。 在左侧底部用户信息区域，点击用户名，在弹出的菜单中点击Profile进入用户信息设置中，在Experience中选择Interface language下拉列表中的 中文，然后保存。界面就设置成中文了。 ‍ 添加模型strapi是个无头内容管理系统，需要先创建内容模型。 在模型构建器中的集合类型下点击创建一个 Content Type按钮。添加一个表。 在添加表名时，不需要使用复数形式，系统会自动根据情况添加。我们先创建一个Post的表。 然后添加表的字段，在字段弹窗中选择文本TEXT，然后填写字段名称。我们填写title，作为博客的名称，然后在高级Tabs标签页中选择，必填和唯一。 然后点击继续添加下一个自动按钮。添加一个富文本字段，字段名称body，作为博客的内容。然后再高级标签页中选择比必填。点击完成按钮。 然后在Post表下有两个字段。再点击右上角的保存按钮。系统会保存并重新加载。就可以在左侧栏的内容管理​菜单中看到刚添加对Post模块的名称了。 ‍ 配置权限strapi内容默认是受权限保护的，未配置权限，外部无法访问。所以需要我们配置数据权限。 ‍ 公共权限 Public 在侧栏的 设置中的角色列表中选择public角色。这个是公共角色，也就是所有公共用户都可以访问的角色。点击编辑图标。 在public角色详情中，权限中找到Post的权限配置。公共用户运行查看所有博客内容和单篇博客的内容。所以选择find和findone，两个权限。 在权限右侧，显示对应对api接口是什么。如：find的接口/api/post，模式是get。 点击保存，则可以放文到所有的博客文章和单篇博客详情了。 ‍ 已验证权限 Authenticated已验证，即为已登录的用户，已经验证过身份的用户权限。 配置方法同公共权限，一般已验证的用户配置增删改查的权限。配置完成后需要用户登录，获取jwt的token。 在User列表中添加一个新用户。选择该用户对角色为Authenticated。 然后通过/auth/local的api路径提交一个post，将添加的新用户用户名identifier和密码password提交到strapi。 然后将返回的jwt保存后，就可以访问到对应的权限。 ‍ 使用Graphql安装Strapi中的Graphql1pnpm strapi install graphql 安装完成后在浏览器中输入http://localhost:1337/graphql就可以访问到graphql的playground了。 不能到系统的市场中去复制那个graphql的命令去执行，否则会报错误，莫名其妙的搞了很久。 Get started with GraphQL - Strapi Developer Docs ‍ 我们可以通过graphql的playground来查询下之前的posts内容。 12345678910query GetPosts &#123; posts &#123; data &#123; attributes &#123; title, content &#125; &#125; &#125;&#125; 好像strapi4的graphql的查询不如之前的，层级变得多了。之前可以在posts之下直接查询到对应的字段。 通过查询语句可以查询到strapi中，我们之前录入的内容。 ‍ 配置项目中的Graphql接下来在前端项目中，安装apollo和graphql。 1pnpm add @apollo/client graphql 安装完成后，需要配置下。 12345678910111213141516171819202122232425// src/app.jsimport React from &#x27;react&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import &#123; ApolloClient, InMemoryCache, ApolloProvider &#125; from &#x27;@apollo/client&#x27;import RootRoutes from &#x27;@/router&#x27;import BaseStyle from &#x27;@/styles/base.style&#x27;const client = new ApolloClient(&#123; uri: &#x27;http://localhost:1337/graphql&#x27;, // graphql的服务器端点 cache: new InMemoryCache() // 缓存&#125;)const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;BaseStyle /&gt; &lt;RootRoutes /&gt; &lt;/ApolloProvider&gt; &lt;/BrowserRouter&gt; )&#125;export default App ‍ 在项目中使用Graphql‍ 列表数据查询先创建一个Graphql​的查询方法 123456789101112131415161718// src/service/gql.jsimport &#123; gql &#125; from &#x27;@apollo/client&#x27;export const GET_POSTS = gql` query GetPosts &#123; posts &#123; data &#123; id attributes &#123; title content updatedAt &#125; &#125; &#125; &#125;` 然后在到组件中引用apollo的查询钩子函数 12345678910111213141516171819202122232425262728293031323334// src/pages/Home/Posts/index.jsximport React from &#x27;react&#x27;import dayjs from &#x27;dayjs&#x27;import &#123; useQuery &#125; from &#x27;@apollo/client&#x27;import &#123; GET_POSTS &#125; from &#x27;@/service/gql&#x27;import &#123; PostsWrapper &#125; from &#x27;./style&#x27;const Posts = () =&gt; &#123; const &#123; data, loading, error &#125; = useQuery(GET_POSTS) if (loading) &lt;div&gt;加载中...&lt;/div&gt; if (error) &lt;div&gt;出错了 :(&lt;/div&gt; return ( &lt;PostsWrapper className=&#x27;page-wrap&#x27;&gt; &lt;div className=&#x27;page-container post-container&#x27;&gt; &lt;div className=&#x27;page-card post-card&#x27;&gt; &#123;data?.posts.data.map(post =&gt; ( &lt;div className=&#x27;post-block&#x27; key=&#123;post.id&#125;&gt; &lt;div className=&#x27;post-title&#x27;&gt;&#123;post.attributes.title&#125;&lt;/div&gt; &lt;div className=&#x27;post-date&#x27;&gt; &#123;dayjs(post.attributes.updatedAt).format(&#x27;YYYY-MM-DD hh:mm:ss&#x27;)&#125; &lt;/div&gt; &lt;div className=&#x27;post-description&#x27;&gt;&#123;post.attributes.content.substring(0, 200)&#125;&lt;/div&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/PostsWrapper&gt; )&#125;export default Posts 注意这里的数据查询后的data，如果需要map出来，结构需要按照gql中的结构层级posts/data。 ‍ 详情查询同样先创建查询方法 123456789101112131415161718// src/service/gql.jsimport &#123; gql &#125; from &#x27;@apollo/client&#x27;export const GET_POST_DETAIL = gql` query GetPostDetail($id: ID!) &#123; post(id: $id) &#123; data &#123; id attributes &#123; title content updatedAt &#125; &#125; &#125; &#125;` ‍ 然后引入查询，通过钩子加载对应ID的内容。 123456789101112131415161718192021222324252627282930313233343536373839// src/pages/Posts/PostDetail/index.jsximport React from &#x27;react&#x27;import &#123; useParams &#125; from &#x27;react-router-dom&#x27;import dayjs from &#x27;dayjs&#x27;import ReactMarkdown from &#x27;react-markdown&#x27;import &#123; useQuery &#125; from &#x27;@apollo/client&#x27;import &#123; GET_POST_DETAIL &#125; from &#x27;@/service/gql&#x27;import &#123; PostDetailWrapper &#125; from &#x27;./style&#x27;const PostDetail = () =&gt; &#123; const &#123; id &#125; = useParams() const &#123; data, loading, error &#125; = useQuery(GET_POST_DETAIL, &#123; variables: &#123; id: id &#125; &#125;) console.log(data) if (loading) &lt;div&gt;加载中...&lt;/div&gt; if (error) &lt;div&gt;出错了 :(&lt;/div&gt; return ( &lt;PostDetailWrapper className=&#x27;page-wrap&#x27;&gt; &lt;div className=&#x27;page-container post-detail-container&#x27;&gt; &lt;div className=&#x27;page-card post-detail-card&#x27;&gt; &lt;div className=&#x27;post-detail-title&#x27;&gt;&#123;data?.post.data.attributes.title&#125;&lt;/div&gt; &lt;div className=&#x27;post-detail-date&#x27;&gt; &#123;dayjs(data?.post.data.attributes.updatedAt).format(&#x27;YYYY-MM-DD hh:mm:ss&#x27;)&#125; &lt;/div&gt; &lt;ReactMarkdown className=&#x27;post-detail-content&#x27;&gt; &#123;data?.post.data.attributes.content&#125; &lt;/ReactMarkdown&gt; &lt;/div&gt; &lt;/div&gt; &lt;/PostDetailWrapper&gt; )&#125;export default PostDetail 同样需要注意引入的数据层级。 ‍ 分类查询同posts基本差不多 12345678910111213141516// src/service/gql.jsimport &#123; gql &#125; from &#x27;@apollo/client&#x27;export const GET_CATEGORY = gql` query GetCategory &#123; categories &#123; data &#123; id attributes &#123; name &#125; &#125; &#125; &#125;` 然后到Header组件。 12345678910111213141516171819202122232425262728293031323334// src/components/Layout/Header/index.jsximport React from &#x27;react&#x27;import &#123; NavLink &#125; from &#x27;react-router-dom&#x27;import &#123; useQuery &#125; from &#x27;@apollo/client&#x27;import &#123; GET_CATEGORY &#125; from &#x27;@/service/gql&#x27;import &#123; HeaderWrapper &#125; from &#x27;./style&#x27;const Header = () =&gt; &#123; const &#123; data, loading, error &#125; = useQuery(GET_CATEGORY) if (loading) &lt;div&gt;加载中...&lt;/div&gt; if (error) &lt;div&gt;出错了 :(&lt;/div&gt; return ( &lt;HeaderWrapper className=&#x27;page-wrap header-wrap&#x27;&gt; &lt;div className=&#x27;page-container header-container&#x27;&gt; &lt;div className=&#x27;logo-block&#x27;&gt;RealWorld&lt;/div&gt; &lt;ul className=&#x27;navs-block&#x27;&gt; &lt;NavLink to=&#x27;/posts&#x27; className=&#x27;nav-item&#x27;&gt; 首页 &lt;/NavLink&gt; &#123;data?.categories.data.map(cate =&gt; ( &lt;NavLink to=&#123;`/post-category/$&#123;cate.id&#125;`&#125; className=&#x27;nav-item&#x27; key=&#123;cate.id&#125;&gt; &#123;cate.attributes.name&#125; &lt;/NavLink&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/HeaderWrapper&gt; )&#125;export default Header ‍ 分类下列表查询这个也算是strapi的Graphql的设计巧妙之处吧。如果文章有分类，那么分类也会把文章添加过去，所以通过Graphql来查询，也可以查询到分类下级的文章。 1234567891011121314151617181920212223242526272829303132// src/service/gql.jsimport &#123; gql &#125; from &#x27;@apollo/client&#x27;export const GET_POST_CATEGORY = gql` query GetPostCategory($id: ID!) &#123; category(id: $id) &#123; data &#123; attributes &#123; name posts &#123; data &#123; id attributes &#123; title content categories &#123; data &#123; id attributes &#123; name &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;` 用法和详情差不多，也是通过id​来查询到对应的分类，然后再分类的data/attributes下可以查询到posts。 ‍ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/pages/PostCategory/index.jsximport React from &#x27;react&#x27;import &#123; useParams, Link &#125; from &#x27;react-router-dom&#x27;import dayjs from &#x27;dayjs&#x27;import ReactMarkdown from &#x27;react-markdown&#x27;import &#123; useQuery &#125; from &#x27;@apollo/client&#x27;import &#123; GET_POST_CATEGORY &#125; from &#x27;@/service/gql&#x27;import &#123; PostCategoryWrapper &#125; from &#x27;./style&#x27;const PostCategory = () =&gt; &#123; const &#123; id &#125; = useParams() const &#123; data, loading, error &#125; = useQuery(GET_POST_CATEGORY, &#123; variables: &#123; id: id &#125; &#125;) if (loading) &lt;div&gt;加载中...&lt;/div&gt; if (error) &lt;div&gt;出错了 :(&lt;/div&gt; console.log(data) return ( &lt;PostCategoryWrapper className=&#x27;page-wrap&#x27;&gt; &lt;div className=&#x27;page-container post-category-container&#x27;&gt; &lt;div className=&#x27;page-card post-category-card&#x27;&gt; &lt;div className=&#x27;post-category-title&#x27;&gt;&#123;data?.category.data.attributes.name&#125;&lt;/div&gt; &#123;data?.category.data.attributes.posts.data.map(post =&gt; ( &lt;div className=&#x27;post-category-block&#x27; key=&#123;post.id&#125;&gt; &lt;Link to=&#123;`/post-detail/$&#123;post.id&#125;`&#125;&gt; &lt;div className=&#x27;post-title&#x27;&gt;&#123;post.attributes.title&#125;&lt;/div&gt; &lt;div className=&#x27;post-date&#x27;&gt; &#123;dayjs(post.attributes.updatedAt).format(&#x27;YYYY-MM-DD hh:mm:ss&#x27;)&#125; &lt;/div&gt; &lt;div className=&#x27;post-description&#x27;&gt; &#123;post.attributes.content.substring(0, 200)&#125;... &lt;/div&gt; &lt;/Link&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/PostCategoryWrapper&gt; )&#125;export default PostCategory ‍ 总结Strapi是个不错的工具，可以快速通过内容给出API，自己来做前端的界面结构。比不过到v4版本，感觉结构上比v3的复杂了很多每个里面都有个attributes，结构上嵌套很多。 Graphql则简化了很多接口，跟RESTful API区别还是很大。后面还会来做下这块的学习。","permalink":"http://example.com/2022/10/08/Strapi-Graphql-%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"nextjs","slug":"nextjs","permalink":"http://example.com/tags/nextjs/"}],"title":"NextJS重新学习之三","date":"2022/10/01","text":"这个是一个用户身份验证的示例。 NextJs提供了一个身份验证的库next auth，使用这个库可以很轻松的做身份验证。 示例使用Github的用户身份登录。 由于版本问题，跟视频里说的一些内容有出入。根据官方文档来做了调整，代码做了很多优化，写起来更少了。 ‍ 安装1pnpm add next-auth ‍ 获取谷歌授权获取Github用户身份权限，相当于在github给第三方授权。 点击右上角的头像，进入settings。 在左侧菜单最下面找到Developer settings。 然后在二级菜单中找到OAuth Apps。 然后点击新建一个OAuth Application 填写Application name，应用的名称（NextAuth） 填写Homepage URL，我们是本地环境，所以填写http://localhost:3000。 Authorization callback URL也可以写http://localhost:3000。 然后点击register application按钮，进行保存。 然后在列表中点击NextAuth这个应用名称，进入详情。 拿到Client ID和Client secrets这两个的值。 ‍ 添加API在pages/api下添加一个文件夹auth，然后在目录下新建一个[...nextauth].js文件。 123456789101112131415// pages/api/auth/[...nextauth].jsimport NextAuth from &#x27;next-auth&#x27;import GithubProvider from &#x27;next-auth/providers/github&#x27;export const authOptions = &#123; providers: [ GithubProvider(&#123; clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET &#125;) ]&#125;export default NextAuth(authOptions) clientId将用来填写从Github上获取的Client ID，clientSecret的值是冲Github​上获取的Client secrets。 这两个内容我们写到本地环境变量（env.local）中。 12GITHUB_ID=********************GITHUB_SECRET=**************************************** ‍ 配置SessionProvider12345678910// pages/_app.jsimport &#123; SessionProvider &#125; from &quot;next-auth/react&quot;export default function App(&#123;Component, pageProps: &#123; session, ...pageProps &#125;&#125;) &#123; return ( &lt;SessionProvider session=&#123;session&#125;&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/SessionProvider&gt; )&#125; 至此，关于身份验证的准备工作已经完成，开始用用吧。 ‍ 获取Github用户信息做了个头部文件，增加了导航，然后通过useSession和getSession进行身份获取，以及是否获取到身份信息，对数据进行守卫。 以下仅在代码中进行说明。 ‍ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// components/navbar.jsximport React from &#x27;react&#x27;import &#123; Flex &#125; from &#x27;@chakra-ui/react&#x27;import Link from &#x27;next/link&#x27;import &#123; signIn, signOut, useSession &#125; from &#x27;next-auth/react&#x27;const handleSignIn = e =&gt; &#123; e.preventDefault() signIn() // next auth提供的登录方法，会跳转到 /pages/api/auth/signin&#125;const handleSignOut = e =&gt; &#123; e.preventDefault() signOut() // next auth提供的登出方法，会跳转到 /pages/api/auth/signout&#125;const Navbar = () =&gt; &#123; const &#123; data, status &#125; = useSession() return ( &lt;Flex justify=&#x27;space-between&#x27; align=&#x27;center&#x27; px=&#x27;5&#x27; h=&#123;12&#125; bgColor=&#x27;blue.500&#x27; color=&#x27;#fff&#x27;&gt; &lt;div className=&#x27;nav-brand&#x27;&gt;NEXT AUTH&lt;/div&gt; &lt;Navs&gt; &lt;Link href=&#x27;/&#x27;&gt; &lt;a className=&#x27;nav-link-item&#x27;&gt;首页&lt;/a&gt; &lt;/Link&gt; &#123;status === &#x27;authenticated&#x27; &amp;&amp; ( &lt;Link href=&#x27;/dashboard&#x27;&gt; &lt;a className=&#x27;nav-link-item&#x27;&gt;控制面板&lt;/a&gt; &lt;/Link&gt; )&#125; &lt;Link href=&#x27;/blog&#x27;&gt; &lt;a className=&#x27;nav-link-item&#x27;&gt;博客&lt;/a&gt; &lt;/Link&gt; &#123;status === &#x27;unauthenticated&#x27; ? ( &lt;Link href=&#x27;/api/auth/signin&#x27;&gt; &lt;a className=&#x27;nav-link-item&#x27; onClick=&#123;e =&gt; handleSignIn(e)&#125;&gt; 登录 &lt;/a&gt; &lt;/Link&gt; ) : null&#125; &#123;status === &#x27;authenticated&#x27; ? data &amp;&amp; ( &lt;div className=&#x27;user-block&#x27;&gt; &lt;div className=&#x27;user-avatar&#x27;&gt; &lt;img src=&#123;data.user.image&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;user-info&#x27;&gt; &lt;div className=&#x27;user-name&#x27;&gt;&#123;data.user.name&#125;&lt;/div&gt; &lt;div className=&#x27;user-mail&#x27;&gt;&#123;data.user.email&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) : null&#125; &#123;status === &#x27;authenticated&#x27; ? ( &lt;Link href=&#x27;/api/auth/signout&#x27;&gt; &lt;a className=&#x27;nav-link-item&#x27; onClick=&#123;e =&gt; handleSignOut(e)&#125;&gt; 登出 &lt;/a&gt; &lt;/Link&gt; ) : null&#125; &lt;/Navs&gt; &lt;/Flex&gt; )&#125;export default Navbar 说明： useSession()返回两个值的对象：data和status。 data根据情况会返回三个值： 当未获取会话返回undefined。 未能检索到会话返回null。 成功则返回session。session就是github返回的用户信息。 status根据上述三种情况的会话，返回loading、authenticated、unauthenticated。表示登录中、已登录、未登录。 上面的代码，通过status的值进行判断，在导航上显示哪些在未登录，哪些内容在已登录。 ‍ 权限守护因为共享了登录状态，所以可以在所有页面通过useSession获取到用户信息。通过getSession做权限守护。 1234567891011121314151617181920212223242526272829import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;import &#123; Box &#125; from &#x27;@chakra-ui/react&#x27;import &#123; useSession, getSession, signIn &#125; from &#x27;next-auth/react&#x27;const Dashboard = () =&gt; &#123; const &#123; data &#125; = useSession() const [loading, setLoading] = useState(true) // 权限守护 const sectPage = async () =&gt; &#123; const session = await getSession() // 如果没有获取到session，则跳转到登录 if (!session) &#123; signIn() &#125; else &#123; // 如果获取到session则结束loading setLoading(false) &#125; &#125; useEffect(() =&gt; &#123; sectPage() &#125;, []) if (loading) &lt;div&gt;登录中...&lt;/div&gt; // 如果有data，则显示data中的用户名称。 return &lt;Box p=&#x27;4&#x27;&gt;Dashboard &#123;data &amp;&amp; `欢迎您：$&#123;data.user.name&#125;`&#125;&lt;/Box&gt;&#125;export default Dashboard 下面的代码也是权限守护，如果未登录则跳转到登录，如果登录了，则显示对应的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243import React from &#x27;react&#x27;import &#123; Box, Text &#125; from &#x27;@chakra-ui/react&#x27;import &#123; getSession &#125; from &#x27;next-auth/react&#x27;const Blog = (&#123; data, isLogin, session &#125;) =&gt; &#123; console.log(&#x27;isLogin&#x27;, isLogin) console.log(&#x27;session&#x27;, session) if (!isLogin) &#123; return &lt;div&gt;无权查看&lt;/div&gt; &#125; return ( &lt;Box m=&#x27;20px auto&#x27; p=&#x27;0 20px&#x27;&gt; &#123;data?.map(post =&gt; ( &lt;Text key=&#123;post.id&#125; align=&#x27;left&#x27; fontSize=&#x27;md&#x27;&gt; &#123;post.title&#125; &lt;/Text&gt; ))&#125; &lt;/Box&gt; )&#125;export default Blogexport async function getServerSideProps(context) &#123; const session = await getSession(context) const response = await fetch(`https://jsonplaceholder.typicode.com/posts`) const data = await response.json() // 权限守护，未登录返回登录，已登录可以返回数据。 if (!session) &#123; return &#123; redirect: &#123; destination: `/api/auth/signin?callbackUrl=http://localhost:3000/blog`, permanent: false // false不是永久重定向，临时的。 &#125; &#125; &#125; return &#123; props: &#123; isLogin: session ? true : false, data: session ? data : [] &#125; &#125;&#125; ‍ API路由守护1234567891011121314// pages/api/text-session.jsimport &#123; getSession &#125; from &#x27;next-auth/react&#x27;const handler = async (req, res) =&gt; &#123; const session = await getSession(&#123; req &#125;) if (!session) &#123; return res.status(401).json(&#123; error: &#x27;unauthenticated user&#x27; &#125;) // 如果没有session返回错误 &#125; else &#123; return res.status(200).json(&#123; message: &#x27;success&#x27;, session &#125;) // 如果有session返回用户信息 &#125;&#125;export default handler ‍","permalink":"http://example.com/2022/10/01/NextJS%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%89/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"nextjs","slug":"nextjs","permalink":"http://example.com/tags/nextjs/"}],"title":"NextJS重新学习之二","date":"2022/10/01","text":"NextJs学习笔记第二部分。基础知识，接上一篇。 ‍ API路由在API文件夹下，添加和访问路径一致的目录，即可在api/路径下获得到对应的json数据。 12345678910111213141516// pages/api/index.js 访问根目录&#x27;/api&#x27;就可以获取到navs的jsonexport default function handler(req, res) &#123; res.status(200).json( &#123; navs: [ &#123; name: &#x27;首页&#x27;, route: &#x27;/&#x27; &#125;, &#123; name: &#x27;用户&#x27;, route: &#x27;/users&#x27; &#125;, &#123; name: &#x27;产品&#x27;, route: &#x27;/products&#x27; &#125;, ]&#125; )&#125;// pages/api/users.js 访问&#x27;/api/users&#x27;可获取到对应的用户名称export default function handler(req, res) &#123; res.status(200).json(&#123; name: &#x27;John Doe&#x27; &#125;)&#125; ‍ 使用API路由可以对数据进行增删改查。 示例： 将数据单独存放到一个地方，供后面进行查询。 12345678910// data/coffee.jsconst coffees = [ &#123; id: 1, text: &#x27;荔枝气泡冷萃&#x27; &#125;, &#123; id: 2, text: &#x27;爆打柠檬冷萃&#x27; &#125;, &#123; id: 3, text: &#x27;生椰冷萃&#x27; &#125;, &#123; id: 4, text: &#x27;冷萃冰咖啡&#x27; &#125;]export default coffees 对访问API的数据区分get查询数据和post提交数据。 1234567891011121314151617// pages/api/coffees/index.jsimport coffees from &#x27;@/data/coffees&#x27;export default function handler(req, res) &#123; if (req.method === &#x27;GET&#x27;) &#123; res.status(200).json(coffees) &#125; else if (req.method === &#x27;POST&#x27;) &#123; const coffee = req.body.coffee const newCoffee = &#123; id: Date.now(), text: coffee &#125; coffees.push(newCoffee) res.status(201).json(newCoffee) &#125;&#125; 对单独的数据进行get查询和delete删除数据 12345678910111213141516// pages/api/coffees/[coffeeId].jsimport coffees from &#x27;@/data/coffees&#x27;export default function handler(req, res) &#123; const &#123; coffeeId &#125; = req.query if (req.method === &#x27;GET&#x27;) &#123; const coffee = coffees.find(coffee =&gt; coffee.id === parseInt(coffeeId)) req.status(200).json(coffee) &#125; else if (req.method === &#x27;DELETE&#x27;) &#123; const deleteCoffee = coffees.find(coffee =&gt; coffee.id === parseInt(coffeeId)) const index = coffees.findIndex(coffee =&gt; coffee.id === parseInt(coffeeId)) coffees.splice(index, 1) res.status(200).json(deleteCoffee) &#125;&#125; 在页面中显示数据、删除数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// pages/coffees/index.jsximport React, &#123; useState &#125; from &#x27;react&#x27;const Coffees = () =&gt; &#123; const [coffees, setCoffees] = useState([]) const [coffee, setCoffee] = useState(&#x27;&#x27;) const getCoffees = async () =&gt; &#123; const response = await fetch(&#x27;/api/coffees&#x27;) const data = await response.json() setCoffees(data) &#125; const handleSubmit = async () =&gt; &#123; const response = await fetch(&#x27;/api/coffees&#x27;, &#123; method: &#x27;POST&#x27;, body: JSON.stringify(&#123; coffee &#125;), headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; &#125;) const data = await response.json() console.log(data) // setCoffee(&#x27;&#x27;) // getCoffees() &#125; const handleDelete = async coffeeId =&gt; &#123; const response = await fetch(`/api/coffees/$&#123;coffeeId&#125;`, &#123; method: &#x27;DELETE&#x27; &#125;) const data = await response.json() console.log(data) getCoffees() &#125; console.log(&#x27;id&#x27;, id) return ( &lt;div&gt; &lt;div&gt; &lt;input type=&#x27;text&#x27; value=&#123;coffee&#125; onChange=&#123;e =&gt; setCoffee(e.target.value)&#125; /&gt; &lt;button onClick=&#123;handleSubmit&#125;&gt;submit&lt;/button&gt; &lt;button onClick=&#123;getCoffees&#125;&gt;Fetch Coffees&lt;/button&gt; &lt;hr /&gt; &lt;/div&gt; &#123;coffees.map(coffee =&gt; ( &lt;div key=&#123;coffee.id&#125;&gt; &lt;span&gt; &#123;coffee.id&#125;. &#123;coffee.text&#125; &lt;/span&gt; &lt;button onClick=&#123;() =&gt; handleDelete(coffee.id)&#125;&gt;delete&lt;/button&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default Coffees 对单独数据进行查询和静态生成 12345678910111213141516171819202122232425262728293031323334353637383940// pages/coffees/[coffeeId].jsximport React from &#x27;react&#x27;import coffees from &#x27;@/data/coffees&#x27;const Coffee = (&#123; coffee &#125;) =&gt; &#123; return ( &lt;div&gt; &#123;coffee.id&#125;. &#123;coffee.text&#125; &lt;/div&gt; )&#125;export default Coffeeexport async function getStaticProps(context) &#123; const &#123; params &#125; = context const &#123; coffeeId &#125; = params const coffee = coffees.find(coffee =&gt; coffee.id === parseInt(coffeeId)) console.log(coffee) return &#123; props: &#123; coffee &#125; &#125;&#125;export async function getStaticPaths() &#123; return &#123; paths: [ &#123; params: &#123; coffeeId: &#x27;1&#x27; &#125; &#125;, &#123; params: &#123; coffeeId: &#x27;2&#x27; &#125; &#125;, &#123; params: &#123; coffeeId: &#x27;3&#x27; &#125; &#125;, &#123; params: &#123; coffeeId: &#x27;4&#x27; &#125; &#125; ], fallback: false &#125;&#125; ‍ API路由总结 API路由机制类似于页面的路由机制。 API路由根据文件名于路由进行关联 每个API路由都会导出一个默认函数，通常称为处理函数（handler） 处理函数接收request简称req和response简称req作为请求参数和响应参数 处理函数通过req.method接收不同的请求类型。例如：GET和POST 通过[...params].js文件命名，使用req.query.params来捕获所有路由参数 ‍ NextJs中的样式‍ NextJs中的全局样式（Global Style）NextJs中的全局样式，在pages/_app.js中进行引入就可以了。_app.js类似于React中的入口文件main.js或者index.js。 123456789// pages/_app.jsimport &#x27;../styles/globals.css&#x27;function MyApp(&#123; Component, pageProps &#125;) &#123; return &lt;Component &#123;...pageProps&#125; /&gt;&#125;export default MyApp ‍ NextJs中组件的样式‍ NextJs中可以直接使用module.css123456// styles/about.css.aboutBlock &#123; background-color: skyblue; color: #444;&#125; 然后在组件中进行引用。 123456789// pages/about.jsximport style from &#x27;@/styles/about.module.css&#x27;const About = () =&gt; &#123; return &lt;div className=&#123;style.aboutBlock&#125;&gt;About&lt;/div&gt;&#125;export default About 在css.module中的优点： 可以让组件各种引用各自的样式，即使样式名称相同，在同一个组件引入不同子组件中有相同的样式，也不会发生冲突。 最容易使用，NextJs可以直接使用，无需安装或引用什么包。 ‍ 在css.module中的缺点： 每次都引用后，样式都要写成对象形式，比如：&lt;div className=&#123;style.aboutBlock&#125;&gt;About&lt;/div&gt;，否则不生效。导致会重复多次style这个单词。 在写法上module也只能按照对象的写法，把样式写成驼峰，不能使用中划线连接。这个就比较别扭。 ‍ NextJs中使用Scss或Less用法上和css.module类似，只是在书写上会更加灵活点。可以使用scss中的变量和嵌套。 首先需要安装scss或less，以scss为例。 1pnpm add sass -D 在styles文件夹下添样式变量文件 12345// styles/_color.scss$bg: #f7f7f7;$textColor: #757575;$titleColor: #424242; ‍ 12345678910111213// styles/contact.module.scss@import &#x27;color&#x27;;.contactBlock &#123; padding: 24px; background-color: $bg; span &#123; font-size: 16px; color: $textColor; &#125;&#125; 然后使用和css.module一样了。 12345678910111213// pages/contact.jsximport style from &#x27;@/styles/about.module.scss&#x27;const Contact = () =&gt; &#123; return ( &lt;div className=&#123;style.aboutBlock&#125;&gt; &lt;span&gt;Contact&lt;/span&gt; &lt;/div&gt; )&#125;export default Contact ‍ NextJs中使用css-in-js​可以安装styled-components或者emotion两者的使用方法差不多，以styled-components为例。 安装 1pnpm add styled-components -D 使用变量的方式有两种，一种是引用文件中的变量，一种是引用主题中的公共变量。 ‍ 引用主题中的公共变量在pages/_app.js中添加themeProvider，并包裹下Component，定义主题变量。 12345678910111213141516171819// pages/_app.jsimport &#123; ThemeProvider &#125; from &#x27;styled-components&#x27;function MyApp(&#123; Component, pageProps &#125;) &#123; const theme = &#123; colors: &#123; primary: &#x27;#0099e8&#x27; &#125; &#125; return ( &lt;ThemeProvider theme=&#123;theme&#125;&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/ThemeProvider&gt; )&#125;export default MyApp 在页面中使用 1234567891011121314151617import styled from &#x27;styled-components&#x27;const AboutBlock = styled.div` padding: 8px; background-color: $&#123;(&#123; theme &#125;) =&gt; theme.colors.primary&#125;; color: #fff;`const About = () =&gt; &#123; return ( &lt;AboutBlock&gt; &lt;span&gt;About&lt;/span&gt; &lt;/AboutBlock&gt; )&#125;export default About 这种方法适用于定义多主题的时候，平常用的比较少，主要在使用变量时需要用一个方法从theme中传对应的变量过来，过于麻烦。平时使用的较多的是从文件中导入变量。 ‍ 引用文件中的变量12345678910111213141516171819202122232425262728293031323334353637383940414243// styles/contact.style.jsconst ellipsis = (line, width = &#x27;100%&#x27;) =&gt; &#123; if (line === 1) &#123; return ` max-width:$&#123;width&#125;; font-size:14px; line-height:18px; overflow:hidden; white-space: nowrap; text-overflow: ellipsis; ` &#125; if (line === 2 || line === 3) &#123; return ` max-width:$&#123;width&#125;; font-size:14px; line-height:18px; display: -webkit-box !important; overflow:hidden; text-overflow:ellipsis; -webkit-line-clamp: $&#123;line&#125;; -webkit-box-orient: vertical; ` &#125;&#125;const flexCenter = () =&gt; &#123; return ` display: flex; justify-content: center; align-items: center; `&#125;export default &#123; // Color &#x27;primary-color&#x27;: &#x27;#0099e8&#x27;, // Function flexCenter, ellipsis&#125; 然后在styled-components的样式组件中引用即可。 123456789101112131415161718// pages/contact.jsximport styled from &#x27;styled-components&#x27;import s from &#x27;@/styles/contact.style&#x27;const ContactBlock = styled.div` $&#123;s.flexCenter&#125;; padding: 8px; background-color: $&#123;s[&#x27;primary-color&#x27;]&#125;; font-size: 14px; color: #fff;`const Contact = () =&gt; &#123; return &lt;ContactBlock&gt;Contact&lt;/ContactBlock&gt;&#125;export default Contact 此方法使用很方便，一些常用的样式可组合成一个变量直接使用，省去甚多重复定义。 ‍ NextJs中的其他配置‍ NextJs中的布局嵌套在NextJs中，可以通过在pages/_app.js这个公共布局组件上添加布局响应的头尾组件。但有一些页面可能不需要公共的组件，则需要通过getLayout这个方法进行处理。 1234567891011121314151617181920// pages/_app.jsimport &#x27;../styles/globals.css&#x27;import Header from &#x27;@/components/layout/Header&#x27;import Footer from &#x27;@/components/layout/Footer&#x27;function MyApp(&#123; Component, pageProps &#125;) &#123; if (Component.getLayout) &#123; return Component.getLayout(&lt;Component &#123;...pageProps&#125; /&gt;) &#125; return ( &lt;&gt; &lt;Header /&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;Footer /&gt; &lt;/&gt; )&#125;export default MyApp 上述代码会通过getLayout进行判断，如果有这个方法的页面，就使用页面定义的Layout。 123456789101112131415161718192021222324// pages/about.jsximport Header from &#x27;@/components/layout/Header&#x27;import React from &#x27;react&#x27;import styled from &#x27;styled-components&#x27;const About = () =&gt; &#123; return ( &lt;div&gt; &lt;span&gt;About&lt;/span&gt; &lt;/div&gt; )&#125;export default AboutAbout.getLayout = page =&gt; &#123; return ( &lt;&gt; &lt;Header /&gt; &#123;page&#125; &lt;/&gt; )&#125; 上述页面，就没有使用&lt;Footer /&gt;这个底部组件。也可以引用其他的头尾组件。 ‍ NextJs中的Head组件作为多页面应用，每个页面都会需要一个Head标签，定义这个页面的一些Meta内容，比如：页面标题、Ico、描述等。NextJs可以在公共模板pages/_app.js中使用这个公共配置。 12345678910111213141516171819202122232425// pages/_app.jsimport Head from &#x27;next/head&#x27;import &#x27;../styles/globals.css&#x27;import Header from &#x27;@/components/layout/Header&#x27;import Footer from &#x27;@/components/layout/Footer&#x27;function MyApp(&#123; Component, pageProps &#125;) &#123; if (Component.getLayout) &#123; return Component.getLayout(&lt;Component &#123;...pageProps&#125; /&gt;) &#125; return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;Sim Site&lt;/title&gt; &lt;meta name=&#x27;discription&#x27; content=&#x27;这个是页面描述&#x27; /&gt; &lt;/Head&gt; &lt;Header /&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;Footer /&gt; &lt;/&gt; )&#125;export default MyApp 当使用独立布局的页面，也可以引用自己的头部 123456789101112131415161718192021222324252627import Head from &#x27;next/head&#x27;import Header from &#x27;@/components/layout/Header&#x27;import React from &#x27;react&#x27;import styled from &#x27;styled-components&#x27;const About = () =&gt; &#123; return ( &lt;div&gt; &lt;span&gt;About&lt;/span&gt; &lt;/div&gt; )&#125;export default AboutAbout.getLayout = page =&gt; &#123; return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;关于我们&lt;/title&gt; &lt;meta name=&#x27;discription&#x27; content=&#x27;这个是关于页面描述&#x27; /&gt; &lt;/Head&gt; &lt;Header /&gt; &#123;page&#125; &lt;/&gt; )&#125; 如果没有使用独立布局的页面，则可以这样引用 1234567891011121314151617181920212223242526import React from &#x27;react&#x27;import Head from &#x27;next/head&#x27;import styled from &#x27;styled-components&#x27;import s from &#x27;@/styles/contact.style&#x27;const ContactBlock = styled.div` $&#123;s.flexCenter&#125;; padding: 8px; background-color: $&#123;s[&#x27;primary-color&#x27;]&#125;; font-size: 14px; color: #fff;`const Contact = () =&gt; &#123; return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;联系我们&lt;/title&gt; &lt;meta name=&#x27;discription&#x27; content=&#x27;这个是联系页面描述&#x27; /&gt; &lt;/Head&gt; &lt;ContactBlock&gt;Contact&lt;/ContactBlock&gt; &lt;/&gt; )&#125;export default Contact 如果是需要生成静态的页面，还可以将Head标签放到[postId].jsx这样的文件中，通过props传入动态变量进行头部内容的添加。此处不做过多说明。 ‍ NextJs中的图片在NextJs中引入图片，可以像普通的图片一样通过import的方式引入。 NextJs也提供了一个图片的API，可以对图片进行优化处理。 对于图片有两种引用方式，一种是本地图片，一种是远程图片。 123456789101112131415161718192021222324252627282930313233// pages/imagelist.jsximport Image from &#x27;next/image&#x27;const picList = [ &#x27;https://p1.music.126.net/RtN6VzXNzOPAOhCiQSfjkQ==/109951163754607895.jpg&#x27;, &#x27;https://p1.music.126.net/Xd6h-xOoPj2yTUuQXOhyCQ==/18612532836990988.jpg&#x27;, &#x27;https://p1.music.126.net/sixunTcvD_IXeVqxZnpHkA==/109951163452086313.jpg&#x27;]const ImageList = () =&gt; &#123; return ( &lt;div&gt; &lt;div&gt; &#123;picList.map((pic, index) =&gt; ( &lt;div key=&#123;index&#125;&gt; &lt;Image src=&#123;`$&#123;pic&#125;?param=200y200`&#125; width=&#123;200&#125; height=&#123;200&#125; /&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &#123;[1, 2, 3].map((img, index) =&gt; ( &lt;div key=&#123;index&#125;&gt; &lt;Image src=&#123;`/$&#123;img&#125;.jpg`&#125; width=&#123;200&#125; height=&#123;200&#125; /&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default ImageList 如果引用远程图片的话，还需要配置下next.config.js，在配置中加入图片的主域。 12345const nextConfig = &#123; images: &#123; domains: [&#x27;p1.music.126.net&#x27;] &#125;&#125; 因为NextJs会对图片做懒加载处理，所以需要给图片加上尺寸进行占位。 加载后的本地图片会进行格式转化为webp格式的图片，并且会根据尺寸显示不同大小的图片进行加载。 ‍ NextJs中的模块导入别名设置在NextJs中可以新建一个jsconfig.json或tsconfig.json文件来配置路径别名。 12345678910// jsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;/*&quot;] &#125; &#125;&#125; 如果配置了&quot;baseUrl&quot;: &quot;.&quot;，路径其实就可以使省去前面的相对路径层级。比如：components文件夹，在pages/posts/index.jsx中引用。可以直接写components/post。但是为了书写习惯和React中保持一致，也可以配置paths如上方一样。 ‍ NextJs中的重定向在NextJs中可以将一些旧的内容重定向到一个新的页面或组件上。在next.config.js中配置 123456789101112131415161718// next.config.jsconst nextConfig = &#123; redirects: async () =&gt; &#123; return [ &#123; source: &#x27;/about&#x27;, destination: &#x27;/&#x27;, permanent: true &#125;, &#123; source: &#x27;/posts2/:postId&#x27;, destination: &#x27;/posts/:postId&#x27;, permanent: true &#125; ] &#125;&#125; source：源路径，可以使用正则等方法对路径进行匹配。 destination：跳转到的路径 permanent：是否长期重定向，主要给搜索引擎查看在headers上的重定向内容。 ‍ NextJs中的环境变量配置‍ 在根目录下添加.env.local文件。文件中可以配置数据库、外部API的内容。通过process.env在代码中取出。 12345// .env.localDB_HOST=localhostDB_USER=myuserDB_PASS=mypassword ‍ 123456789// pages/index.jsexport async function getStaticProps() &#123; const db = await myDB.connect(&#123; host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS, &#125;)&#125; 默认情况下，环境变量仅可在node环境中使用，不会暴露给浏览器。 如果需要将环境变量内容暴露给浏览器可以在变量前增加前缀NEXT_PUBLIC_，这样就可以在浏览器中访问到该变量。 123// .env.localNEXT_PUBLIC_ANALYTICS_ID=abcdefghijk ‍ 1234567891011// pages/index.jsimport setupAnalyticsService from &#x27;../lib/my-analytics-service&#x27;setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)function HomePage() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;&#125;export default HomePage ‍ 在通常情况下只有一个环境变量，但有时会对开发环境和生产环境进行区分。所以可以进行如下配置： .env.local可以覆盖所有默认值，可用来保存一些公共的信息。另外该文件不会被提交到源码仓库，可以放置一些密钥类的信息。 .env.development设置开发环境默认值 .env.production设置生产环境默认值 ‍","permalink":"http://example.com/2022/10/01/NextJS%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"nextjs","slug":"nextjs","permalink":"http://example.com/tags/nextjs/"}],"title":"NextJS重新学习之一","date":"2022/10/01","text":"国内的NextJs资料太少了，B站上找了下讲的很少，官网又是一个挂着中文文档的英文文档。在YouTube上找了下，英文的资料还是很多。 找到了这个Codevolution大神的教程，79个视频的播放列表。 Next.js Tutorial for Beginners 以下是学习笔记。 ‍ NextJs的安装可以通过两种方式： 12345678910111213// 常规方式 可以填写项目名称 或不填写 在提示后填写项目名称pnpm create next-app [项目名称]// npx方式 效果同上npx create-next-app [项目名称]// 安装完后//进入项目目录cd [项目名称]// 启动项目pnpm dev ‍ 给NextJS安装ESLint和Prettier通过安装eslint-config-acme这个包，则可以一步到位。 1234567891011121314151617// 安装pnpm add eslint-config-acme -D// 装完后会装上下面这么一堆eslinteslint-config-airbnbeslint-config-prettiereslint-import-resolver-aliaseslint-plugin-importeslint-plugin-jsx-a11yeslint-plugin-prettiereslint-plugin-reacteslint-plugin-react-hookseslint-plugin-simple-import-sorteslint-plugin-tailwindcssprettierprettier-plugin-tailwindcss ‍ 然后来修改下next中的一些配置，让ESLint和Prettier生效。 在package.json中增加 1234567891011121314// package.json&#123; &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: [&quot;acme&quot;] &#125;, &quot;jsx-a11y/anchor-is-valid&quot;: [ &quot;error&quot;, &#123; &quot;components&quot;: [&quot;Link&quot;], &quot;specialLink&quot;: [&quot;hrefLeft&quot;, &quot;hrefRight&quot;], &quot;aspects&quot;: [&quot;invalidHref&quot;, &quot;preferButton&quot;] &#125; ]&#125; jsx-a11y/anchor-is-valid这个配置是用来修复next.jsLink组件的一个bug。需要放到package.json中 ‍ 在.eslintrc.json中修改并增加一些 123456789101112// .eslintrc.json&#123; &quot;extends&quot;: [&quot;acme&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: [ &quot;error&quot;, &#123; &quot;printWidth&quot;: 100 &#125; ] &#125;&#125; 然后新建.prettierrc.cjs文件 12345678910111213141516171819module.exports = &#123; printWidth: 100, semi: false, singleQuote: true, jsxSingleQuote: true, trailingComma: &quot;none&quot;, bracketSpacing: true, jsxBracketSameLine: false, arrowParens: &quot;avoid&quot;, insertPragma: false, tabWidth: 2, useTabs: false, endOfLine: &quot;auto&quot;, HTMLWhitespaceSensitivity: &quot;ignore&quot;, extends: [ &quot;eslint:recommended&quot;, &quot;plugin:prettier/recommended&quot;, ],&#125; 如果需要使用路径别名，需要新建一个jsconfig.json的文件 12345678910// jsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;/*&quot;] &#125; &#125;&#125; ‍ 以上配置完成。 ‍ NextJs的路由‍ 基本路由NextJs的路由属于约定式路由，所有路由文件都需要统一放在pages文件夹下。 一个文件或者一个文件夹都可以作为路由 1234567// 一级路由pages/index.js 对应路由为 &#x27;/&#x27;// 二级路由pages/books.js 对应路由为 &#x27;/books&#x27;// 或者pages/books/index.js 对应路由也为 &#x27;/books&#x27; ‍ 动态路由动态路由是可以通过特定的标识符[ ]来对文件或者文件夹进行命名，来作为路由参数进行获取。 1234567// 文件参数路由pages/books/[bookId].js 对应路由为 &#x27;/books/:id&#x27;// 也可以和index.js共存pages/books/index.js 路由会优先访问 index.js文件 ’/books‘// 如果有参数则会访问参数路由&#x27;/books/1&#x27; 则会访问 pages/books/[bookId].js文件 ‍ 取出路由参数可以使用next/router中的钩子函数 useRouter中的query来获取 12345678910// pages/books/[bookId].jsimport React from &#x27;react&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const Book = () =&gt; &#123; const router = useRouter() return &lt;div&gt;book - &#123;router.query.bookId&#125;&lt;/div&gt;&#125;export default Book ‍ 动态路由的嵌套动态路由可以根据情况使用文件夹进行嵌套 12345// 在book中有评论comment/pages/books/[bookId]/comments/[commentId].js 路由为 &#x27;/books/123/comments/456&#x27;books、[bookId]、comments 为文件夹[commentId].js 为文件 可以通过[commentId].js文件中的 const &#123; productId, commentId &#125; = useRouter().query 来获取book和comment的id ‍ 这样动态嵌套路由能解决一部分参数较少的需求，如果参数较多，就会造成嵌套过多的问题。可以使用[...pramas].js这个文件名来解决嵌套问题。 使用这个文件名，next就会自动获取多个层级的路由参数。 12345678910111213141516171819// pages/books/[[...pramas]].jsimport React from &#x27;react&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const book = () =&gt; &#123; const router = useRouter() // 获取路由参数，需要给pramas赋一个空数组作为默认值，否则会报undefined const &#123; pramas = [] &#125; = router.query console.log(pramas) // 判断参数长度，根据长度显示相应的参数。 if (pramas.length === 1) return &lt;div&gt;Pramas: &#123;pramas[0]&#125;&lt;/div&gt; if (pramas.length === 2) return &lt;div&gt;Pramas: &#123;pramas[1]&#125;&lt;/div&gt; if (pramas.length === 3) return &lt;div&gt;Pramas: &#123;pramas[2]&#125;&lt;/div&gt; //当没有参数时，显示默认返回值，但是这里有问题会显示404 return &lt;div&gt;book index&lt;/div&gt;&#125;export default book 当使用[...pramas].js作为文件名时，只会获取参数页面，如果需要默认的首页则需要在[...pramas]外面在包裹一个中括号，[[...pramas]].js这样就可以访问到默认返回内容。 ‍ NextJs中的路由跳转比较简单，直接看代码 123456789101112131415161718192021222324252627// pages/index.jsimport React from &#x27;react&#x27;import Link from &#x27;next/link&#x27;const Home = () =&gt; &#123; return ( &lt;div&gt; &lt;h4&gt;Home&lt;/h4&gt; &lt;nav&gt; &lt;Link href=&quot;/&quot;&gt; &lt;a&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;span&gt; | &lt;/span&gt; &lt;Link href=&quot;/books&quot;&gt; &lt;a&gt;Books&lt;/a&gt; &lt;/Link&gt; &lt;span&gt; | &lt;/span&gt; &lt;Link href=&quot;/products&quot; replace&gt; &lt;a&gt;Products&lt;/a&gt; &lt;/Link&gt; &lt;/nav&gt; &lt;/div&gt; )&#125;export default Home 使用&lt;Link&gt;&lt;/Link&gt;标签进行包裹，注意，中间要使用&lt;a&gt;&lt;/a&gt;标签，否则无法跳转。很怪异，href这个属性要写到&lt;Link&gt;这个标签上，比react-router-dom里的&lt;Link&gt;&lt;/Link&gt;难用太多。 replace类似react-router-dom里的history使用后，会对历史记录进行覆盖替换，所以后退时，不会返回到上一页。 ‍ 在方法中使用路由跳转也很简单，使用useRouter这个钩子函数，中的push或者replace方法就可以了。类似react-router-dom中的useNavigate，当然这个更灵活。 1234567891011121314151617181920// pages/index.jsimport React from &#x27;react&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;const Home = () =&gt; &#123; const router = useRouter() const handleClick = () =&gt; &#123; router.push(&#x27;/products/12&#x27;) // router.replace(&#x27;/products/12&#x27;) // 效果和在Link上加replace一样，覆盖历史记录。 &#125; return ( &lt;div&gt; &lt;h4&gt;Home&lt;/h4&gt; &lt;button onClick=&#123;handleClick&#125;&gt;Place Order&lt;/button&gt; &lt;/div&gt; )&#125;export default Home ‍ 自定义错误页面自定义404页面，只需要定义一个页面命名为404.js即可。 12345678910// pages/404.jsximport React from &#x27;react&#x27;const PageNotFound = () =&gt; &#123; return &lt;h2&gt;404 - PageNotFound&lt;/h2&gt;&#125;export default PageNotFound ‍ NextJs中获取数据NextJs因为是服务端渲染，所以需要提前获取到数据后对数据进行渲染，所以需要使用到getStaticProps方法，导出对应props的数据到组件。 1234567891011121314151617181920212223242526272829// pages/users/index.jsximport React from &#x27;react&#x27;import User from &#x27;@/components/user&#x27;const Users = (&#123; users &#125;) =&gt; &#123; console.log(users) return ( &lt;&gt; &lt;h4&gt;Users List&lt;/h4&gt; &lt;User data=&#123;users&#125; /&gt; &lt;/&gt; )&#125;export default Users// 这里必须使用getStaticProps 这个方法名称，否则获取不到数据// 获取到的数据必须 返回 一个对象，在对象中的 返回 props对象export const getStaticProps = async (context) =&gt; &#123; const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;) const data = await response.json() console.log(&#x27;data&#x27;, data) return &#123; props: &#123; users: data &#125; &#125;&#125; NextJs可以和react一样使用组件传递props 12345678910111213141516171819// components/user/index.jsximport React from &#x27;react&#x27;const User = (&#123; data &#125;) =&gt; &#123; return ( &lt;&gt; &#123;data.map(user =&gt; ( &lt;div key=&#123;user.id&#125;&gt; &lt;span&gt;&#123;user.name&#125;&lt;/span&gt; &lt;span&gt; - &lt;/span&gt; &lt;span&gt;&#123;user.email&#125;&lt;/span&gt; &lt;/div&gt; ))&#125; &lt;/&gt; )&#125;export default User 另外，需要注意getStaticProps只能在pages的页面中使用，不能再组件端components中使用。 ‍ NextJs预渲染（Pre-rendering）在NextJs中支持两种形式的预渲染：静态生成和服务端渲染。 静态生成和服务端渲染时生成HTML的时机不同。 静态生成：是在&#x3D;&#x3D;构建时&#x3D;&#x3D;生成HTML，以后每个请求都共用构建时生成好的HTML。 服务器渲染：是在&#x3D;&#x3D;请求时&#x3D;&#x3D;生成HTML，每隔请求都会重新生成HTML。 ‍ NextJs允许开发者为每个页面选择不同的渲染方式，不同的渲染方式由不同的特点，应根据场景进行渲染。建议大多数页面使用静态生成。 静态生成一次构建，反复使用，访问速度快。适用场景：营销页面，博客文章、电商产品列表、帮助文档。 服务端渲染访问速度不如静态生成快，但是由于每次请求都会重新渲染，所以适用于数据平凡更新的页面或页面内容随请求变化而变化的页面。 ‍ ‍ 无数据和有数据的静态生成无数据的静态生成：组件不需要在其他地方获取数据，直接进行静态生成。 有数据的静态生成：组件需要在其他地方获取数据，在构建时NextJs会预先获取组件需要的数据，然后再对组件进行静态生成。 ‍ 静态生成getStaticProps​getStaticProps方法的作用是获取组件静态生成时所需要的数据，并通过props的方式讲数据传递给组件。 该方法是一个异步函数，需要再组件内部进行导出。 getStaticProps 是在构建时运行的，运行在node下，可以使用node的代码，如通过node方法获取文件内容。 12345678910export const getStaticProps = async () =&gt; &#123; // 从文件系统、api、数据库中获取的数据 const data = ... // props 属性的值将会传递给组件 return &#123; props: &#123; ... &#125; &#125;&#125; ‍ 服务器端渲染getServerSideProps​在构建时不生产HTML，在接收到请求时再生成HTML。 如果采用服务器渲染，需要在组件中导出getServerSideProps方法。 12345678export async function getServerSideProps(context) &#123; // context 中会包含特定的请求参数 return &#123; props: &#123; // props for your compnent &#125; &#125;&#125; ‍ 基于动态路由的静态生成基于参数为页面组件生产HTML页面，有多少参数就生成多少HTML页面。 在构建应用时，先获取用户可以访问的所有路由器参数，再根据路由参数获取具体数据，然后根据数据生产静态HTML。 ‍ 实现方法： 创建基于动态路由的页面组件文件，命名时在文件名称外面加上[]，比如[id].js​ 导出异步函数getStaticPaths，用于获取所有用户可以访问的路由参数。 123456789export async function () &#123; // 此次获取所有用户可以访问的路由参数 return &#123; // 返回固定格式的路由参数 paths: [&#123;params: &#123;id: 1&#125;&#125;, &#123;params: &#123;id: 2&#125;&#125;], // 当用户访问的路由参数没有在当前函数中返回时，是否显示404页面，false：显示，true：不显示 fallback: false &#125;&#125; 导出异步函数getStaticProps，用于根据路由参数获取具体的数据。 12345678export async function getStaticProps(&#123;params&#125;) &#123; // params 中获取id // 此处根据路由参数获取具体数据 return &#123; // 将数据传递到组件中进行静态页面的生成 props: &#123; &#125; &#125;&#125; 注：getStaticPaths和getStaticProps只运行在服务器端，永远不会运行在客户端，甚至不会被打包到客户端JavaScript中，意味着这里可以随意写服务器端代码，比如数据查询。 ‍ 有数据的静态生成，示例：12345678910111213141516171819202122232425262728293031// pages/posts/index.jsximport Link from &#x27;next/link&#x27;const Posts = (&#123; posts &#125;) =&gt; &#123; return ( &lt;PostsWrapper&gt; &lt;div className=&#x27;post-list&#x27;&gt; &#123;posts.map(post =&gt; ( &lt;Link href=&#123;`/posts/$&#123;post.id&#125;`&#125; key=&#123;post.id&#125;&gt; &lt;a className=&#x27;post-list-item&#x27;&gt; &#123;post.id&#125;. &#123;post.title&#125; &lt;/a&gt; &lt;/Link&gt; ))&#125; &lt;/div&gt; &lt;/PostsWrapper&gt; )&#125;export default Postsexport const getStaticProps = async () =&gt; &#123; const response = await fetch(`https://jsonplaceholder.typicode.com/posts`) const data = await response.json() return &#123; props: &#123; posts: data &#125; &#125;&#125; ‍ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// pages/posts/[postId].jsximport &#123; useRouter &#125; from &#x27;next/router&#x27; const Post = (&#123; post &#125;) =&gt; &#123; const router = useRouter() if (router.isFallback) &lt;div&gt;Loading...&lt;/div&gt; return ( &lt;PostWrapper&gt; &lt;div className=&#x27;post-item&#x27;&gt; &lt;div className=&#x27;post-title&#x27;&gt;&#123;post.title&#125;&lt;/div&gt; &lt;div className=&#x27;post-body&#x27;&gt;&#123;post.body&#125;&lt;/div&gt; &lt;/div&gt; &lt;/PostWrapper&gt; )&#125;export default Postexport async function getStaticPaths() &#123; const response = await fetch(`https://jsonplaceholder.typicode.com/posts`) const data = await response.json() // 生成 前10条（共100条） const paths = data.slice(0, 10).map(post =&gt; &#123; return &#123; params: &#123; postId: `$&#123;post.id&#125;` &#125; &#125; &#125;) return &#123; paths, fallback: true &#125;&#125;export async function getStaticProps(context) &#123; const &#123; params &#125; = context const response = await fetch(`https://jsonplaceholder.typicode.com/posts/$&#123;params.postId&#125;`) const data = await response.json() // 如果没有对应的id则返回404 if (!data.id) &#123; return &#123; notFound: true &#125; &#125; return &#123; props: &#123; post: data &#125; &#125;&#125; ‍ getStaticPaths的fallback设置总结：一、 当getStaticPaths的fallback: false getStaticPaths返回的路径参数在构建时（build）由getStaticProps渲染生成HTML。 如果fallback设置为false，那么getStaticPaths没有返回的任何路径参数（路径参数范围之外的），都会跳转到404页面。 何时使用fallback: false? 如果应用只需生成少量的html时，则false比较合适。 如果不经常添加新的页面时。 二、 当getStaticPaths的fallback: true​ getStaticPaths返回的路径参数在构建时（build）由getStaticProps渲染生成HTML。 但构建时（build）没有生成的路径参数不会跳转到404页面，NextJs将在对此类路径参数的第一次请求时，提供页面的后备（fallback）版本， 在服务端，通过执行getStaticProps请求的路径参数生成HTML和JSON。 完成后，将页面发送给浏览器，从用户角度来看，页面从后备页面切换到了生成后的页面。 同时，NextJs会跟踪新的页面渲染页面列表，对同一路径的后续请求提供生成好的页面进行访问。(浏览列表页面时，会根据列表的访问情况生成后续的详情页面。) 何时使用fallback: true? 如果应用需要生成大量静态页面，则true比较合适。 如果希望生成所有产品页面，但若果有上千个产品，可能需要很长的构建时间。则可以生成一小部分受欢迎的产品静态页面，其余的使用后备（fallback）。 当有人请求尚未生成的页面时，用户将会看到带有加载状态的页面，不久之后通过getStaticProps请求到页面数据并生成静态页面，从此之后的访问该页面的人都会看到已经生成好的静态页面。 这可以确保用户得到快速的体验，同时保留快速构建和生成静态页面的优势。 三、当getStaticPaths的fallback: blocking​ fallback设置为blocking与设置为true很像，唯一区别，在第一次请求到没有生成后备（fallback）的路经参数后，会通过getStaticProps生成静态文件。但这个时候不会有加载的、后退的状态闪烁过程。这样会产生一小段的空白页面的状态。 何时使用fallback: blocking? 在交互上当页面切换时不希望有loading的呈现。 一些爬虫不支持JavaScript，加载页面时，如果是loading将导致问题的页面。 ‍ 静态生成（Static Generation）的总结优点： 静态生成是一种预渲染（pre-rendering）方法，其中HTML页面是在构建时生成的。 预渲染的静态页面可以立即推送到CDN缓存并提供给全球的客户。 静态内容对SEO来说更快更好，因为他们会被搜索引擎立即索引。 使用getStaticProps获取数据并使用getStaticPaths​生成动态页面是在应用程序生成环境中不错的方式。 缺点： 构建时间与应用中页面数量成正比。 一旦页面生成，在重新构建应用前，可能会有陈旧的历史数据。 ‍ 增量静态再生成（Incremental Static Regeneration）（ISR）只需要更新那些需要更改的页面，而无需重新构建整个应用程序。使用ISR，NextJs允许再构建应用后更新静态页面，可以生成单个页面，无需重建整个站点，有效解决数据陈旧问题。 ‍ 如何使用：在getStaticProps方法中，除了props，还可以指定revalidate这个参数。reavalidate的值，是可以重新生成页面的时间。单位：秒 ‍ 再生成（Re-generation） 仅当用户在revalidate的时间之后发起请求时才会启动再生成。 如果用户访问产品详情页面后，在页面数据变更后没有再次访问该页面，则不会发生重新生成。 realidate不是页面每10秒重新生成一次。只会在用户访问页面时发起请求，则必须启动realidate重新生成时间。 重新生成也可能失败，它会提供之前已经缓存的HTML页面，直到后续重新生成成功。 ‍ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// pages/posts/[postId].jsximport &#123; useRouter &#125; from &#x27;next/router&#x27;const Post = (&#123; post &#125;) =&gt; &#123; const router = useRouter() if (router.isFallback) &#123; return &lt;div&gt;Loading...&lt;/div&gt; &#125; return ( &lt;PostWrapper&gt; &lt;div className=&#x27;post-item&#x27;&gt; &lt;div className=&#x27;post-title&#x27;&gt;&#123;post.title&#125;&lt;/div&gt; &lt;div className=&#x27;post-body&#x27;&gt;&#123;post.body&#125;&lt;/div&gt; &lt;/div&gt; &lt;/PostWrapper&gt; )&#125;export default Postexport async function getStaticPaths() &#123; const response = await fetch(`https://jsonplaceholder.typicode.com/posts`) const data = await response.json() const paths = data.slice(0, 10).map(post =&gt; &#123; return &#123; params: &#123; postId: `$&#123;post.id&#125;` &#125; &#125; &#125;) return &#123; paths, fallback: true &#125;&#125;export async function getStaticProps(context) &#123; const &#123; params &#125; = context const response = await fetch(`https://jsonplaceholder.typicode.com/posts/$&#123;params.postId&#125;`) const data = await response.json() return &#123; props: &#123; post: data &#125;, revalidate: 10 &#125;&#125; ‍ 服务端预渲染因为静态生成还是增量静态再生成，不能实时更新数据，一些数据变化频繁的应用，使用静态生成或者增量静态再生成就不合适了。NextJs提供了getServerSideProps用来实时通过服务端获取数据并渲染。 getServerSideProps​ getServerSideProps只运行在服务端，不会在客户端运行。 在getServerSideProps中编写的代码不会发送到浏览器的JS打包中。 可以直接在getServerSideProps中编写服务器端代码，使用fs模块访问文件系统或查询数据库。 不必担心在getServerSideProps中包含API密钥，它不会发送到浏览器。 getServerSideProps只能在页面中使用，不能从常规组件文件中运行，它仅用于预渲染而不是客户端的数据获取。 getServerSideProps返回一个对象，并且对象应该包含一个props对象。 ‍ 123456789101112131415161718192021222324252627282930313233// pages/users/index.jsximport User from &#x27;@/components/user&#x27;const Users = (&#123; users &#125;) =&gt; &#123; console.log(users) return ( &lt;&gt; &lt;h4&gt;Users List&lt;/h4&gt; &#123;users.map(user =&gt; ( &lt;div key=&#123;user.id&#125;&gt; &lt;span&gt;&#123;user.name&#125;&lt;/span&gt; &lt;span&gt; - &lt;/span&gt; &lt;span&gt;&#123;user.email&#125;&lt;/span&gt; &lt;/div&gt; ))&#125; &lt;/&gt; )&#125;export default Usersexport const getServerSideProps = async () =&gt; &#123; const userResponse = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;) const userData = await userResponse.json() return &#123; props: &#123; users: userData &#125; &#125;&#125; ‍ 使用getServerSideProps可以通过参数筛选数据。 123456789101112131415161718192021222324252627282930313233// pages/posts/index.jsxconst Posts = (&#123; posts &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h2&gt;Post List&lt;/h2&gt; &#123;posts.slice(0, 30).map(post =&gt; ( &lt;div key=&#123;post.id&#125;&gt; &lt;h4&gt; &#123;post.id&#125; - &#123;post.title&#125; &lt;/h4&gt; &lt;p&gt;user: &#123;post.userId&#125;&lt;/p&gt; &lt;div&gt;&#123;post.body&#125;&lt;/div&gt; &lt;hr /&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default Postsexport async function getServerSideProps() &#123; const response = await fetch(`https://jsonplaceholder.typicode.com/posts`) const data = await response.json() return &#123; props: &#123; posts: data &#125; &#125;&#125; 通过userId获取该用户的所有文章。 123456789101112131415161718192021222324252627282930313233343536// pages/posts/[userId].jsxconst User = (&#123; userPosts, userId &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h4&gt;User: &#123;userId&#125;&lt;/h4&gt; &lt;div&gt; &#123;userPosts.map(userPost =&gt; ( &lt;div key=&#123;userPost.id&#125;&gt; &lt;h4&gt; &#123;userPost.id&#125; -&#123;userPost.title&#125; &lt;/h4&gt; &lt;p&gt;&#123;userPost.body&#125;&lt;/p&gt; &lt;hr /&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default Userexport async function getServerSideProps(context) &#123; const &#123; params &#125; = context const response = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=$&#123;params.userId&#125;`) const data = await response.json() return &#123; props: &#123; userPosts: data, userId: params.userId &#125; &#125;&#125; 通过getServerSideProps中的context不仅可以获取到传递的参数params还可以获取到所有请求和响应的对象，比如设置cookie 1234567891011121314151617181920212223242526272829303132333435363738// pages/posts/[userId].jsxconst User = (&#123; userPosts, userId &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h4&gt;User: &#123;userId&#125;&lt;/h4&gt; &lt;div&gt; &#123;userPosts.map(userPost =&gt; ( &lt;div key=&#123;userPost.id&#125;&gt; &lt;h4&gt; &#123;userPost.id&#125; -&#123;userPost.title&#125; &lt;/h4&gt; &lt;p&gt;&#123;userPost.body&#125;&lt;/p&gt; &lt;hr /&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; )&#125;export default Userexport async function getServerSideProps(context) &#123; const &#123; params, req, res &#125; = context console.log(&#x27;params&#x27;, params) console.log(&#x27;cookie&#x27;, req.headers.cookie) res.setHeader(&#x27;Set-Cookie&#x27;, [&#x27;name=Simz&#x27;]) const response = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=$&#123;params.userId&#125;`) const data = await response.json() return &#123; props: &#123; userPosts: data, userId: params.userId &#125; &#125;&#125; ‍ 客户端获取数据一些私有数据，比如一些在登录后获取的个人用户的信息，无需预渲染和从服务端获取数据。可以从客户端直接获取。同react中一样。可以使用react-query等获取数据。 ‍ 1234567891011121314151617181920212223242526272829303132// pages/albums/index.jsximport React, &#123; useEffect, useState &#125; from &#x27;react&#x27;const albums = () =&gt; &#123; const [isLoading, setIsLoading] = useState(true) const [albums, setAlbums] = useState([]) const getAlbums = async () =&gt; &#123; const response = await fetch(`https://jsonplaceholder.typicode.com/albums`) const data = await response.json() setAlbums(data) setIsLoading(false) &#125; useEffect(() =&gt; &#123; getAlbums() &#125;, []) if (isLoading) &lt;div&gt;Loading...&lt;/div&gt; return ( &lt;div&gt; &#123;albums.map(album =&gt; ( &lt;div key=&#123;album.id&#125;&gt; &lt;p&gt;&#123;album.title&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default albums ‍ SWRNextJs官方退出了一个用于数据请求的React Hooks库，类似React-Query 官方地址：https://swr.vercel.app/zh-CN ‍ 1234567891011121314151617181920212223242526import React from &#x27;react&#x27;import useSwr from &#x27;swr&#x27;const AlbumsSwr = () =&gt; &#123; const fetcher = async () =&gt; &#123; const response = await fetch(`https://jsonplaceholder.typicode.com/albums`) const data = await response.json() return data &#125; const &#123; data, error &#125; = useSwr(&#x27;albums/swr&#x27;, fetcher) if (!data) &lt;div&gt;Loading...&lt;/div&gt; if (error) &lt;div&gt;&#123;error&#125;&lt;/div&gt; return ( &lt;div&gt; &#123;data?.map(album =&gt; ( &lt;div key=&#123;album.id&#125;&gt; &lt;p&gt;&#123;album.title&#125;&lt;/p&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125;export default AlbumsSwr ‍ 使用服务端预渲染与客户端获取数据结合示例使用getServerSideProps获取初始数据，然后通过客户端发起请求，筛选数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166// pages/coffees/index.jsximport React, &#123; useState &#125; from &#x27;react&#x27;import &#123; useRouter &#125; from &#x27;next/router&#x27;import styled from &#x27;styled-components&#x27;const CoffeesWrapper = styled.div` display: flex; justify-content: center; width: 100vw; .coffee-container &#123; display: flex; justify-content: space-between; flex-direction: column; width: 1280px; height: auto; border-radius: 6px; border: 1px solid #ddd; .coffee-header &#123; flex: 0 0 auto; display: flex; justify-content: space-between; align-items: center; padding: 0 16px; height: 48px; border-radius: 6px 6px 0 0; border-bottom: 1px solid #ddd; background-color: #f4f4f4; color: #424242; font-size: 16px; .coffee-tag &#123; display: flex; justify-content: flex-end; span &#123; margin-left: 8px; padding: 4px 6px; border-radius: 4px; background-color: #e8e8e8; font-size: 12px; color: #757575; cursor: pointer; &amp;:hover &#123; background-color: #e0e0e0; color: #424242; &#125; &#125; &#125; &#125; .coffee-body &#123; flex: 1; display: flex; justify-content: space-between; flex-direction: column; padding: 0 16px; .coffee-item &#123; box-sizing: border-box; flex: 0 0 auto; display: flex; justify-content: space-between; padding: 10px 0; height: 120px; border-bottom: 1px solid #eee; .coffee-cover &#123; flex: 0 0 auto; margin-right: 16px; width: 100px; height: 100px; img &#123; width: 100%; border-radius: 6px; &#125; &#125; .coffee-content &#123; flex: 1; display: flex; justify-content: flex-start; flex-direction: column; line-height: 1.5; font-size: 14px; text-align: left; .coffee-title &#123; font-size: 16px; color: #424242; &#125; .coffee-price &#123; color: #ff222c; &#125; .coffee-text &#123; color: #757575; &#125; &#125; &#125; &#125; &#125;`const Coffees = (&#123; coffeesList &#125;) =&gt; &#123; const [coffees, setCoffees] = useState(coffeesList) const router = useRouter() const handleClickTag = async tag =&gt; &#123; const clickTag = tag ? `coffees?category=$&#123;tag&#125;` : &#x27;coffees&#x27; const response = await fetch(`http://localhost:4000/$&#123;clickTag&#125;`) const data = await response.json() setCoffees(data) router.push(`/coffees?category=$&#123;tag&#125;`, undefined, &#123; shallow: true &#125;) &#125; return ( &lt;CoffeesWrapper&gt; &lt;div className=&#x27;coffee-container&#x27;&gt; &lt;div className=&#x27;coffee-header&#x27;&gt; &lt;span&gt;Tims 咖啡&lt;/span&gt; &lt;div className=&#x27;coffee-tag&#x27;&gt; &lt;span onClick=&#123;() =&gt; handleClickTag(&#x27;&#x27;)&#125;&gt;全部&lt;/span&gt; &lt;span onClick=&#123;() =&gt; handleClickTag(&#x27;冷萃系列&#x27;)&#125;&gt;冷萃系列&lt;/span&gt; &lt;span onClick=&#123;() =&gt; handleClickTag(&#x27;鲜萃咖啡&#x27;)&#125;&gt;鲜萃咖啡&lt;/span&gt; &lt;span onClick=&#123;() =&gt; handleClickTag(&#x27;意式咖啡&#x27;)&#125;&gt;意式咖啡&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#x27;coffee-body&#x27;&gt; &#123;coffees?.map(coffee =&gt; ( &lt;div className=&#x27;coffee-item&#x27; key=&#123;coffee.id&#125;&gt; &lt;div className=&#x27;coffee-cover&#x27;&gt; &lt;img src=&#123;coffee.picture&#125; /&gt; &lt;/div&gt; &lt;div className=&#x27;coffee-content&#x27;&gt; &lt;div className=&#x27;coffee-title&#x27;&gt;&#123;coffee.name&#125;&lt;/div&gt; &lt;div className=&#x27;coffee-price&#x27;&gt;&#123;coffee.price&#125; 元&lt;/div&gt; &lt;div className=&#x27;coffee-text&#x27;&gt;&#123;coffee.category&#125;&lt;/div&gt; &lt;div className=&#x27;coffee-text&#x27;&gt;&#123;coffee.description&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/CoffeesWrapper&gt; )&#125;export default Coffeesexport async function getServerSideProps(context) &#123; const &#123; query &#125; = context const &#123; category &#125; = query console.log(&#x27;category&#x27;, category) const queryString = category ? `category=$&#123;category&#125;` : &#x27;&#x27; const response = await fetch(`http://localhost:4000/coffees?$&#123;queryString&#125;`) const data = await response.json() return &#123; props: &#123; coffeesList: data &#125; &#125;&#125; ‍ 预渲染和获取数据总结预渲染是指在服务端提前生成HTML的过程，这会带来更好的性能和SEO，NextJs支持两种形式的预渲染：静态生成和服务器端渲染。 ‍ 静态生成（Static Generation）一种在构建时(pnpm build)时生成HTML页面的预渲染方法。页面可以一次性构建后，由CDN缓存。如营销或博客网站。 对于普通页面，使用getStaticProps方法提前获取数据 对于动态页面，还需要使用getStaticPaths方法 后备数据（fallback）的三个参数：false、true、blocking 如果页面没有完全重新构建，页面将无法更新，在这种情况下可以使用增量静态再生成。 ‍ 服务端渲染（Server-side rendering）在请求时获取数据，根据传入请求中的参数处理数据。示例：新闻、产品列表页面。 getServerSideProps方法可以帮助获取服务端数据 将服务端预渲染与客户端数据获取相结合 在客户端获取数据时使用浅层路由Shallow routing，不调用getStaticProps或getServerSideProps的路由。 ‍ ‍","permalink":"http://example.com/2022/10/01/NextJS%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/","photos":[]},{"tags":[{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"},{"name":"prettier","slug":"prettier","permalink":"http://example.com/tags/prettier/"},{"name":"eslint","slug":"eslint","permalink":"http://example.com/tags/eslint/"}],"title":"使用vite-pretty-lint更加快速的配置ESLint和Prettier","date":"2022/09/13","text":"有的时候就是遇到麻烦了才回去想解决办法。这不，今天在公司装了1个小时的ESLint，魔障了一样，就是有问题。于是回家的路上看了下有没有类似的解决办法，就看到了这个神器——vite-pretty-lint 步骤如下： 还是正常的使用pnpm来安装vite项目 1pnpm create vite 创建好目录后，cd进入到目录中，pnpm i装下相关包文件。 然后再使用如下命令： 1pnpm create vite-pretty-lint 仅仅数秒钟，就已经帮你把项目中的ESLint和Prettier配置完了。剩下的补充一些你的偏好配置即可。 .prettierrc.json中修改下 12345678910&#123; &quot;trailingComma&quot;: &quot;none&quot;, &quot;printWidth&quot;: 100, &quot;tabWidth&quot;: 2, &quot;semi&quot;: false, &quot;singleQuote&quot;: true, &quot;useTabs&quot;: false, &quot;jsxSingleQuote&quot;: true, &quot;bracketSpacing&quot;: true&#125; .eslintrc.json中修改下rules： 123456789&quot;rules&quot;: &#123; &quot;react/react-in-jsx-scope&quot;: &quot;off&quot;, &quot;prettier/prettier&quot;: &quot;off&quot;, &quot;arrow-body-style&quot;: &quot;off&quot;, &quot;prefer-arrow-callback&quot;: &quot;off&quot;, &quot;no-undef&quot;: &quot;off&quot;, &quot;no-unused-vars&quot;: &quot;off&quot;, &quot;react/prop-types&quot;: &quot;off&quot;&#125; 大功告成，再也不用傻傻的一个个命令敲打，一个劲的装着有问题了。~","permalink":"http://example.com/2022/09/13/%E4%BD%BF%E7%94%A8vite-pretty-lint%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F%E7%9A%84%E9%85%8D%E7%BD%AEESLint%E5%92%8CPrettier/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"icon","slug":"icon","permalink":"http://example.com/tags/icon/"}],"title":"攒个Icon组件2.0","date":"2022/08/19","text":"上周看到vant react版升到了3，发现弄了很多新东西，其中就有将所有的Icon都换成了svg的了。于是研究了下，传统的fonts和css的组合似乎，因为字体文件的存在，打包会影响包体积，所以用svg加上打包工具的Tree Shaking，只需要将用到的图标保留，没用的不打包进去就可以了。另外，svg的矢量显示效果比字体图标显示效果更好，所以，svg将会是以后更多的选择。 svg刚好上周也有看到相关的视频，稍微了解了下。于是搞了个demo研究了下，怎么使用svg的Icon。如果能将Remixicon的图标都转成svg icon就更妙了。 首先想到了字节的Icon pack 看到他们里面有介绍到svg sprite map，于是试了下他们的在线项目，结果只能传500个svg，Remixicon有2k+的图标，显然不够。 找了很久，想到最近用的vite也到3了，做了许多demo了，看看他们有没有插件，果然找到了vite-plugin-svg-icons，这个插件作者是vben的作者，之前搞vue时好像看到过说是个很屌的大佬。 vite-plugin-svg-icons 直接上插件地址，用法也很简单。 另外，因为之前用mantine的关系，看了下另外一个css in js的工具，emotion。跟styled-components的用法差不多，甚至更灵活些。它也有和styled-components 类似的styled的写法，写起来和styled-components一毛一样。只是有些方法在@emotion/react这个模块上。所以这次改造，也用上emotion。 先装好vite的插件 1yarn add vite-plugin-svg-icons -D 需要注意：今天在测试的时候，发现安装后有一些插件相关的包没有一起安装上，重装试了很多次都不行，最后从原来的项目里将相应的包拷贝过来才运行起来。 在vite.config.js中进行配置 12345678910111213141516171819import &#123; createSvgIconsPlugin &#125; from &#x27;vite-plugin-svg-icons&#x27;import path from &#x27;path&#x27;export default () =&gt; &#123; return &#123; plugins: [ createSvgIconsPlugin(&#123; // 指定需要缓存的图标文件夹 iconDirs: [path.resolve(process.cwd(), &#x27;src/assets/icons&#x27;)], // 指定symbolId格式 icon-[dir]-[name] symbolId: &#x27;[name]&#x27;, // 自定义插入位置 &#x27;body-last&#x27; | &#x27;body-first&#x27; @default: body-last inject: &#x27;body-last&#x27;， // custom dom id customDomId: &#x27;__svg__icons__dom__&#x27;, &#125;), ], &#125;&#125; 在src/main.js中注入脚本 1import &#x27;virtual:svg-icons-register&#x27; 然后来定义Icon组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123; memo &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import styled from &#x27;@emotion/styled&#x27;import &#123; keyframes &#125; from &#x27;@emotion/react&#x27;const rotate = keyframes` from &#123; transform: rotate(0) &#125; to &#123; transform: rotate(360deg) &#125;`const IconWrapper = styled.span` display: flex; justify-content: center; align-items: center; width: $&#123;(props) =&gt; (props.size || 16) + &#x27;px&#x27;&#125;; height: $&#123;(props) =&gt; (props.size || 16) + &#x27;px&#x27;&#125;; animation: $&#123;(props) =&gt; (props.spin ? rotate : null)&#125; 1s linear infinite; .svg-icon &#123; width: $&#123;(props) =&gt; props.size + &#x27;px&#x27; || &#x27;16px&#x27;&#125;; height: $&#123;(props) =&gt; props.size + &#x27;px&#x27; || &#x27;16px&#x27;&#125;; &#125;`function Icon(&#123; name, size, color, type, spin, ...props &#125;) &#123; return ( &lt;IconWrapper size=&#123;size&#125; spin=&#123;spin&#125; &#123;...props&#125;&gt; &lt;svg className=&quot;svg-icon&quot; fill=&#123;color&#125; aria-hidden=&quot;true&quot;&gt; &lt;use href=&#123;`#$&#123;name&#125;-$&#123;type&#125;`&#125; fill=&#123;color&#125; /&gt; &lt;/svg&gt; &lt;/IconWrapper&gt; )&#125;Icon.defaultProps = &#123; name: &#x27;heart&#x27;, type: &#x27;line&#x27;, size: 16, color: &#x27;&#x27;, spin: false&#125;Icon.propTypes = &#123; name: PropTypes.string.isRequired, type: PropTypes.oneOf([&#x27;line&#x27;, &#x27;fill&#x27;]), size: PropTypes.number, color: PropTypes.string, spin: PropTypes.bool&#125;export default memo(Icon) svg是使用fill修改颜色，如果有默认值就无法修改了，所以这里没有像之前写了默认颜色，所以每次都需要手动默认颜色，或者直接定义样式。这样就可以指定active和hover的颜色了。","permalink":"http://example.com/2022/08/19/%E6%94%92%E4%B8%AAIcon%E7%BB%84%E4%BB%B62-0/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}],"title":"Object.entries方法","date":"2022/08/08","text":"最近在做Mac版的Netease Music的项目，在参考大佬的源码的时候看到了这个方法Object.entries，感觉甚妙，故记录之。 在项目中，有个歌单分类，返回的数据中，一组为一级分类的对象，一组为二级分类的数组。二级分类上有一级分类的值。 参考地址：歌单分类API 一级分类为对象，需要遍历出key和value，使用Object.entries就可以拿到key和value，并map出所有的一级分类，然后通过key，filter出二级分类中相应的子分类，并map出来。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839const DEFAULT_CAT = &#x27;全部&#x27;const [currentCat, setCurrentCat] = useState(selectedCat || DEFAULT_CAT)const handleCatClick = (cat: string) =&gt; &#123; setCurrentCat(cat) onCatSelect(cat)&#125;const renderCats = () =&gt; &#123; return ( &lt;div className=&#x27;popover&#x27;&gt; &lt;div className=&#x27;all&#x27;&gt; &lt;span className=&#123;currentCat === DEFAULT_CAT ? &#x27;active&#x27; : &#x27;&#x27;&#125; onClick=&#123;() =&gt; handleCatClick(DEFAULT_CAT)&#125;&gt; 全部歌单 &lt;/span&gt; &lt;/div&gt; &lt;div className=&quot;content&quot;&gt; &#123;Object.entries(cats.categories).map(([key, value]) =&gt; &#123; const subCats = cats.sub.filter((&#123;category&#125;) =&gt; category === Number(key)) return ( &lt;div className=&#x27;cat-block&#x27; key=&#123;key&#125;&gt; &lt;div className=&#x27;label&#x27;&gt;&#123;value&#125;&lt;/div&gt; &lt;div className=&#x27;content&#x27;&gt; &#123;subCats.map((&#123;name&#125;) =&gt; ( &lt;div key=&#123;name&#125; className=&#123;currentCat === name ? &#x27;active&#x27;: &#x27;&#x27;&#125; onClick=&#123;() =&gt; handleCatClick(name)&#125; &gt;&#123;name&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; &lt;/div&gt; &lt;/div&gt; )&#125; 顺便学习下Object.entries相关的方法Object.keys和Object.values entries可以将key和value同时取出。 keys则只是取出key values取出value 以后遇到对象转数组就不用怕了~ 123456789101112131415161718192021222324252627282930313233343536import React from &#x27;react&#x27;const categories = &#123; 0: &#x27;语种&#x27;, 1: &#x27;风格&#x27;, 2: &#x27;场景&#x27;, 3: &#x27;情感&#x27;, 4: &#x27;主题&#x27;&#125;export default function ObjectFunc() &#123; const keys = Object.keys(categories) const values = Object.values(categories) const entriesMap = Object.entries(categories) return ( &lt;div&gt; ObjectFunc &lt;div&gt; &lt;span&gt;Keys: &lt;/span&gt; &#123;keys.map((item, index) =&gt; ( &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;div&gt; &lt;span&gt;Values: &lt;/span&gt; &#123;values.map((item, index) =&gt; ( &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;div&gt; &lt;span&gt;Entries: &lt;/span&gt; &#123;entriesMap.map(([key, value]) =&gt; ( &lt;div key=&#123;key&#125;&gt;&#123;value&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; )&#125; 相反，还有个数组转对象的方法Object.fromEntries，和Object.entries一起看下就明白了 1234567const object = &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125;const array = Object.entries(object)// [ [&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;] ]Object.fromEntries(array)// &#123; key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27; &#125; ES6之后增加了很多新的方法要多看看掌握核心科技~","permalink":"http://example.com/2022/08/08/Object-entries%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"styled-components","slug":"styled-components","permalink":"http://example.com/tags/styled-components/"}],"title":"Styled Components + Context 打造主题切换","date":"2022/07/29","text":"这两天在看Mantine，里面有自带的主题切换，试了下，感觉过于复杂context的Privoder都要包两层，另外Mantine的css in js 方案使用的是emotion，过于小众和繁琐，不如在styled-components中写css的流畅。所以翻了很久掘金挖宝，果然挖到一宝。Up是椒盐味花生米，使用context修改styled-components的GlobalStyle，并且将配色方案保存在localstorage中，重启浏览器效果依然得以保存。但是他的方案使用的是redux toolkit，并且只能切换明亮和暗黑两种主题，我改成了mobx和多主题，本来想用更轻量的Jotai状态库来试下的，但是Jotai还没摸透，等下次吧。 目录结构：1234567891011121314/src /store /index.jsx // 合并状态并存到context中 /theme.store.jsx //保存主题状态 /styles /themes // 主题文件夹 /index.jsx // 将主题装入context /blue.theme.jsx // 蓝色主题方案 /dark.theme.jsx // 暗黑主题方案 /light.theme.jsx // 明亮主题方案 /global.style.jsx // styled-components 系统默认样式 /pages /home.jsx // 展示页面 /App.jsx // 根组件 Mobx实现store将主题状态存入store，便于在多个页面进行切换设置。 1234567891011121314151617181920212223// /src/store/theme.store.jsximport &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;// 获取localstorage中的主题const localTheme = localStorage.getItem(&#x27;theme&#x27;)class ThemeStore &#123; theme = localTheme ? localTheme : &#x27;light&#x27; // 如果localstorage中有主题则使用，否则使用明亮主题 constructor() &#123; makeAutoObservable(this) &#125; // 设置主题 setTheme = (data) =&gt; &#123; this.theme = data &#125; // 修改主题 changeTheme = (state) =&gt; &#123; this.setTheme(state) // 将得到的主题存入store localStorage.setItem(&#x27;theme&#x27;, state) // 将得到的主题存入localstorage &#125;&#125;export default ThemeStore 让后将theme.store.jsx文件中的ThemeStore放入store/index.jsx合并并包装入context，这里其实跟redux toolkit有点像，他是将theme.slice放入index文件中进行合并导出。 12345678910111213141516// /scr/store/index.jsximport &#123; useContext, createContext &#125; from &#x27;react&#x27;import ThemeStore from &#x27;./theme.store&#x27;class RootStore &#123; constructor() &#123; this.themeStore = new ThemeStore() &#125;&#125;const rootStore = new RootStore()const context = createContext(rootStore)const useStore = () =&gt; useContext(context)export default useStore 配置Styles在styles/themes/目录下创建相应的主题配置。因为内容类似，就放在一起了。 主要改两个位置的样式，页面body的背景色和header容器的背景色。 1234567891011121314151617181920212223242526272829303132333435// /src/styles/themes/blue.theme.jsxconst blueTheme = &#123; colors: &#123; body: &#x27;lightBlue&#x27; &#125;, header: &#123; backgroundColor: &#x27;#0099e8&#x27; &#125;&#125;export default blueTheme// /src/styles/themes/dark.theme.jsxconst darkTheme = &#123; colors: &#123; body: &#x27;#777&#x27; &#125;, header: &#123; backgroundColor: &#x27;#424242&#x27; &#125;&#125;export default darkTheme// /src/styles/themes/light.theme.jsxconst lightTheme = &#123; colors: &#123; body: &#x27;#fff&#x27; &#125;, header: &#123; backgroundColor: &#x27;#f4f4f4&#x27; &#125;&#125;export default lightTheme 再来关键的一个封装，将styled-components的主题支持ThemeProvider封装。然后再将封装好的Provider 去包装根组件。 123456789101112131415161718192021222324252627282930313233343536// /src/styles/themes/index.jsximport React from &#x27;react&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;import &#123; ThemeProvider &#125; from &#x27;styled-components&#x27;import useStore from &#x27;@/store&#x27;import darkTheme from &#x27;./dark.theme&#x27;import lightTheme from &#x27;./light.theme&#x27;import blueTheme from &#x27;./blue.theme&#x27;const ThemeProviderWrapper = (props) =&gt; &#123; const &#123;themeStore: &#123; theme &#125;&#125; = useStore() // 从store中获取主题 const switchTheme = () =&gt; &#123; // 将获取到的主题来匹配对应的主题方案，并return出来给到ThemeProvider switch (theme) &#123; case &#x27;dark&#x27;: return darkTheme case &#x27;light&#x27;: return lightTheme case &#x27;blue&#x27;: return blueTheme default: return darkTheme &#125; &#125; return ( // &lt;ThemeProvider theme=&#123;theme === &#x27;dark&#x27; ? darkTheme : lightTheme&#125; &#123;...props&#125;&gt; // 如果只有两个主题这个更简单 &lt;ThemeProvider theme=&#123;switchTheme&#125; &#123;...props&#125;&gt; &#123;theme&#125; &#123;props.children&#125; &lt;/ThemeProvider&gt; )&#125;// 因为有用到mobx所以记得这里要用observer来包裹下export default observer(ThemeProviderWrapper) 然后再使用styled-components设置全局样式GlobalStyles 1234567891011import &#123; createGlobalStyle &#125; from &#x27;styled-components&#x27;const GlobalStyle = createGlobalStyle` body &#123; background-color:$&#123;(props) =&gt; props.theme.colors.body&#125;; &#125; .header &#123; background-color:$&#123;(props) =&gt; props.theme.header.backgroundColor&#125;; &#125;`export default GlobalStyle 如何使用首先将封装的ThemeProviderWrapper包裹下根组件，并且将GlobalStyles也包裹进其中，让其生效。 12345678910111213141516import React from &#x27;react&#x27;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;import RootRouter from &#x27;@/router&#x27;import ThemeProviderWrapper from &#x27;@/styles/themes&#x27;import GlobalStyle from &#x27;@/styles/global.style&#x27;export default function App() &#123; return ( &lt;BrowserRouter&gt; &lt;ThemeProviderWrapper&gt; &lt;GlobalStyle /&gt; &lt;RootRouter /&gt; &lt;/ThemeProviderWrapper&gt; &lt;/BrowserRouter&gt; )&#125; 如果需要在同一个按钮上切换，写个方法即可。 1234567891011121314151617181920212223// /src/pages/home.jsximport React from &#x27;react&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;import useStore from &#x27;@/store&#x27;function Rank() &#123; const &#123; themeStore &#125; = useStore() const &#123; theme, changeTheme &#125; = themeStore return ( &lt;div&gt; &lt;div&gt;Rank&lt;/div&gt; &lt;div&gt;&#123;theme&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; changeTheme(&#x27;light&#x27;)&#125;&gt;change light theme&lt;/button&gt; &lt;button onClick=&#123;() =&gt; changeTheme(&#x27;dark&#x27;)&#125;&gt;change dark theme&lt;/button&gt; &lt;button onClick=&#123;() =&gt; changeTheme(&#x27;blue&#x27;)&#125;&gt;change blue theme&lt;/button&gt; &lt;div className=&quot;header&quot; style=&#123;&#123; width: &#x27;100%&#x27;, height: &#x27;56px&#x27; &#125;&#125;&gt;&lt;/div&gt; &lt;/div&gt; )&#125;export default observer(Rank) 总结store使用mobx感觉还是有些过重，并且每次都需要将使用mobx的组件页面使用observer进行包裹很麻烦，有时候总是忘记，调了半天才想起来是没进行包裹，mobx无法产生响应式观察。后续Jotai研究出来了，在来替换吧。","permalink":"http://example.com/2022/07/29/Styled-Components-Context-%E6%89%93%E9%80%A0%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"icon","slug":"icon","permalink":"http://example.com/tags/icon/"}],"title":"攒个Icon组件","date":"2022/07/28","text":"经常会用到RemixIcon的图标，所以每次都得整半天，所以干脆攒个Icon的组件好了，下次直接用。 组件代码因为依赖RemixIcon和styled-components，所以也需要安装这两个package。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;import styled, &#123; keyframes &#125; from &#x27;styled-components&#x27;import &#x27;remixicon/fonts/remixicon.css&#x27;const rotate = keyframes` from &#123; transform: rotate(0) &#125; to &#123; transform: rotate(360deg) &#125;`const IconWrapper = styled.span` display: flex; justify-content: center; align-items: center; width: $&#123;(props) =&gt; (props.size || 16) + &#x27;px&#x27;&#125;; height: $&#123;(props) =&gt; (props.size || 16) + &#x27;px&#x27;&#125;; font-size: $&#123;(props) =&gt; (props.size || 16) + &#x27;px&#x27;&#125;; color: $&#123;(props) =&gt; props.color || &#x27;#9e9e9e&#x27;&#125;; animation: $&#123;(props) =&gt; (props.spin ? rotate : null)&#125; 1s linear infinite;`function Icon(&#123; icon, type, size, color, spin &#125;) &#123; return ( &lt;IconWrapper size=&#123;size&#125; color=&#123;color&#125; spin=&#123;spin&#125;&gt; &lt;i className=&#123;`ri-$&#123;icon ? icon : heart&#125;-$&#123;type ? type : line&#125;`&#125;&gt;&lt;/i&gt; &lt;/IconWrapper&gt; )&#125;Icon.defaultProps = &#123; icon: &#x27;heart&#x27;, type: &#x27;line&#x27;, size: 16, color: &#x27;#9e9e9e&#x27;, spin: false&#125;Icon.propTypes = &#123; icon: PropTypes.string.isRequired, type: PropTypes.oneOf([&#x27;line&#x27;, &#x27;fill&#x27;]), size: PropTypes.number, color: PropTypes.string, spin: PropTypes.bool&#125;export default Icon Porps 参数 说明 类型 默认值 icon 图标内容，见remixicon string heart type 图标类型，包括：line | fill line | fill line size 图标大小 number 16px color 图标颜色 string #9e9e9e spin 是否旋转 boolean false","permalink":"http://example.com/2022/07/28/%E6%94%92%E4%B8%AAIcon%E7%BB%84%E4%BB%B6/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"react-router","slug":"react-router","permalink":"http://example.com/tags/react-router/"}],"title":"React Router v6 组件懒加载","date":"2022/07/27","text":"还是React Router V6，在v5的时候组件懒加载只需要在路由页面使用lazy方法import组件后，然后在App组件外层包一层Suspense后就可以实现了，在v6里就搞得很麻烦，因为Suspense包在了每个路由的外面。 V5与V6使用比较12345678910111213141516171819202122232425262728293031323334353637// v5// routes里const routes = [ &#123; path: &#x27;/user/home&#x27;, component: React.lazy(() =&gt; import(&#x27;@/pages/home&#x27;)) // 组件懒加载 &#125;, ...]// Suspense包裹在APP中包裹路由就可以了function App() &#123; return ( &lt;HashRouter&gt; &lt;Suspense fallback=&#123;&lt;LazyLoading /&gt;&#125;&gt; &lt;ContextProvider&gt;&#123;renderChildren(routes)&#125;&lt;/ContextProvider&gt; &lt;/Suspense&gt; &lt;/HashRouter&gt; );&#125;// v6const HomeLazy = lazy(() =&gt; import(&#x27;@/pages/home&#x27;)) // 组件懒加载const routes = [ &#123; path: &#x27;home&#x27;, element: ( &lt;Suspense fallback=&#123;&lt;LazyLoading /&gt;&#125;&gt; // Suspense包裹在了组件懒加载的外面 &lt;HomeLazy /&gt; &lt;/Suspense&gt; ) &#125; ...] V6中组件懒加载方法这就搞的很麻烦，不但代码量增加，这样搞得每个element都需要包裹一个Suspense，体力活增加了。 借用掘金佟舟大神的方法，写起来就就简单了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// /src/router/index.jsximport React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;import &#123; Navigate, useRoutes &#125; from &#x27;react-router-dom&#x27;const routes = [ &#123; path: &#x27;/&#x27;, element: () =&gt; import(&#x27;@/pages/Home&#x27;), children: [ &#123; path: &#x27;/&#x27;, element: &lt;Navigate to=&#x27;/discover&#x27; /&gt; &#125;, &#123; path: &#x27;discover&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover&#x27;), children: [ &#123; index: true, element: () =&gt; import(&#x27;@/pages/Home/Discover/Recommend&#x27;)&#125;, &#123; path: &#x27;recommend&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover/Recommend&#x27;) &#125;, &#123; path: &#x27;playlist&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover/Playlist&#x27;) &#125;, &#123; path: &#x27;djradio&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover/Djradio&#x27;) &#125;, &#123; path: &#x27;rank&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover/Rank&#x27;) &#125;, &#123; path: &#x27;artists&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover/Artists&#x27;) &#125;, &#123; path: &#x27;latesmusic&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Discover/LatesMusic&#x27;) &#125;, ] &#125;, &#123; path: &#x27;/video&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Video&#x27;) &#125;, &#123; path: &#x27;/friend&#x27;, element: () =&gt; import(&#x27;@/pages/Home/Friend&#x27;) &#125;, ] &#125;, &#123; path: &#x27;/login&#x27;, element: () =&gt; import(&#x27;@/pages/Login&#x27;) &#125;, &#123; path: &#x27;/search&#x27;, element: () =&gt; import(&#x27;@/pages/Search&#x27;) &#125;,]function LazyElement(&#123; importFunc &#125;) &#123; const LazyComponent = lazy(importFunc) return ( &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;LazyComponent /&gt; &lt;/Suspense&gt; )&#125;// element如果是懒加载，则包裹Suspense(function dealRoutes(routesArr) &#123; if (routesArr &amp;&amp; Array.isArray(routesArr) &amp;&amp; routesArr.length &gt; 0) &#123; routesArr.forEach((route) =&gt; &#123; if (route.element &amp;&amp; typeof route.element == &#x27;function&#x27;) &#123; const importFunc = route.element route.element = &lt;LazyElement importFunc=&#123;importFunc&#125; /&gt; &#125; if (route.children) &#123; dealRoutes(route.children) &#125; &#125;) &#125;&#125;)(routes)export default function RootRoutes() &#123; const element = useRoutes(routes) return element&#125; 以上就完成组件懒加载，完美~","permalink":"http://example.com/2022/07/27/React-Router-v6-%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"react-router","slug":"react-router","permalink":"http://example.com/tags/react-router/"}],"title":"React Router V6 三级目录跳转","date":"2022/07/27","text":"之前在做看Coderwhy的网易云音乐的项目时，遇到了一个问题，因为网易云音乐在进入站点后，会从根目录跳转到三级目录下，经过 发现 （Discover），到推荐 （recommend）页面。coderwhy是用的react-router-dom v5的版本，所以使用了react-router-config这个插件，可以render到一个目录下，但react-router-dom v6的版本 react-router-config这个插件就用不了了，只能使用useRoutes这个来代替之前的集中式路由导航。这个里面并没有render这个方法，一些api也有变化，没有direct，使用Navigate来代替了。总之搞得头很大。 试了很多方法，v6，在跳转到二级目录后，则不能直接跳转到三级，今天在小破站看到大神介绍v6 的一些功能，受到了一些启发，他是做到页面上的Routes和Route路由配置，跟useRoutes这块的路由还是区别很大，useRouter这种和vue-router的配置就很像了。但是还是缺了vue-router的路由守卫… 之前一直在没跳脱出来一直调整二级到三级的跳转方式，或者使用三级做二级的首页，但pathname上又不能统一，会造成在发现（Discover）上，能显示推荐（Recommend）的内容，但是无法让NavLink上的链接高亮，虽然可以用useLocation的土办法直接去匹配字符串，但是始终是不完美的。 下面是可以来完美实现从根目录直接跳转到三级目录的代码。 12345678910111213141516171819202122232425262728293031323334import React from &#x27;react&#x27;import &#123; useRoutes, Navigate &#125; from &#x27;react-router-dom&#x27;import Home from &#x27;../pages/Home&#x27;import Discover from &#x27;../pages/Home/Discover&#x27;import Recommend from &#x27;../pages/Home/Discover/Recommend&#x27;import Playlist from &#x27;../pages/Home/Playlist&#x27;import Rank from &#x27;../pages/Home/Rank&#x27;const routes = [ &#123; path: &#x27;/&#x27;, element: &lt;Home /&gt;, children: [ &#123; path: &#x27;/&#x27;, element: &lt;Navigate to=&quot;/discover&quot; /&gt; &#125;, &#123; path: &#x27;discover&#x27;, element: &lt;Discover /&gt;, children: [ &#123; path: &#x27;/discover&#x27;, element: &lt;Navigate to=&quot;/discover/recommend&quot; /&gt; &#125;, &#123; path: &#x27;/discover/recommend&#x27;, element: &lt;Recommend /&gt; &#125; ] &#125;, &#123; path: &#x27;Rank&#x27;, element: &lt;Rank /&gt; &#125;, &#123; path: &#x27;Playlist&#x27;, element: &lt;Playlist /&gt; &#125; ] &#125;, &#123; path: &#x27;*&#x27;, element: &lt;div&gt;Pathname Error&lt;/div&gt; &#125;]export default function RootRoutes() &#123; const el = useRoutes(routes) return el&#125; 其实也很简单，在二级跳转到三级的时候需要完整的从一级到二级的路径，如果只有单一的二级路径，则会报错。","permalink":"http://example.com/2022/07/27/React-Router-V6-%E4%B8%89%E7%BA%A7%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC/","photos":[]},{"tags":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"},{"name":"elint","slug":"elint","permalink":"http://example.com/tags/elint/"},{"name":"prettier","slug":"prettier","permalink":"http://example.com/tags/prettier/"}],"title":"React + Vite + ESLint + Prettier","date":"2022/07/25","text":"Vite到3了，在React中比自带的create-react-app，快太多，用上就基本换不过去的感觉。记录下配置ESLint和Prettier，看了很多教程，配置大多都是和Typescript一起，本人还未到那个层级，只能上JS。废话少说开始干活~ 创建项目1yarn create vite 然后提示输入项目名称 my-app ，进入项目 cd my-app，安装依赖 yarn，然后启动项目yarn dev。运行后，vite项目的默认端口改成了5173。 ESLint12345678910npm init @eslint/config// How would you like to use ESLint? Yes// What type of modules does your project use? esm// Which framework does you project use? react// Does your project use TypeScript? No// Where does your code run? browse// What format do you want your config file to be in? JavaScript// Would you like to install them now? Yes... 安装成功后 ESLint 帮我们创建了 .eslintrc.cjs 配置文件（cjs 是指 CommonJS 格式）,先不管，安装Prettier Prettier1yarn add prettier -D 然后再根目录创建 .prettierrc.cjs 配置文件 12345678910module.exports = &#123; printWidth: 80, tabWidth: 2, useTabs: false, singleQuote: true, jsxSingleQuote: true, semi: false, trailingComma: &quot;none&quot;, bracketSpacing: true&#125; 需要注意：jsxSingleQuote: true 这条默认是false，如果设置为true，让jsx中使用单引号，就需要在ESLint中配置&#39;prefer-single&#39;: &#39;on&#39;开启，否则报错 ESLint + Prettier接下来在 ESLint 中引入 Prettier，安装相关依赖。 1yarn add eslint-config-prettier eslint-plugin-prettier -D 再来配置下 .eslintrc.cjs 123456789101112131415161718192021222324252627282930313233module.exports = &#123; env: &#123; browser: true, es2021: true &#125;, extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:react/recommended&#x27;, &#x27;plugin:prettier/recommended&#x27;, &#x27;plugin:react/jsx-runtime&#x27; ], parserOptions: &#123; ecmaFeatures: &#123; jsx: true &#125;, ecmaVersion: &#x27;latest&#x27;, sourceType: &#x27;module&#x27; &#125;, plugins: [&#x27;react&#x27;, &#x27;prettier&#x27;], rules: &#123; &#x27;prettier/prettier&#x27;: &#x27;error&#x27;, &#x27;arrow-body-style&#x27;: &#x27;off&#x27;, &#x27;prefer-arrow-callback&#x27;: &#x27;off&#x27;, &#x27;no-undef&#x27;: &#x27;off&#x27;, &#x27;no-unused-vars&#x27;: &#x27;off&#x27;, &#x27;react/prop-types&#x27;: &#x27;off&#x27; &#125;, settings: &#123; react: &#123; version: &#x27;detect&#x27; &#125; &#125;&#125; 这几个配置需要注意下，ESLine还是过分BT 123&#x27;no-undef&#x27;: &#x27;off&#x27;, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到&#x27;no-unused-vars&#x27;: &#x27;off&#x27;, // 禁止出现未使用过的变量&#x27;react/prop-types&#x27;: &#x27;off&#x27; // 禁用道具类型验证 Vite 中引入 ESLint1yarn add vite-plugin-eslint -D 再来配置下vite.config.js， 123456789101112131415161718192021import &#123; defineConfig &#125; from &#x27;vite&#x27;// import react from &#x27;@vitejs/plugin-react&#x27;import reactRefresh from &#x27;@vitejs/plugin-react-refresh&#x27;import path from &#x27;path&#x27;import viteEslint from &#x27;vite-plugin-eslint&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ reactRefresh(), viteEslint(&#123; failOnError: false &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;/src&#x27;) &#125; &#125;&#125;) 以上配置基本完成。","permalink":"http://example.com/2022/07/25/React-vite-ESLint/","photos":[]},{"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"nextjs","slug":"nextjs","permalink":"http://example.com/tags/nextjs/"}],"title":"Next.js学习笔记","date":"2022/06/14","text":"最近在学习Next，这是一个与React相关的应用框架。最近需要使用Next做项目，所以跟着视频一起学了些东西，本文作为笔记进行记录。 因为网络上大多视频，时间比较久远，就导致很多代码的框架、模块的版本发送了很多变化，导致很多功能都发生了很大的变化，当然老的技术你可以学，但是新的还是要学的。比如：最近学了Redux，大多视频讲的都是Redux4.x，结果现在redux官方现在推荐使用ReduxToolkit。东西当然优化了很多，没有原来那么麻烦，但是资料也少啊 ，遇到很多问题，还在摸索。 出现这种情况的还有React，现在网上很多视频打着2022最新教程，讲着React16.13或者17.x的内容，现在React官方已经到了18.x了。看介绍说是优化了很多性能上的东西，但功能也有些调整，还没来得及了解。 列举下最近技术框架发生的变化： React 当前版本是18.1.0。入口文件的写法调整了，开始学的时候就是一个大坑。不过还好其他的功能变化不是太多。 Redux当前版本是4.2，但是官方建议使用ReduxToolkit，来优化原来的繁琐操作，ReduxToolkit内置了redux-thunk，调整了action和reducer的写法，可以写到一起作为一个状态切片。在store中合并切片导出。 Mobx是一个比Redux好用很多的状态管理库，现在版本是6.6.0，较之前5的写法上优化了很多，可以不适用装饰器，可以通过context传递状态，可以使用makeAutoObservable来对状态进行自动观察，并且可以指定观察类型，并且绑定this。 React-router当前版本是6.3，相较于5的内容，调整了很多写法，之前的react-router-config在6中不好使了，但是可以useRoutes来代替，但某些场景似乎有问题。官方文档就是个渣，搜索都没有。 Next当前版本是12.1.6，好在功能上做了很多优化，功能目前了解到的变化不多。css可以直接引用不需要配置babel，css in js框架内置了styled-jsx，可以实现类似vue种的直接写style，无需引用。使用styled-components，也只需要在next.config.js中配置一下了 好了这里还是说回Next。已下为记录Next功能笔记，所有代码都已亲自敲过并验证。 安装：1npx create-next-app my-next-app Next项目结构 1234/.next/pages/public/styles /pages放着项目所有的页面文件 /public目录放着项目所有公共文件 /styles目录放着项目所有公共样式文件 Next路由Next使用的是约定式路由模式，在pages目录下存放的每个文件和文件夹都是一个路由，如：/指的是pages下的index.js文件。/blog只的是blog.js或者blog目录下的index.js 在next项目中直接使用a标签进行跳转在跳转过程中，由于是服务端渲染，会加载很多相关依赖的js。这里就需要使用next链接标签Link。 基本路由链接1234567891011/pages/index.jsimport Link from &#x27;next/link&#x27;export default function Hello() &#123; return ( &lt;div&gt; &lt;Link href=&quot;/blog/post&quot;&gt;&lt;a&gt;博客首页&lt;/a&gt;&lt;/Link&gt; &lt;/div&gt; )&#125; 路由传参通过param传参 123456789101112131415161718192021222324252627282930/pages/index.jsimport Link from &#x27;next/link&#x27;export default function Home() &#123; const users = [&#x27;John&#x27;, &#x27;Jane&#x27;, &#x27;Bob&#x27;] return ( &lt;&gt; &lt;h2&gt;Next首页&lt;/h2&gt; &lt;hr /&gt; &#123;/* 基础路由传参 */&#125; &lt;Link href=&#x27;/user/Jack&#x27;&gt; &lt;a&gt;Jack detail&lt;/a&gt; &lt;/Link&gt; &lt;br /&gt; &#123;/* 批量模式 */&#125; &lt;ul&gt; &#123;users.map(user =&gt; &#123; return ( &lt;li key=&#123;user&#125;&gt; &lt;Link href=&#123;`/user/$&#123;user&#125;`&#125;&gt; &lt;a&gt;&#123;user&#125; detail&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ) &#125;)&#125; &lt;/ul&gt; &lt;/&gt; )&#125; 注意文件需要以参数形式命名[ ]param形式 12345678910/pages/user/[name].jsimport &#123; useRouter &#125; from &#x27;next/router&#x27;export default function Index() &#123; const router = useRouter() return ( &lt;div&gt;&#123;router.query.name&#125;, 欢迎你！&lt;/div&gt; )&#125; 通过query的方式来传递 1234567891011121314151617181920212223// /pages/about.jsimport Link from &#x27;next/link&#x27;=export default function about() &#123; return ( &lt;div&gt; &lt;h2 className=&#x27;about-title&#x27;&gt;about&lt;/h2&gt; &lt;div&gt; &#123; [1, 2, 3, 4].map(id =&gt; &#123; return ( &lt;div key=&#123;id&#125;&gt; &lt;Link href=&#123;`/user?id=$&#123;id&#125;`&#125;&gt;&lt;a&gt;用户id:&#123;id&#125;&lt;/a&gt;&lt;/Link&gt; &lt;br /&gt; &lt;/div&gt; ) &#125;) &#125; &lt;/div&gt; &lt;/div&gt; )&#125; 接收传递过来的id 12345678910// /pages/user/index.jsimport &#123; useRouter &#125; from &#x27;next/router&#x27;export default function Index() &#123; const router = useRouter() return ( &lt;div&gt;用户ID: &#123;router.query.id&#125;&lt;/div&gt; )&#125; 通过函数调用的方式传参123456789101112131415161718// page/about.jsimport Router from &#x27;next/router&#x27;export default function about() &#123; const sendGuestId = (id) =&gt; &#123; Router.push(&#123; pathname: &#x27;/guest&#x27;, query: &#123; id &#125; &#125;) &#125; return ( &lt;div&gt; &lt;button onClick=&#123;()=&gt;sendGuestId(12)&#125;&gt;发送访客id&lt;/button&gt; &lt;/div&gt; )&#125; 1234567891011// /pages/guets.jsimport &#123; useRouter &#125; from &#x27;next/router&#x27;export default function Guest() &#123; const router = useRouter() console.log(router.query) return ( &lt;div&gt;访客ID: &#123;router.query.id&#125;&lt;/div&gt; )&#125; Next路由中的钩子事件路由钩子事件，也就是当路由发生变化时，可以监听到这些变化的事件，执行对应的函数。如：在routeChangeStart时执行加载动画，在routeChangeComplete时关闭加载动画。 1234567891011121314151617181920212223242526272829303132333435363738import Link from &#x27;next/link&#x27;import &#123; Router &#125; from &#x27;next/router&#x27;export default function Home() &#123; //路由发生变化时 Router.events.on(&#x27;routeChangeStart&#x27;, (...args) =&gt; &#123; console.log(&#x27;1. routeChangeComplete: 路由开始变化, 参数为: &#x27;,...args) &#125;) //路由结束变化时 Router.events.on(&#x27;routeChangeComplete&#x27;, (...args) =&gt; &#123; console.log(&#x27;2. routeChangeComplete: 路由结束变化, 参数为: &#x27;,...args) &#125;) //浏览器 history触发前 Router.events.on(&#x27;beforeHistoryChange&#x27;, (...args) =&gt; &#123; console.log(&#x27;3. beforeHistoryChange: 在改变浏览器history之前触发, 参数为: &#x27;,...args) &#125;) //路由跳转发生错误时 Router.events.on(&#x27;routeChangeError&#x27;,(...args)=&gt;&#123; console.log(&#x27;4. routeChangeError: 跳转发生错误, 参数为: &#x27;,...args) &#125;) // hash路由的开始变化 Router.events.on(&#x27;hashChangeStart&#x27;,(...args)=&gt;&#123; console.log(&#x27;5. hashChangeStart: hash跳转开始时执行, 参数为: &#x27;,...args) &#125;) // hash路由的结束变化 Router.events.on(&#x27;hashChangeComplete&#x27;,(...args)=&gt;&#123; console.log(&#x27;6. hashChangeComplete: hash跳转完成时, 参数为: &#x27;,...args) &#125;) return ( &lt;&gt; &lt;Link href=&#x27;/user/Jack&#x27;&gt;&lt;a&gt;history路由跳转&lt;/a&gt;&lt;/Link&gt; &lt;br /&gt; &lt;Link href=&#x27;#/abc&#x27;&gt;&lt;a&gt;hash路由跳转&lt;/a&gt;&lt;/Link&gt; &lt;/&gt; )&#125; Next页面嵌套head标签内容在页面上显示&lt;head&gt;&lt;/head&gt;标签中的内容。 1234567891011121314/page/index.jsimport Head from &#x27;next/head&#x27;export default function Home() &#123; const users = [&#x27;John&#x27;, &#x27;Jane&#x27;, &#x27;Bob&#x27;] return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;Hello Next&lt;/title&gt; &lt;/Head&gt; &lt;/&gt; )&#125; 公共内容提取公共部分嵌套在页面上，如，将header和footer提取出来。 第一种方式，同react中组件引用一样，在根目录下新建componets目录，创建对应的app.header.js和app.footer.js然后再在页面中引用。 第二种方式，在page中有一个_app.js的文件，在该文件上直接应用header和footer文件内容也可以，或者引用同一的组件。 1234567891011121314151617/pages/_app.jsimport &#x27;../styles/globals.css&#x27;function MyApp(&#123; Component, pageProps &#125;) &#123; return ( &lt;&gt; &lt;div&gt;Header Component&lt;/div&gt; &lt;hr /&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;hr /&gt; &lt;div&gt;Footer Component&lt;/div&gt; &lt;/&gt; )&#125;export default MyApp 自定义document 1234567891011121314151617181920212223242526import Document, &#123; Html, Head, Main, NextScript &#125; from &#x27;next/document&#x27;class MyDocument extends Document &#123; static async getInitialProps(ctx) &#123; const initialProps = await Document.getInitialProps(ctx) return &#123; ...initialProps &#125; &#125; render() &#123; return ( // 增加html的语言 &lt;Html lang=&#x27;zh&#x27;&gt; &lt;Head /&gt; &#123;/* 增加body样式 */&#125; &lt;body className=&#x27;body&#x27;&gt; &#123;/* 增加body标签中公共内容 */&#125; &lt;h2&gt;document新增内容&lt;/h2&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ) &#125;&#125;export default MyDocument 在page目录下新建_document.js文件，重新定义整个document，可以在html标签上或公共位置增加内容 12345678910111213141516171819202122232425262728/pages/_document.jsimport Document, &#123; Html, Head, Main, NextScript &#125; from &#x27;next/document&#x27;class MyDocument extends Document &#123; static async getInitialProps(ctx) &#123; const initialProps = await Document.getInitialProps(ctx) return &#123; ...initialProps &#125; &#125; render() &#123; return ( // 增加html的语言 &lt;Html lang=&#x27;zh&#x27;&gt; &lt;Head /&gt; &#123;/* 增加body样式 */&#125; &lt;body className=&#x27;body&#x27;&gt; &#123;/* 增加body标签中公共内容 */&#125; &lt;h2&gt;document新增内容&lt;/h2&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ) &#125;&#125;export default MyDocument 子页面布局嵌套多用于二级导航的嵌套，官方叫做Per-Page Layouts。 比如：company目录下有history.js和contact.js两个页面，使用company模块的二级导航。 1234567891011121314151617181920// /pages/company/compayn.layout.jsimport Link from &#x27;next/link&#x27;import React from &#x27;react&#x27;export default function CompanyLayou(props) &#123; return ( &lt;div&gt; &lt;div className=&#x27;page-title&#x27;&gt;Company&lt;/div&gt; &lt;div&gt; &lt;Link href=&#x27;/company/history&#x27;&gt;&lt;a&gt;公司历史&lt;/a&gt;&lt;/Link&gt; &lt;Link href=&#x27;/company/contact&#x27;&gt;&lt;a&gt;联系我们&lt;/a&gt;&lt;/Link&gt; &lt;/div&gt; &lt;div&gt; &#123;/* 相当于子路由内容占位 */&#125; &#123;props.children&#125; &lt;/div&gt; &lt;/div&gt; )&#125; 在子页面中引入layout页面，并用layout组件包裹。 123456789101112131415161718192021// /pages/company/history.jsimport React from &#x27;react&#x27;import CompanyLayou from &#x27;./company.layout&#x27;export default function History() &#123; return ( &lt;CompanyLayou&gt;History&lt;/CompanyLayou&gt; )&#125;// /pages/company/contact.jsimport React from &#x27;react&#x27;import CompanyLayou from &#x27;./company.layout&#x27;export default function Contact() &#123; return ( &lt;CompanyLayou&gt;Contact&lt;/CompanyLayou&gt; )&#125; Next样式的引用有四种方式： 直接引用，/styles/globals.css文件，在index.js中直接进行了引用。此样式一般为全局样式。 使用模块化引用。/styles/Home.module.css文件在index.js中也进行了模块化引用。 12345678910111213// /pages/index.jsimport styles from &#x27;../styles/Home.module.css&#x27;export default function Home() &#123; return ( &lt;&gt; &lt;main&gt; &#123;/* 使用模块化样式引用 */&#125; &lt;h2 className=&#123;styles.title&#125;&gt;Next首页&lt;/h2&gt; &lt;/&gt; )&#125; 使用css in js，next中默认自带了styled-jsx，由于是组件内样式，所以在其他组件使用时没有效果。 123456789101112131415// /pages/index.jsexport default function Home() &#123; return ( &lt;&gt; &lt;main&gt; &lt;h2 className=&#123;styles.title&#125;&gt;Next首页&lt;/h2&gt; &#123;/* 使用styled-jsx样式 */&#125; &lt;div className=&#x27;sub-title&#x27;&gt;这里是副标题&lt;/div&gt; &lt;style&gt;&#123;` .sub-title &#123; color:red; line-height:1.8; font-weight:800; text-align:center; &#125; `&#125;&lt;/style&gt; &lt;/&gt; )&#125; 还可以使用其他的css in js的技术，比如，styled-components，使用时需先进行安装，然后在next.config.js中进行配置。next新版本不需要在配置babel相关内容，简单很多 123456789// 安装yarn add styled-components// 然后在根目录下next.config.js配置这个插件const nextConfig = &#123; compiler: &#123; styledComponents: true, &#125;,&#125; Next中发起网络请求使用axios发起网络请求，官方从9.3以上版本建议使用getStaticProps通过context转发数据。以下版本则还可以使用getInitialProps通过props转发数据。两种在写法上有些不同。 123456789101112131415161718192021222324252627282930import React from &#x27;react&#x27;import axios from &#x27;axios&#x27;const News = (props) =&gt; &#123; const &#123; banners, recommendList &#125; = props return ( &lt;div&gt; &lt;h3&gt;News&lt;/h3&gt; &lt;ul&gt; &#123;banners.map(item =&gt; (&lt;li key=&#123;item.amc&#125;&gt;&#123;item.title&#125;&lt;/li&gt;))&#125; &lt;/ul&gt; &lt;hr /&gt; &lt;ul&gt; &#123;recommendList.map(item =&gt; (&lt;li key=&#123;item.amc&#125;&gt;&#123;item.title&#125;&lt;/li&gt;))&#125; &lt;/ul&gt; &lt;/div&gt; )&#125;// 此处需要将getStaticProps进行导出，否则报错，并且getStaticProps的形参须为context，return的结构为返回一个对象中的props对象export async function getStaticProps(context) &#123; const res = await axios.get(&#x27;http://123.207.32.32:8000/home/multidata&#x27;).then(res =&gt; res.data) return &#123; props: &#123; banners: res.data.banner.list, recommendList: res.data.recommend.list &#125; &#125;&#125;export default News Next模块和组件的懒加载异步加载第三方模块。 1234567891011121314151617import React, &#123; useState &#125; from &#x27;react&#x27;export default function Time() &#123; const [time, setTime] = useState(1655188576637) const changeTimeHandle = async () =&gt; &#123; const moment = await import(&#x27;moment&#x27;) setTime(moment.default(time).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) &#125; return ( &lt;div&gt; &lt;h2&gt;当前时间：&#123;time&#125;&lt;/h2&gt; &lt;div&gt; &lt;button onClick=&#123;changeTimeHandle&#125;&gt;格式化时间&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125; 懒加载组件，当页面加载时才加载该组件 123456789101112import dynamic from &#x27;next/dynamic&#x27;// 通过dynamic定义懒加载的组件const Loading = dynamic(() =&gt; import(&#x27;../components/Loading&#x27;), &#123; ssr: false &#125;)export default function Time() &#123; return ( &lt;div&gt; &lt;Loading /&gt; &lt;/div&gt; )&#125;","permalink":"http://example.com/2022/06/14/Next-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","photos":[]},{"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"ElementPlus","slug":"ElementPlus","permalink":"http://example.com/tags/ElementPlus/"},{"name":"避坑指南","slug":"避坑指南","permalink":"http://example.com/tags/%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"}],"title":"ElementPlus的坑","date":"2022/05/05","text":"记录一下在使用ElementPlus中的一些坑。 按需导入 坑： 之前没有这两个插件，不能自动导入，需要通过配安装babel，通过babel.config.js配置，组件需要统一全局手动注册一次，并且需要引入element-plus的基础样式。 按官方说明安装后，引入组件无效，卸载之前的element-plus和unplugin-vue-components、unplugin-auto-import。 重新进行安装，将配置放到webpack中。vue.config.ts中放入后会报错，不存在plugins的方法。 通过插件自动导入组件无需引入基础样式。 自动导入需要安装unplugin-vue-components 和 unplugin-auto-import这两款插件 1npm install -D unplugin-vue-components unplugin-auto-import 然后在vite或者webpack中进行配置。 Vite12345678910111213141516// vite.config.tsimport AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;export default &#123; plugins: [ // ... AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ],&#125; webpack12345678910111213141516// webpack.config.jsconst AutoImport = require(&#x27;unplugin-auto-import/webpack&#x27;)const Components = require(&#x27;unplugin-vue-components/webpack&#x27;)const &#123; ElementPlusResolver &#125; = require(&#x27;unplugin-vue-components/resolvers&#x27;)module.exports = &#123; // ... plugins: [ AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ],&#125; 全局引入的样式 坑： 全局引入样式，原来路径为import &#39;element-plus/lib/theme-chalk/index.css&#39; ，基础样式引入为import &#39;element-plus/lib/theme-chalk/base.css&#39; 2.0以后官方修改为 import &#39;element-plus/dist/index.css&#39; Loading组件 坑： loading组件在进行axios封装时使用，给所有axios封装的实例添加请求拦截器成功时，加载loading组件，在响应成功后关闭该组件。 在封装中需要配置 loading属性的类型，原来为 import &#123; ILoadingInstance &#125; from &#39;element-plus/lib/el-loading/src/loading.type&#39; 现在属性类型和位置为import &#123; LoadingInstance &#125; from &#39;element-plus/lib/components/loading/src/loading&#39;","permalink":"http://example.com/2022/05/05/ElementPlus%E7%9A%84%E5%9D%91/","photos":[]},{"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"pinia","slug":"pinia","permalink":"http://example.com/tags/pinia/"},{"name":"vuex","slug":"vuex","permalink":"http://example.com/tags/vuex/"}],"title":"Pinia使用小结","date":"2022/04/29","text":"大菠萝Pinia，号称vux5，全新的vue状态管理库。 个人感受，vuex4.x里面的概念太多了，本来vue就喜欢造概念，一堆一堆学都学不过来。vue4.x里更是繁琐的很，components要DIspatch给Actions，然后Actions要commit给Mutations，当然也可以从commponents给到Mutations，然后Mutaiions要Mutate给State。 但凡可以 get和set就别造新词了吧，真的记不住~ 搞得我看了好几遍，现在还是没啥概念。 Pinia就好很多 Actions既可以同步也可以异步，没分开。数据传递也很简单。看着教程就很容易的上手。 安装1npm i pinia -D 导入、实例化、挂载main.js 1234567891011import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;// 创建Pinia实例const pinia = createPinia()// 实例化 Vueconst app = createApp(App)// 挂载piniaapp.use(pinia)app.mount(&#x27;#app&#x27;) 创建storesrc&#x2F;store&#x2F;index.js 可以有多个容器，通过容器ID进行区分。 定义store有函数和对象两种写法。 12345678910111213141516171819202122232425262728293031323334import &#123; defineStore &#125; from &#x27;pinia&#x27;// 参数1：容器的ID，必须唯一 将来pinia会把所有的容易挂载到根容器// 参数2：选项对象// 返回值是一个函数 调用得到 对外部暴露一个 use 方法，该方法会导出我们定义的 stateexport const userMainStore = defineStore(&#x27;main&#x27;, &#123; // 类似于组件的data 用来存储全局状态 state: () =&gt; &#123; return &#123; counter: 100, msg: &#x27;Hello Pinia&#x27; &#125; &#125;, getters: &#123; // getters 相当于computed，对state中的数据进行加工 // 如果使用箭头函数会导致 this 指向有问题 // 可以在函数的第一个参数中拿到 state getCounter (state) &#123; return state.counter * 2 &#125; &#125;, actions: &#123; // actions 相当于methods用来修改 state add () &#123; this.counter++ &#125;, sub () &#123; this.counter-- &#125;, changeMsg () &#123; this.msg = &#x27;Hello Sim&#x27; &#125; &#125;&#125;) 使用storesrc&#x2F;App.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld /&gt; &lt;Home /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;import Home from &#x27;./components/Home.vue&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; HelloWorld, Home &#125;&#125;&lt;/script&gt;&lt;style&gt;.container &#123; margin: 40px auto; text-align:center;&#125;div,button &#123; margin-bottom: 20px;&#125;&lt;/style&gt; src&#x2F;components&#x2F;HelloWorld.vue 导入store中的userMainStore，可以在组件中调用，store中定义在Actions中的方法。使用公共方法对state中的数据做操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt;HelloWorld: &#123;&#123;store.counter&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;sub&quot;&gt;-1&lt;/button&gt; &lt;button @click=&quot;addTen&quot;&gt;+10&lt;/button&gt; &lt;br&gt; &lt;hr&gt; &lt;br&gt; &lt;div&gt;HelloWorld: &#123;&#123;store.msg&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;changeActionsMsg&quot;&gt;change Actions msg&lt;/button&gt; &lt;button @click=&quot;changeMsg&quot;&gt;change msg&lt;/button&gt; &lt;br&gt; &lt;hr&gt; &lt;div&gt;HelloWorld: &#123;&#123; store.getCounter&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; userMainStore &#125; from &#x27;../store/index&#x27;const store = userMainStore()const add = () =&gt; &#123; store.add()&#125;const sub = () =&gt; &#123; store.sub()&#125;const addTen = () =&gt; &#123; store.$patch(&#123; counter: store.counter + 10 &#125;)&#125;const changeActionsMsg = () =&gt; &#123; store.changeMsg()&#125;const changeMsg = () =&gt; &#123; store.$patch((state) =&gt; &#123; state.msg = &#x27;Hello Simz&#x27; &#125;)&#125;&lt;/script&gt; src&#x2F;components&#x2F;Home.vue 1.直接从 store中解构的对象，不具备响应式，使用storeToRefs解构后的具有响应式 12345678910111213141516171819&lt;template&gt; &lt;div&gt;Home:&#123;&#123;store.counter&#125;&#125;&lt;/div&gt; &lt;div&gt;Home:&#123;&#123;store.msg&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;hr&gt; &lt;br&gt; &lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; userMainStore &#125; from &#x27;../store/index&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;// 使用storeToRefs解构后具有响应式const store = userMainStore()const &#123; counter, msg &#125; = storeToRefs(store)&lt;/script&gt; 总结：以上仅未pinia的简单使用。 调用state中的数据 调用actions的方法 使用getters中的计算方法，并在组件调用 在setup中使用pinia","permalink":"http://example.com/2022/04/29/Pinia%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/","photos":[]},{"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}],"title":"JavaScript字符串操作整理","date":"2022/04/29","text":"基础差就只能慢慢补，这两天把字符串操作的方法整理了下，平常用的也就只有几个，但是一整理就发现有一大堆。 常用indexOf()、split()、slice()、toLowerCase()、toUpperCase()、replace()、trim()、padStart()、parseInt() 获取字符串长度获取字符串长度 length12const str = &#x27;Hello World&#x27;str.length // 11 获取字符串指定位置的值获取指定位置的字符 charAt()12const str = &#x27;Hello World&#x27;str.charAt(1) // e 获取指定位置的Uniconde值 charCodeAt()12const str = &#x27;Hello World&#x27;str.charCodeAt(1) // 117 检索字符串是否包含特定序列查找某个字符 IndexOf()有则返回第一次匹配到的索引位置index，否则返回-1 123const str = &#x27;Hello World&#x27;str.indexOf(&#x27;l&#x27;) // 2str.indexOf(&#x27;x&#x27;) // -1 查找某个字符 lastIndexOf()有则返回最后匹配到的索引位置index ，否则返回-1 。只是查找的顺序不一样，indexOf()是正序查找，lastIndexOf()是逆序查找。 123const str = &#x27;Hello World&#x27;str.lastIndexOf(&#x27;l&#x27;) // 8str.lastIndexOf(&#x27;y&#x27;) // -1 判断字符串是否包含指定子字符串 includes()如找到匹配字符串返回true否则返回false 。 参数： searchvalue，必须，要查找的字符串。 start，开始查找位置，默认为0。 1234const str = &#x27;Hello World&#x27;str.includes(&#x27;o&#x27;) // truestr.includes(&#x27;x&#x27;) // falsestr.includes(&#x27;e&#x27;, 2) // false 检测字符串是否以指定的子字符串开始 startsWith()如以指定子字符串开始返回true，否则返回false 。 1234const str = &#x27;Hello World&#x27;str.startsWith(&#x27;He&#x27;) // truestr.startsWith(&#x27;he&#x27;) // falsestr.startsWith(&#x27;Wo&#x27;, 6) // true 检测字符串是否以指定的字符串结尾 endsWith()如以指定字符串结尾返回true，否则返回false。 参数： searchvalue，必须，要查询的字符串。 length，查询字符串的长度范围，默认为整个字符串长度范围内。 1234const str = &#x27;Hello World&#x27;str.endsWith(&#x27;ld&#x27;) // truestr.endsWith(&#x27;ed&#x27;) // falsestr.endsWith(&#x27;llo&#x27;, 5) // true 连接多个字符串连接两个或多个字符串 concat()不会改变原有字符串，会返回连接后的新的字串 123const str = &#x27;Hello World&#x27;str.concat(&#x27; Javascript&#x27;) // Hello World Javascriptstr.concat(&#x27; Vue&#x27;, &#x27; React&#x27;) // Hello World Vue React 字符串分割成数组字符串分割成字符串数组 split()不会改变原始字符串。 参数： separator，必须，字符串或正则表达式，从该参数指定的地方分割字符串。 limit，可选，指定返回数组中字符串长度。未设置该参数则整个字符串都会被分割。 1234const str = &#x27;Hello World&#x27;str.split(&#x27;&#x27;) // //[ &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27; ]str.split(&#x27;&#x27;, 5) // [ &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27; ]str.split(&#x27; &#x27;) // [&#x27;Hello&#x27;, &#x27;World&#x27;] 截取字符串提取字符串某个部分 slice(）以新的字符串返回被提取的部分。该方法返回的字符串：包括开始处的字符，不包括结束处的字符 。 参数： start，必须，要截取片段开始下标，第一个字符位置为0，如为负数，则从未必开始截取。 end，可选，要截取片段结尾下标。若未指定该参数，则从start到原始字符串结尾的字符串。若参数为负数，则从字符串尾部开始算起。 123456const str = &#x27;Hello World&#x27;str.slice(1, 4) // ellostr.slice(6) // Worldstr.slice() // Hello Worldstr.slice(-2) // ldstr.slice(6, 1) // 提取两个指定下标之间的的字符 substring()MDN建议使用substring()替代substr()。 返回一个新的字符串。 参数： from，必须，非负整数，规定要提取子字符串的起始位置。 to，可选，非负整数，规定要提取子字符串的结束位置。如省略，则返回的字符串一直到字符串的结尾。 注意： 如from和to相等，那么返回一个空串。 如from比to大，则会交换这两个参数，该方法不接受负数作为参数。 该方法返回的字符串：包括开始处的字符，不包括结束处的字符 。 123456const str = &#x27;Hello World&#x27;str.substring(0, 5) // Hellostr.substring(6) // Worldstr.substring() // Hello Worldstr.substring(6, 0) // Hellostr.substring(-1) // Hello World 字符串大小写转换把字符串转换为小写 toLowerCase()1234const str = &#x27;Hello World&#x27;str.toLowerCase() // hello world// 首字母变成小写console.log(str[0].toLowerCase() + str.substring(1)) // hello World 把字符串转换为大写 toUpperCase()12const str = &#x27;Hello World&#x27;str.toUpperCase() // HELLO WORLD 字符串匹配模式替换字符 replace()参数： searchvalue，必须，规定子字符串或要替换的模式的RegExp对象。 newvalue，必须，字符串，规定了替换文本或生成文本的函数。 123const str = &#x27;Hello World&#x27;str.replace(&#x27;World&#x27;, &#x27;Javascript&#x27;) // Hello Javascriptstr.replace(/world/gi, &#x27;Vue&#x27;) // Hello Vue 匹配字符串 match()匹配字符串，查找到返回一个数组对象，数组对象里有 匹配的值 查找字符串的下标 和 原字符串内容，找不到返回null。 该方法参数regexp是必须的，规定要匹配的模式的RegExp对象，如果不是RegExp对象，则需要先传递给RegExp构造函数，将其转换为RegExp对象。 该方法返回存放匹配结果的数组。 123const str = &#x27;Hello World&#x27;str.match(&#x27;o&#x27;) // [ &#x27;o&#x27;, index: 4, input: &#x27;Hello World&#x27;, groups: undefined ]str.match(&#x27;f&#x27;) // null 检索字符串 search()跟indexOf一样，查找字符串首次出现的位置，如果找到返回该字符串下标，下标从0开始，未找到返回-1 123const str = &#x27;Hello World&#x27;str.search(&#x27;o&#x27;) // 4str.search(&#x27;f&#x27;) // -1 移除字符串中的空白字符移除首尾空白字符 trim()不改变原字符串，返回一个新字符串。不适用于null、nudefined、Number类型。 12const str = &#x27; Hello World &#x27;str.trim() // Hello World 移除开头的空白字符 trimStart()12const str = &#x27; Hello World &#x27;str.trimStart() // Hello World 移除结尾的空白字符 trimEnd()12const str = &#x27; Hello World &#x27;str.trimEnd() // Hello World 获取字符串本身返回字符串的原始值 valueOf()12const str = &#x27;Hello World&#x27;str.valueOf() // Hello World 转换成字符串类型 tostring()一般用于将数值、布尔值类型转换成字符串类型。 12const str = 123str.toString() // &quot;123&quot; 重复字符串重复字符串 repeat()返回一个新字符串，重复n次。 如参数为0、负小数、NaN、字符串，输出为空 如为负数、infinity 会报错 如为小数，会向下取整 如果字符串会先转为数字 12345const str = &#x27;Hello World&#x27;str.repeat(2) // Hello WorldHello Worldstr.repeat(0) //str.repeat(2.8) // Hello WorldHello Worldstr.repeat(-1) // Error 补齐字符串长度补齐头部字符串 padStart()参数： 参数1，必须，数字，字符串补齐后的长度。如原字符串长度等于或大于指定长度，则返回原字符串 参数2，可选，字符，用来补全的字符串。如为空则用空格补全长度 1234const str = &#x27;Hello World&#x27;str.padStart(15, &#x27;a&#x27;) // aaaaHello Worldstr.padStart(8, &#x27;a&#x27;) // Hello Worldstr.padStart(15) // Hello World 补齐尾部字符串 padEnd()参数同padStart。 1234const str = &#x27;Hello World&#x27;str.padEnd(15, &#x27;a&#x27;) // Hello Worldaaaastr.padEnd(3, &#x27;a&#x27;)str.padEnd(15) 字符串转为数字字符串转为整数 parseInt()参数： string，必须，要被转换的字符串。 radix，可选，要解析的数字技术，介于2 ~ 36之间。 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。 当参数 radix 的值以 “0x” 或 “0X” 开头，将以 16 为基数 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN 只有字符串中的第一个数字会被返回，当遇到第一个不是数字的字符为止 如果字符串的第一个字符不能被转换为数字，就会返回 NaN 字符串开头和结尾的空格是允许的 12const numStr = &quot;123&quot;parseInt(numStr) // 123 字符串转为浮点数 parseFloat()该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 12const numStr = &quot;123&quot;parseFloat(numStr) 快速概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const str = &#x27;Hello World&#x27;const str2 = &#x27; Hello World &#x27;const num = 123const numStr = &#x27;123.00&#x27;// 获取字符串长度 lengthconsole.log(str.length) // 11// 获取字符串指定位置值 charAt()console.log(str.charAt(1)) // econsole.log(str.charCodeAt(1)) // 101// 获取字符位置索引 indexOfconsole.log(str.indexOf(&#x27;l&#x27;)) // 2console.log(str.indexOf(&#x27;x&#x27;)) // -1console.log(str.lastIndexOf(&#x27;l&#x27;)) // 8console.log(str.lastIndexOf(&#x27;y&#x27;)) // -1// 获取字符串是否包含子字符串 includes()console.log(str.includes(&#x27;o&#x27;)) // trueconsole.log(str.includes(&#x27;x&#x27;)) // falseconsole.log(str.includes(&#x27;e&#x27;, 2)) // false// 检测字符串是否以指定子字符串开始 startsWith()console.log(str.startsWith(&#x27;He&#x27;)) // trueconsole.log(str.startsWith(&#x27;he&#x27;)) // falseconsole.log(str.startsWith(&#x27;Wo&#x27;, 6)) // true// 检测字符串是否以指定子字符串结尾 endsWith()console.log(str.endsWith(&#x27;ld&#x27;)) // trueconsole.log(str.endsWith(&#x27;ed&#x27;)) // falseconsole.log(str.endsWith(&#x27;llo&#x27;, 5)) // true// 连接两个或多个字符串 cancat()console.log(str.concat(&#x27; Javascript&#x27;)) // Hello World Javascriptconsole.log(str.concat(&#x27; Vue&#x27;, &#x27; React&#x27;)) // Hello World React// 字符串分割成数组 split()console.log(str.split(&#x27;&#x27;)) //[ &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27; ]console.log(str.split(&#x27;&#x27;, 5)) // [ &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27; ]console.log(str.split(&#x27; &#x27;)) // [ &#x27;Hello&#x27;, &#x27;World&#x27; ]// 截取字符串 slice()console.log(str.slice(1, 6)) // elloconsole.log(str.slice(6)) // Worldconsole.log(str.slice()) // Hello Worldconsole.log(str.slice(-2)) // ldconsole.log(str.slice(6, 1)) // // 截取字符串 substringconsole.log(str.substring(0, 5)) // Helloconsole.log(str.substring(6)) // Worldconsole.log(str.substring()) // Hello Worldconsole.log(str.substring(6, 0)) // Helloconsole.log(str.substring(-1)) // Hello World// 字符串转换成小写 toLowerCase()console.log(str.toLowerCase()) // hello world// 字符串转换成大写 toUpperCase()console.log(str.toUpperCase()) // HELLO WORLD// 首字母变成小写console.log(str[0].toLowerCase() + str.substring(1)) // hello World// 替换字符串 replace()console.log(str.replace(&#x27;World&#x27;, &#x27;Javascript&#x27;)) // Hello Javascriptconsole.log(str.replace(/world/gi, &#x27;Vue&#x27;)) // Hello Vue// 匹配字符串 match()console.log(str.match(&#x27;o&#x27;)) // [ &#x27;o&#x27;, index: 4, input: &#x27;Hello World&#x27;, groups: undefined ]console.log(str.match(&#x27;f&#x27;)) // null// 检索字符串 search()console.log(str.search(&#x27;o&#x27;)) // 4console.log(str.search(&#x27;f&#x27;)) // -1// 移除字符串首尾空白字符 trim()console.log(str2.trim()) // Hello World// 移除开头的空白字符 trimStart()console.log(str2.trimStart()) // Hello World // 移除结尾的空白字符 trimEnd()console.log(str2.trimEnd()) // Hello World// 返回字符串本身 valueOf()console.log(str.valueOf()) // Hello World// 返回一个字符串对象 toString()const result = num.toString()console.log(typeof result, result) // string 123// 重复字符串 repeat()console.log(str.repeat(2)) // Hello WorldHello Worldconsole.log(str.repeat(0)) // console.log(str.repeat(2.8)) // Hello WorldHello World// console.log(str.repeat(-1)) // Error// 补齐头部字符串 padStart()console.log(str.padStart(15, &#x27;a&#x27;)) // aaaaHello Worldconsole.log(str.padStart(8, &#x27;a&#x27;)) // Hello Worldconsole.log(str.padStart(15)) // Hello World// 补齐尾部字符串 padEnd()console.log(str.padEnd(15, &#x27;a&#x27;)) // Hello Worldaaaaconsole.log(str.padEnd(8, &#x27;a&#x27;)) // Hello Worldconsole.log(str.padEnd(15)) // Hello World // 字符串转为整数 parseInt()const result2 = parseInt(numStr)console.log(typeof result2, result2) // number 123const result3 = parseFloat(numStr)console.log(typeof result3, result3) // number 123","permalink":"http://example.com/2022/04/29/JavaScript%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/","photos":[]},{"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}],"title":"CSS垂直居中的完全体","date":"2022/04/18","text":"很久没见到这么干的文章，拉屎的时候刷到让我便意似乎没了。赶紧拜读了一遍，默默关注了大神。 原来面试的时候经常会问这个问题，大多数能讲出三四个我已经觉得很了不起了。我自己也大概只知道五六种，感觉前端的发展太快很多东西学不动只能让自己不断落后。所以该记录的记录下来，该改进的改进改进，逆水行舟冷暖自知。 水平居中比较简单，垂直居中由于浏览器的原因会有很多差异，如果用上flex幸福感会提升很多，考虑到兼容性，似乎就没那么多幸福了… 垂直居中分为两种类型：元素已知宽高 和 元素未知宽高。 html公共结构： 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;居中内容&lt;/div&gt;&lt;/div&gt; 元素已知宽高absolute + margin12345678910111213141516171819.father &#123; width: 80vw; height: 80vh; background-color: #f7f7f7; position: relative;&#125;.son &#123; width: 200px; height: 200px; background-color: #9e9e9e; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; absolute + 负margin已知宽高时，此方法用的最多，主要比较容易理解 123456789101112131415161718.father &#123; width: 80vw; height: 80vh; background-color: #f7f7f7; position: relative;&#125;.son &#123; width: 200px; height: 200px; background-color: #9e9e9e; position: absolute; top:50%; left:50%; margin-top: -100px; margin-left: -100px;&#125; absoulute + calc利用了css3中的计算函数calc，原理上同上面的absolute+负margin类似。 12345678910111213141516.father &#123; width: 80vw; height: 80vh; background-color: #f7f7f7; position: relative;&#125;.son &#123; width: 200px; height: 200px; background-color: #9e9e9e; position: absolute; top:calc(50% - 100px); left:calc(50% - 100px);&#125; 元素未知宽高absoulte + transformTransform属性应用于元素的2D或3D转换。这里用到了transform属性中的translate。 此方法和absoulte + 负margin的方法类似，但可以用于未知宽高的元素上，所以适用面更广，也是使用的比较多的方法。 12345678910111213141516.father &#123; width: 80vw; height: 80vh; background-color: #f7f7f7; position: relative;&#125;.son &#123; padding:10px; background-color: #9e9e9e; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; line-height + vertical-align这个方法我也是第一次看到，因为vertical-align属性在css里基本是个废品。原来是没用到正确的使用方法。 通过继承父级的line-height，vertical-align就可以得到正确的使用方法。 123456789101112131415.father &#123; width:100vw; background-color: #f7f7f7; line-height: 480px; text-align: center;&#125;.son &#123; padding: 10px; background-color: #9e9e9e; display: inline-block; line-height: initial; vertical-align :middle;&#125; table表格这是最原始的方法了，通过table的单元格td来让td内的元素水平垂直居中。代码过于冗余，现在应该没有人会去使用了吧。 1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;居中内容&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;style&gt; .father &#123; width: 100vw; height: 100vh; background-color: #f7f7f7; text-align:center; &#125; .son &#123; padding:10px; background-color: #9e9e9e; display:inline-block; &#125;&lt;/style&gt; display:table-cell这个方法应该是早期比较流行的方法了，设置为table-cell。 123456789101112131415.father &#123; width: 100vw; height: 100vh; background-color: #f7f7f7; display: table-cell; text-align: center; vertical-align: middle;&#125;.son &#123; padding: 10px; background-color: #9e9e9e; display:inline-block;&#125; flex align-items:centerflex有两个专门的属性来设置水平和垂直居中，而且是通过父级来实现非常优雅。bootstrap有一堆工具样式来实现这些，后面有时间再来记录下。 12345678910111213.father &#123; width: 100vw; height: 100vh; background-color: #f7f7f7; display: flex; justify-content: center; align-items: center;&#125;.son &#123; padding: 10px; background-color: #9e9e9e;&#125; flex + margin:auto应该是只用到两句代码来做到的，在子元素上写margin:auto的做法这样限制也会略多。 12345678910111213.father &#123; width: 100vw; height: 100vh; background-color: #f7f7f7; display: flex;&#125;.son &#123; padding: 10px; background-color: #9e9e9e; margin:auto;&#125; gridgrid出来的比flex更晚，用的会相对更少些。 12345678910111213.father &#123; width: 100vw; height: 100vh; background-color: #f7f7f7; display: grid; justify-content: center; align-items: center;&#125;.son &#123; padding: 10px; background-color: #9e9e9e;&#125; grid-item通过子元素设置居中。 1234567891011121314.father &#123; width: 100vw; height: 100vh; background-color: #f7f7f7; display: grid;&#125;.son &#123; padding: 10px; background-color: #9e9e9e; align-self: center; justify-self: center;&#125; 好了，以上就是大佬总结的11种垂直居中方式，全部在codepen中测试通过。使用时，注意兼容性。","permalink":"http://example.com/2022/04/18/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BD%93/","photos":[]},{"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"prettier","slug":"prettier","permalink":"http://example.com/tags/prettier/"},{"name":"eslint","slug":"eslint","permalink":"http://example.com/tags/eslint/"}],"title":"VSCode使用Prettier按ESLint格式化代码","date":"2022/04/15","text":"被ESLint折腾了好几天，VSCode的配置也配了好多次，这次应该是解决了。主要目的，通过Perttier按照ESLint的标准来格式化。不用我们在手动格式化了。ESLint真是一个BT的格式化标准。 安装插件 ESLint：用来识别并检查ECMAScript&#x2F;JavaScript 代码的工具 Prettier：用来格式化代码，如.js、.vue、css等都可以进行格式化 Vetur：用来识别并高亮vue语法 EditorConfig：用来设置vscode的编程行为 安装依赖 安装 ESlint 的依赖 1npm i -D eslint babel-eslint eslint-plugin-vue @vue/cli-plugin-eslint eslint ：ESlint 的核心代码 babel-eslint：eslint和babel的整合包 eslint-plugin-vue @vue&#x2F;cli-plugin-eslint：eslint和vue的整合包 安装 Prettier 依赖 ​ 适应vue3以下： 1npm i -D prettier eslint-plugin-prettier eslint-config-prettier prettier-eslint-cli prettier：Prettier的核心代码 eslint-plugin-prettier：将prettier作为ESLint规范来使用 eslint-config-prettier：解决 ESLint 中的样式规范和 prettier 中样式规范的冲突，以 prett ier 的样式规范为准，使 ESLint 中的样式规范自动失效 prettier-eslint-cli：prettier-eslint-cli 允许你对多个文件用 prettier-eslint 进行格式化 适用vue3： 1npm i -D prettier eslint-plugin-prettier @vue/eslint-config-prettier 配置 配置ESlint：在项目的根目录下，新建.eslintrc.js 文件。 1234567891011121314module.exports = &#123; root: true, env: &#123; node: true, &#125;, extends: [&quot;plugin:vue/vue3-essential&quot;, &quot;eslint:recommended&quot;, &quot;@vue/prettier&quot;], parserOptions: &#123; parser: &quot;babel-eslint&quot;, &#125;, rules: &#123; &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot; &#125;&#125;; 配置Prettier（局部的只对本项目有效）：在项目的根目录下创建.prettierrc.js 文件。 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; // 最大长度80个字符 printWidth: 80, // 行末分号 semi: false, // 单引号 singleQuote: true, // JSX双引号 jsxSingleQuote: false, // 尽可能使用尾随逗号（包括函数参数） trailingComma: &#x27;none&#x27;, // 在对象文字中打印括号之间的空格。 bracketSpacing: true, // &gt; 标签放在最后一行的末尾，而不是单独放在下一行 jsxBracketSameLine: false, // 箭头圆括号 arrowParens: &#x27;avoid&#x27;, // 在文件顶部插入一个特殊的 @format 标记，指定文件格式需要被格式化。 insertPragma: false, // 缩进 tabWidth: 2, // 使用tab还是空格 useTabs: false, // 行尾换行格式 endOfLine: &#x27;auto&#x27;, HTMLWhitespaceSensitivity: &#x27;ignore&#x27;, extends: [ //继承 vue 的标准特性 &#x27;plugin:vue/essential&#x27;, &#x27;eslint:recommended&#x27;, //避免与 prettier 冲突 &#x27;plugin:prettier/recommended&#x27; ]&#125; Settings.json配置补充内容。主要针对各种文件设置执行&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;这个配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;files.autoSave&quot;: &quot;onWindowChange&quot;, // 切换窗口文件自动保存 &quot;editor.formatOnSave&quot;: true, // 保存时格式化 &quot;editor.formatOnPaste&quot;: true, // 粘贴文件时格式化 &quot;editor.suggestSelection&quot;: &quot;first&quot;, &quot;editor.tabSize&quot;: 2, // tab空格 &quot;editor.fontSize&quot;: 18, // 编辑器字体大小 &quot;editor.fontFamily&quot;: &quot;Monaco, Source Code Pro, Cascadia Code&quot;, // 字体 &quot;editor.codeLens&quot;: true, &quot;explorer.compactFolders&quot;: false, // 资源管理器文件夹以紧凑的形式呈现 &quot;editor.matchBrackets&quot;: &quot;never&quot;, // 突出显示匹配的括号 &quot;emmet.triggerExpansionOnTab&quot;: true, // 启用tab展开emmet语法 &quot;editor.renderIndentGuides&quot;: true, // 缩进渲染 &quot;html.format.endWithNewline&quot;: true, // 格式化时文件末尾保留一行空行 &quot;workbench.colorTheme&quot;: &quot;Default Dark+&quot;, // 默认配色: Default Dark+ | Visual Studio Dark | Noctis Minimus | Atom One Dark &quot;editor.scrollBeyondLastLine&quot;: false, // 是否允许滚动到最后一行 &quot;editor.rulers&quot;: [120], // 最大列宽 &quot;editor.wordWrap&quot;: &quot;on&quot;, // 自动换行 &quot;editor.wordWrapColumn&quot;: 120, // 列数120自动换行 // 本次配置补充内容 &quot;editor.formatOnType&quot;: true, &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.eslint&quot;: true &#125;, &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettier&quot;, &quot;[css]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[scss]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[jsonc]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[javascript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[vue]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;&#125; 配置编辑器：在项目的根目录下创建.editorconfig 文件。 123456789101112root = true [*]charset = utf-8end_of_line = lfindent_style = spaceindent_size = 2trim_trailing_whitespace = trueinsert_final_newline = true [*.md]trim_trailing_whitespace = false 配置完基本就可以格式css、scss、json、javascript、vue、html的格式了。 以下补充ESLint配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221module.exports = &#123; env: &#123; node: true, browser: true, commonjs: true, es6: true, jquery: true &#125;, parser: &#x27;babel-eslint&#x27;, extends: &#x27;eslint:recommended&#x27;, parserOptions: &#123; ecmaFeatures: &#123; experimentalObjectRestSpread: true, jsx: true &#125;, sourceType: &#x27;module&#x27; &#125;, plugins: [&#x27;html&#x27;], // 列举不需要检查的全局对象 globals: &#123; vue: true, requirejs: true, define: true, _: true, PPDWebUI: true, ppdeal: true, swal: true, toastr: true, cmp: true, template: true, controller: true, Switchery: true, common: true, maltose: true &#125;, rules: &#123; /* &quot;off&quot;或者0 //关闭规则关闭 &quot;warn&quot;或者1 //在打开的规则作为警告（不影响退出代码） &quot;error&quot;或者2 //把规则作为一个错误（退出代码触发时为1） */ &#x27;no-alert&#x27;: 0, //允许使用alert confirm prompt &#x27;no-array-constructor&#x27;: 2, //禁止使用数组构造器 &#x27;no-bitwise&#x27;: 0, //允许使用按位运算符 &#x27;no-caller&#x27;: 1, //谨慎使用arguments.caller或arguments.callee &#x27;no-catch-shadow&#x27;: 2, //禁止catch子句参数与外部作用域变量同名 &#x27;no-class-assign&#x27;: 2, //禁止给类赋值 &#x27;no-cond-assign&#x27;: 0, //允许在条件表达式中使用赋值语句 &#x27;no-console&#x27;: 0, //允许使用console &#x27;no-const-assign&#x27;: 2, //禁止修改const声明的变量 &#x27;no-constant-condition&#x27;: 1, //谨慎在条件中使用常量表达式 if(true) if(1) &#x27;no-continue&#x27;: 0, //允许使用continue &#x27;no-control-regex&#x27;: 0, //允许在正则表达式中使用控制字符 &#x27;no-debugger&#x27;: 2, //禁止使用debugger &#x27;no-delete-var&#x27;: 2, //不能对var声明的变量使用delete操作符 &#x27;no-div-regex&#x27;: 0, //谨慎使用看起来像除法的正则表达式/=foo/ &#x27;no-dupe-keys&#x27;: 2, //在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; &#x27;no-dupe-args&#x27;: 2, //函数参数不能重复 &#x27;no-duplicate-case&#x27;: 2, //switch中的case标签不能重复 &#x27;no-else-return&#x27;: 0, //如果if语句里面有return,后面不能跟else语句 &#x27;no-empty&#x27;: 0, //块语句中的内容可以为空 &#x27;no-empty-character-class&#x27;: 0, //正则表达式中的[]内容可以为空 &#x27;no-empty-label&#x27;: 0, //允许使用空label &#x27;no-eq-null&#x27;: 0, //允许对null使用==或!=运算符 &#x27;no-eval&#x27;: 0, //允许使用eval &#x27;no-ex-assign&#x27;: 2, //禁止给catch语句中的异常参数赋值 &#x27;no-extend-native&#x27;: 0, //允许扩展native对象 &#x27;no-extra-bind&#x27;: 0, //禁止不必要的函数绑定 .bind(this) &#x27;no-extra-boolean-cast&#x27;: 2, //禁止不必要的bool转换 &#x27;no-extra-parens&#x27;: 0, //禁止非必要的括号 &#x27;no-extra-semi&#x27;: 2, //禁止多余的冒号 &#x27;no-fallthrough&#x27;: 0, //禁止switch穿透 &#x27;no-floating-decimal&#x27;: 2, //禁止省略浮点数中的0 .5 3. &#x27;no-func-assign&#x27;: 2, //禁止重复的函数声明 &#x27;no-implicit-coercion&#x27;: 0, //允许隐式转换 &#x27;no-implied-eval&#x27;: 2, //禁止使用隐式eval &#x27;no-inline-comments&#x27;: 0, //允许行内备注 &#x27;no-inner-declarations&#x27;: [2, &#x27;functions&#x27;], //禁止在块语句中使用声明（变量或函数） &#x27;no-invalid-regexp&#x27;: 2, //禁止无效的正则表达式 &#x27;no-invalid-this&#x27;: 0, //禁止无效的this，只能用在构造器，类，对象字面量 &#x27;no-irregular-whitespace&#x27;: 2, //不能有不规则的空格 &#x27;no-iterator&#x27;: 2, //禁止使用__iterator__ 属性 &#x27;no-label-var&#x27;: 2, //label名不能与var声明的变量名相同 &#x27;no-labels&#x27;: 2, //禁止标签声明 &#x27;no-lone-blocks&#x27;: 2, //禁止不必要的嵌套块 &#x27;no-lonely-if&#x27;: 0, //谨慎在else语句内只有if语句 &#x27;no-loop-func&#x27;: 1, //谨慎在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &#x27;no-mixed-requires&#x27;: [0, false], //允许声明时混用声明类型 &#x27;no-mixed-spaces-and-tabs&#x27;: [1, false], //禁止混用tab和空格 &#x27;linebreak-style&#x27;: [0, &#x27;windows&#x27;], //换行风格 &#x27;no-multi-spaces&#x27;: 1, //禁止用多余的空格 &#x27;no-multi-str&#x27;: 1, //字符串不能用\\换行 &#x27;no-multiple-empty-lines&#x27;: [1, &#123; max: 2 &#125;], //空行最多不能超过2行 &#x27;no-native-reassign&#x27;: 1, //不能重写native对象 &#x27;no-negated-in-lhs&#x27;: 1, //in 操作符的左边不能有! &#x27;no-nested-ternary&#x27;: 0, //允许使用嵌套的三目运算 &#x27;no-new&#x27;: 0, //禁止在使用new构造一个实例后不赋值 &#x27;no-new-func&#x27;: 1, //允许使用new Function &#x27;no-new-object&#x27;: 1, //禁止使用new Object() &#x27;no-new-require&#x27;: 1, //禁止使用new require &#x27;no-new-wrappers&#x27;: 1, //禁止使用new创建包装实例，new String new Boolean new Number &#x27;no-obj-calls&#x27;: 0, //不能调用内置的全局对象，比如Math() JSON() &#x27;no-octal&#x27;: 0, //禁止使用八进制数字 &#x27;no-octal-escape&#x27;: 0, //禁止使用八进制转义序列 &#x27;no-param-reassign&#x27;: 0, //禁止给参数重新赋值 &#x27;no-path-concat&#x27;: 0, //node中不能使用__dirname或__filename做路径拼接 &#x27;no-plusplus&#x27;: 0, //禁止使用++，-- &#x27;no-process-env&#x27;: 0, //禁止使用process.env &#x27;no-process-exit&#x27;: 0, //禁止使用process.exit() &#x27;no-proto&#x27;: 0, //禁止使用__proto__属性 &#x27;no-redeclare&#x27;: 2, //禁止重复声明变量 &#x27;no-regex-spaces&#x27;: 1, //禁止在正则表达式字面量中使用多个空格 /foo bar/ &#x27;no-restricted-modules&#x27;: 0, //如果禁用了指定模块，使用就会报错 &#x27;no-return-assign&#x27;: 0, //return 语句中不能有赋值表达式 &#x27;no-script-url&#x27;: 0, //禁止使用javascript:void(0) &#x27;no-self-compare&#x27;: 1, //不能比较自身 &#x27;no-sequences&#x27;: 0, //禁止使用逗号运算符 &#x27;no-shadow&#x27;: 2, //外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &#x27;no-shadow-restricted-names&#x27;: 2, //严格模式中规定的限制标识符不能作为声明时的变量名使用 &#x27;no-spaced-func&#x27;: 2, //函数调用时 函数名与()之间不能有空格 &#x27;no-sparse-arrays&#x27;: 2, //禁止稀疏数组， [1,,2] &#x27;no-sync&#x27;: 0, //nodejs 禁止同步方法 &#x27;no-ternary&#x27;: 0, //禁止使用三目运算符 &#x27;no-trailing-spaces&#x27;: 1, //一行结束后面不要有空格 &#x27;no-this-before-super&#x27;: 0, //在调用super()之前不能使用this或super &#x27;no-throw-literal&#x27;: 1, //禁止抛出字面量错误 throw &quot;error&quot;; &#x27;no-undef&#x27;: 1, //不能有未定义的变量 &#x27;no-undef-init&#x27;: 1, //变量初始化时不能直接给它赋值为undefined &#x27;no-undefined&#x27;: 0, //不能使用undefined &#x27;no-unexpected-multiline&#x27;: 1, //避免多行表达式 &#x27;no-underscore-dangle&#x27;: 0, //标识符不能以_开头或结尾 &#x27;no-unneeded-ternary&#x27;: 0, //禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &#x27;no-unreachable&#x27;: 2, //不能有无法执行的代码 &#x27;no-unused-expressions&#x27;: 0, //禁止无用的表达式 a &amp;&amp; a.b &#x27;no-unused-vars&#x27;: [1, &#123; vars: &#x27;all&#x27;, args: &#x27;after-used&#x27; &#125;], //不能有声明后未被使用的变量或参数 &#x27;no-use-before-define&#x27;: 2, //未定义前不能使用 &#x27;no-useless-call&#x27;: 2, //禁止不必要的call和apply &#x27;no-useless-escape&#x27;: 0, //不允许在字符串和正则表达式中使用无意义的换行符 &#x27;no-void&#x27;: 0, //禁用void操作符 &#x27;no-var&#x27;: 0, //禁用var，用let和const代替 &#x27;no-warning-comments&#x27;: [ 1, &#123; terms: [&#x27;todo&#x27;, &#x27;fixme&#x27;, &#x27;xxx&#x27;], location: &#x27;start&#x27; &#125; ], //不能有警告备注 &#x27;no-with&#x27;: 1, //禁用with &#x27;array-bracket-spacing&#x27;: [1, &#x27;never&#x27;], //是否允许非空数组里面有多余的空格 &#x27;arrow-parens&#x27;: 0, //箭头函数用小括号括起来 &#x27;arrow-spacing&#x27;: 0, //=&gt;的前/后括号 &#x27;accessor-pairs&#x27;: 0, //在对象中使用getter/setter &#x27;block-scoped-var&#x27;: 0, //块语句中使用var &#x27;brace-style&#x27;: [1, &#x27;1tbs&#x27;], //大括号风格 &#x27;callback-return&#x27;: 0, //避免多次调用回调什么的 &#x27;amelcase: 1, //强制驼峰法命名 &#x27;comma-dangle&#x27;: [1, &#x27;never&#x27;], //对象字面量项尾不能有逗号 &#x27;comma-spacing&#x27;: 0, //逗号前后的空格 &#x27;comma-style&#x27;: [1, &#x27;last&#x27;], //逗号风格，换行时在行首还是行尾 complexity: [0, 20], //循环复杂度 &#x27;computed-property-spacing&#x27;: [0, &#x27;never&#x27;], //是否允许计算后的键名什么的 &#x27;consistent-return&#x27;: 0, //return 后面是否允许省略 &#x27;consistent-this&#x27;: [2, &#x27;that&#x27;], //this别名 &#x27;constructor-super&#x27;: 0, //非派生类不能调用super，派生类必须调用super curly: [1, &#x27;all&#x27;], //必须使用 if()&#123;&#125; 中的&#123;&#125; &#x27;default-case&#x27;: 1, //switch语句最后必须有default &#x27;dot-location&#x27;: 0, //对象访问符的位置，换行的时候在行首还是行尾 &#x27;dot-notation&#x27;: [0, &#123; allowKeywords: true &#125;], //避免不必要的方括号 &#x27;eol-last&#x27;: 0, //文件以单一的换行符结束 eqeqeq: 0, //必须使用全等 &#x27;func-names&#x27;: 0, //函数表达式必须有名字 &#x27;func-style&#x27;: [0, &#x27;declaration&#x27;], //函数风格，规定只能使用函数声明/函数表达式 &#x27;generator-star-spacing&#x27;: 0, //生成器函数*的前后空格 &#x27;guard-for-in&#x27;: 0, //for in循环要用if语句过滤 &#x27;handle-callback-err&#x27;: 0, //nodejs 处理错误 &#x27;id-length&#x27;: 0, //变量名长度 indent: [1, &#x27;tab&#x27;, &#123; SwitchCase: 1 &#125;], //缩进风格 &#x27;init-declarations&#x27;: 0, //声明时必须赋初值 &#x27;key-spacing&#x27;: [0, &#123; beforeColon: false, afterColon: true &#125;], //对象字面量中冒号的前后空格 &#x27;lines-around-comment&#x27;: 0, //行前/行后备注 &#x27;max-depth&#x27;: [0, 4], //嵌套块深度 &#x27;max-len&#x27;: [0, 80, 4], //字符串最大长度 &#x27;max-nested-callbacks&#x27;: [0, 10], //回调嵌套深度 &#x27;max-params&#x27;: [0, 20], //函数最多只能有3个参数 &#x27;max-statements&#x27;: [0, 50], //函数内最多有几个声明 &#x27;new-cap&#x27;: 0, //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &#x27;new-parens&#x27;: 1, //new时必须加小括号 &#x27;newline-after-var&#x27;: 1, //变量声明后是否需要空一行 &#x27;object-curly-spacing&#x27;: [0, &#x27;never&#x27;], //大括号内是否允许不必要的空格 &#x27;object-shorthand&#x27;: 0, //强制对象字面量缩写语法 &#x27;one-var&#x27;: 0, //连续声明 &#x27;operator-assignment&#x27;: [0, &#x27;always&#x27;], //赋值运算符 += -=什么的 &#x27;operator-linebreak&#x27;: [1, &#x27;after&#x27;], //换行时运算符在行尾还是行首 &#x27;padded-blocks&#x27;: 0, //块语句内行首行尾是否要空行 &#x27;prefer-const&#x27;: 0, //首选const &#x27;prefer-spread&#x27;: 0, //首选展开运算 &#x27;prefer-reflect&#x27;: 0, //首选Reflect的方法 quotes: [1, &#x27;single&#x27;], //引号类型 `` &quot;&quot; &#x27;&#x27; &#x27;quote-props&#x27;: [0, &#x27;always&#x27;], //对象字面量中的属性名是否强制双引号 radix: 0, //parseInt必须指定第二个参数 &#x27;id-match&#x27;: 0, //命名检测 &#x27;require-yield&#x27;: 0, //生成器函数必须有yield semi: [1, &#x27;always&#x27;], //语句强制分号结尾 &#x27;semi-spacing&#x27;: [0, &#123; before: false, after: true &#125;], //分号前后空格 &#x27;sort-vars&#x27;: 0, //变量声明时排序 &#x27;space-after-keywords&#x27;: [0, &#x27;always&#x27;], //关键字后面是否要空一格 &#x27;space-before-blocks&#x27;: [0, &#x27;always&#x27;], //不以新行开始的块&#123;前面要不要有空格 &#x27;space-before-function-paren&#x27;: [0, &#x27;always&#x27;], //函数定义时括号前面要不要有空格 &#x27;space-in-parens&#x27;: [0, &#x27;never&#x27;], //小括号里面要不要有空格 &#x27;space-infix-ops&#x27;: 0, //中缀操作符周围要不要有空格 &#x27;space-return-throw-case&#x27;: 0, //return throw case后面要不要加空格 &#x27;space-unary-ops&#x27;: [0, &#123; words: true, nonwords: false &#125;], //一元运算符的前/后要不要加空格 &#x27;spaced-comment&#x27;: 0, //注释风格要不要有空格什么的 strict: 0, //使用严格模式 &#x27;use-isnan&#x27;: 1, //禁止比较时使用NaN，只能用isNaN() &#x27;valid-jsdoc&#x27;: 0, //jsdoc规则 &#x27;valid-typeof&#x27;: 1, //必须使用合法的typeof的值 &#x27;vars-on-top&#x27;: 1, //var必须放在作用域顶部 &#x27;wrap-iife&#x27;: [1, &#x27;inside&#x27;], //立即执行函数表达式的小括号风格 &#x27;wrap-regex&#x27;: 0, //正则表达式字面量用小括号包起来 yoda: [2, &#x27;never&#x27;] //禁止尤达条件 &#125;&#125;","permalink":"http://example.com/2022/04/15/VSCode%E4%BD%BF%E7%94%A8Prettier%E6%8C%89ESLint%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/","photos":[]},{"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"elementui","slug":"elementui","permalink":"http://example.com/tags/elementui/"}],"title":"Vue2.x ElementUI项目总结","date":"2022/04/12","text":"近一个月的Vue2 ElementUI 电商后台项目的总结。 Vue2 的写法太累，data、mehtods都卸写在一起，除了用注释标记区分，结构上很是繁琐。vue3这块的Compositions API解决了这块的问题，期待后面要开始Vue3的项目。 Vue东西还是很简单，主要还是需要项目来练习。 黑马的学习视频还是不行，每次都直接把代码贴出来，念一遍，很多关联概念不解释，只说是固定写法。尚硅谷的张天禹的好太多，就是需要去跟着他的内容去理解，掰得太碎。最近在看coderwhy的视频，还可以，该讲的也讲的比较细，就是上课中间中断太多。 以下为本次项目基础总结，入口、框架、增删改查都涉及到了。 入口：main.js基础组件、样式、第三方插件引入。 axios挂载，配置请求拦截器（主要设置token到sessionStorage）和响应拦截器 12345678910111213141516171819202122232425262728293031323334import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router.js&#x27; // 路由import &#x27;./plugins/element.js&#x27; // 导入element// remixicon字体图标import &#x27;./assets/fonts/remixicon.css&#x27;// 基础样式import &#x27;./assets/css/bootstrap.css&#x27;import &#x27;./assets/css/base.css&#x27;// 导入第三方插件import TreeTable from &#x27;vue-table-with-tree-grid&#x27;// 挂载axiosimport axios from &#x27;axios&#x27;// 全局默认值，基础url路径axios.defaults.baseURL = &#x27;http://127.0.0.1:8888/api/private/v1/&#x27;// 请求拦截器axios.interceptors.request.use((config) =&gt; &#123; // 在发送请求前，配置请求头中Authorization须和sessionStorage中的token一致 config.headers.Authorization = window.sessionStorage.getItem(&#x27;token&#x27;) return config&#125;)// 将axios配置到原型上$http,可以让$http在所有Vue实例上可用Vue.prototype.$http = axios// 关闭vue开发环境提示Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 路由：router.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Login from &#x27;./components/Login&#x27;import Home from &#x27;./components/Home&#x27;import Dashboard from &#x27;./components/Dashboard&#x27;import Users from &#x27;./components/user/Users&#x27;import Rights from &#x27;./components/power/Rights&#x27;import Roles from &#x27;./components/power/Roles&#x27;import Cate from &#x27;./components/goods/Cate&#x27;import Params from &#x27;./components/goods/Params&#x27;import List from &#x27;./components/goods/List&#x27;import AddGoods from &#x27;./components/goods/Add&#x27;import Order from &#x27;./components/order/Order&#x27;import Report from &#x27;./components/report/Report&#x27;Vue.use(Router)const router = new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/login&#x27; &#125;, &#123; path: &#x27;/login&#x27;, component: Login &#125;, &#123; path: &#x27;/home&#x27;, component: Home, redirect: &#x27;/dashboard&#x27;, children: [ &#123; path: &#x27;/dashboard&#x27;, component: Dashboard &#125;, &#123; path: &#x27;/users&#x27;, component: Users &#125;, &#123; path: &#x27;/rights&#x27;, component: Rights &#125;, &#123; path: &#x27;/roles&#x27;, component: Roles &#125;, &#123; path: &#x27;/categories&#x27;, component: Cate &#125;, &#123; path: &#x27;/params&#x27;, component: Params &#125;, &#123; path: &#x27;/goods&#x27;, component: List &#125;, &#123; path: &#x27;/goods/add&#x27;, component: AddGoods &#125;, &#123; path: &#x27;/orders&#x27;, component: Order &#125;, &#123; path: &#x27;/reports&#x27;, component: Report &#125; ] &#125; ]&#125;)// 挂载路由守卫router.beforeEach((to, from, next) =&gt; &#123; // to将要访问的路径 // from从哪个路径而来 // next 一个函数，表示放行 // next()放行 next(&#x27;/login&#x27;)强制跳转 if (to.path === &#x27;/login&#x27;) return next() // 获取token const tokenStr = window.sessionStorage.getItem(&#x27;token&#x27;) // 如果没有token，强行跳转到登录 if (!tokenStr) return next(&#x27;/login&#x27;) // 如果有token则放行 next()&#125;)export default router App.vue使用路由占位符对全局路由进行控制 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 路由占位符 --&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;VApp&#x27;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Home.vue系统框架页面 Template1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;el-container&gt; &lt;!-- el-header --&gt; &lt;el-header&gt; &lt;div class=&quot;logo-block&quot;&gt; &lt;img src=&quot;../assets/logo.png&quot; class=&quot;logo-image&quot; /&gt; &lt;div class=&quot;logo-title&quot;&gt; &lt;span&gt;微店管理系统&lt;/span&gt; &lt;small&gt;SIMSHOP MANAGE&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; &lt;el-button icon=&quot;ri-menu-2-line&quot; @click=&quot;menuSwitch&quot; class=&quot;menu-switch&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;small&quot; icon=&quot;ri-shut-down-line&quot; circle @click=&quot;logout&quot; class=&quot;btn-logout&quot;&gt;&lt;/el-button&gt; &lt;/el-header&gt; &lt;!-- /el-header --&gt; &lt;!-- el-container --&gt; &lt;el-container&gt; &lt;!-- el-aside --&gt; &lt;el-aside :width=&quot;isCollapse ? &#x27;64px&#x27; : &#x27;200px&#x27; &quot;&gt; &lt;el-menu class=&quot;side-nav&quot; text-color=&quot;#6c757d&quot; active-text-color=&quot;#727cf5&quot; unique-opened :collapse=&quot;isCollapse&quot; router :default-active=&quot;activePath&quot;&gt; &lt;el-menu-item index=&quot;home&quot; route=&quot;/dashboard&quot;&gt; &lt;i class=&quot;ri-home-3-line&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;概览&lt;/span&gt; &lt;/el-menu-item&gt; &lt;!--通过两次for循环出所有一级、二级菜单--&gt; &lt;el-submenu :index=&quot;item.id + &#x27;&#x27; &quot; v-for=&quot;item in menuList&quot; :key=&quot;item.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i :class=&quot;menuIconList[item.id]&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item.authName&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item :index=&quot;&#x27;/&#x27; + subItem.path &quot; v-for=&quot;subItem in item.children&quot; :key=&quot;subItem.id&quot; @click=&quot;saveNavStatus(&#x27;/&#x27; + subItem.path)&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;span&gt;&#123;&#123;subItem.authName&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;!-- /el-aside --&gt; &lt;!-- el-main --&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;!-- /el-main --&gt; &lt;/el-container&gt; &lt;!-- /el-container --&gt; &lt;/el-container&gt; &lt;!-- /el-container --&gt;&lt;/template&gt; Script123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt;export default &#123; name: &#x27;VHome&#x27;, data() &#123; return &#123; menuList: [], menuIconList: &#123; 125: &#x27;ri-user-settings-line&#x27;, 103: &#x27;ri-shield-check-line&#x27;, 101: &#x27;ri-shopping-bag-2-line&#x27;, 102: &#x27;ri-survey-line&#x27;, 145: &#x27;ri-file-chart-line&#x27; &#125;, isCollapse: false, activePath: &#x27;&#x27; &#125; &#125;, created() &#123; // 页面加载时获取左侧菜单导航数据 this.getMenuList() // 获取token this.activePath = window.sessionStorage.getItem(&#x27;activePath&#x27;) &#125;, methods: &#123; logout() &#123; window.sessionStorage.clear() this.$router.push(&#x27;/login&#x27;) &#125;, // 发起请求获取菜单导航数据 async getMenuList() &#123; const &#123; data: res &#125; = await this.$http.get(&#x27;menus&#x27;) if (res.meta.status !== 200) return this.$message.error(res.meta.msg) this.menuList = res.data // 将获取到的菜单导航数据 赋值给 menuList &#125;, menuSwitch() &#123; this.isCollapse = !this.isCollapse &#125;, // 验证token是否一致 saveNavStatus(activePath) &#123; window.sessionStorage.setItem(&#x27;activePath&#x27;, activePath) this.activePath = activePath &#125; &#125; &#125;&lt;/script&gt; Css123456789101112131415&lt;style scoped&gt;.el-container &#123; height:100vh; background-color:#fafbfe;&#125;.el-header &#123; background-color:#313a46;&#125;.el-aside &#123; background-color:#fff; box-shadow:1px 0 8px rgba(33,33,33,.05);&#125;.logo-block &#123; float:left; display:flex; justify-content:flex-start; align-items:center; width:180px; height:60px; border-right:1px solid rgba(255,255,255,.1)&#125;.logo-block .logo-image &#123; margin-right:10px; max-width:32px; height:32px;&#125;.logo-block .logo-title &#123; color:#fff;&#125;.logo-block .logo-title span &#123; display:block; clear:both; margin-top:4px; height:16px; line-height:16px; font-size:16px;&#125;.logo-block .logo-title small &#123; height:14px; line-height:14px; font-size:12px; color:#9e9e9e; font-family:Arial, Helvetica, sans-serif;&#125;.menu-switch &#123; float:left; margin-top:6px !important; border:none !important; background-color:transparent !important; font-size:24px !important; color:#6c757d !important;&#125;.btn-logout &#123; float:right; margin-top:12px !important; padding:9px 10px !important; font-size:14px !important;&#125;.side-nav &#123;border-right:0 !important;&#125;.el-menu .el-submenu [class^=&quot;ri-&quot;] &#123; font-size:16px;&#125;.el-menu .el-submenu span,.el-menu .el-menu-item span &#123; margin-left:8px; &#125;&lt;/style&gt; 列表获取数据 ListTemplate12345678910111213141516171819202122232425262728&lt;template&gt; &lt;el-table :data=&quot;userlist&quot; highlight-current-row size=&quot;medium&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&quot;index&quot; :index=&quot;indexMethod&quot; label=&quot;#&quot; width=&quot;80&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;username&quot; label=&quot;姓名&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;mg_state&quot; label=&quot;用户状态&quot; width=&quot;120&quot;&gt; &lt;!--作用域插槽--&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!--switch的change事件，将scope.row上获取的data作为参数传给事件--&gt; &lt;el-switch v-model=&quot;scope.row.mg_state&quot; @change=&quot;userStateChange(scope.row)&quot;&gt;&lt;/el-switch&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;300&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!--通过scope将id传给editDialog事件--&gt; &lt;el-button size=&quot;mini&quot; type=&quot;success&quot; plain @click=&quot;editDialog(scope.row.id)&quot;&gt; &lt;i class=&quot;ri-file-edit-line float-start me-1&quot;&gt;&lt;/i&gt; &lt;span class=&quot;float-start&quot;&gt;编辑&lt;/span&gt; &lt;/el-button&gt; &lt;el-button size=&quot;mini&quot; type=&quot;danger&quot; plain @click=&quot;delUserById(scope.row.id)&quot;&gt; &lt;i class=&quot;ri-delete-bin-6-line float-start me-1&quot;&gt;&lt;/i&gt; &lt;span class=&quot;float-start&quot;&gt;删除&lt;/span&gt; &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--分页--&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;queryInfo.pagenum&quot; :page-sizes=&quot;[10, 20, 50, 100]&quot; :page-size=&quot;queryInfo.pagesize&quot; background layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt;&lt;/template&gt; Script123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt;data() &#123; return &#123; userlist: [], // 存放列表数据 queryInfo: &#123; // 存放分页信息 query: &#x27;&#x27;, // 分页参数 pagenum: 1, // 当前页数 pagesize: 10 // 每页显示条数 &#125;, total: 0 // 分页数据条数 &#125;, created() &#123; // 页面创建后，获取列表数据 this.getUserList() &#125;, methods: &#123; // 列表编号 indexMethod(index) &#123; return index + 1 &#125;, // 发起请求获取列表数据 async getUserList() &#123; const &#123; data: res &#125; = await this.$http.get(&#x27;users&#x27;, &#123; params: this.queryInfo&#125;) if (res.meta.status !== 200) &#123; return this.$message.error(&#x27;用户获取失败&#x27;) &#125; this.userlist = res.data.users this.total = res.data.total &#125;, // 监听pagesize改变事件 handleSizeChange(newSize) &#123; this.queryInfo.pagesize = newSize this.getUserList() &#125;, handleCurrentChange(newPage) &#123; // 监听当前页面改变事件 this.queryInfo.pagenum = newPage this.getUserList() &#125;, async userStateChange(userInfo) &#123; // 监听Switch开关 用户状态 const &#123; data: res &#125; = await this.$http.put(`users/$&#123;userInfo.id&#125;/state/$&#123;userInfo.mg_state&#125;`) if (res.meta.status !== 200)&#123; userInfo.mg_state = !userInfo.mg_state return this.$message.error(&#x27;用户状态更新失败&#x27;) &#125; this.$message.success(&#x27;用户状态更新成功&#x27;) &#125;,&#125;&lt;/script&gt; 添加弹层 AddTemplate123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- dialog:addUser --&gt;&lt;!--* 弹层配置* :visible.sync=&quot;addUserVisible&quot;: 控制弹层显示隐藏* @close=&quot;addDialogClose&quot;: 弹层关闭后事件，重置表单清除表单数据和验证提示信息--&gt;&lt;el-dialog title=&quot;添加用户&quot; :visible.sync=&quot;addUserVisible&quot; width=&quot;640px&quot; @close=&quot;addDialogClose&quot;&gt; &lt;span&gt; &lt;!-- * 表单配置 Form * :model=&quot;addUser&quot;: 表单数据。提交表单后，数据存放 * :rules=&quot;addUserRules&quot;: 表单验证规则 * ref=&quot;addUserRef&quot;: 获取表单数据，主要给提交表单时做数据预校验使用 * label-width=&quot;80px&quot;: 设置表单标题宽度 * 表单项 Form Item * label=&quot;用户名&quot;: 表单项标题 * prop=&quot;username&quot;: 表单项储存数据字段名称供model做数据绑定 * v-model=&quot;addUser.username&quot; 表单项数据存储的字段名称 * 提交表单 * @click=&quot;addUserForm&quot;: 点击确定按钮后的提交事件 --&gt; &lt;el-form :model=&quot;addUser&quot; :rules=&quot;addUserRules&quot; ref=&quot;addUserRef&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;el-input v-model=&quot;addUser.username&quot; clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;addUser.password&quot; show-password&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;addUser.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机&quot; prop=&quot;mobile&quot;&gt; &lt;el-input v-model=&quot;addUser.mobile&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/span&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer border-top d-block pt-3&quot;&gt; &lt;el-button @click=&quot;addUserVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addUserForm&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt;&lt;!-- /dialog --&gt; Script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;script&gt;export default &#123; name: &#x27;VUser&#x27;, data() &#123; // 自定义邮箱验证规则 const checkEmail = (rule, value, callback) =&gt; &#123; const regEmail = /^\\w+@\\w+(\\.\\w+)+$/ if (regEmail.test(value)) return callback() callback(new Error(&#x27;请输入正确的邮箱&#x27;)) &#125; // 自定义邮箱验证规则 const checkMobile = (rule, value, callback) =&gt; &#123; const regMobile = /^1[34578]\\d&#123;9&#125;$/ if (regMobile.test(value)) return callback() callback(new Error(&#x27;请输入正确的手机号码&#x27;)) &#125; return &#123; //添加用户对话框控制 addUserVisible: false, // 添加用户数据 addUser: &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, email: &#x27;&#x27;, mobile: &#x27;&#x27; &#125;, // 添加用户验证规则 addUserRules: &#123; username: [ &#123; require: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123; min: 3, max: 16, message: &#x27;长度为3 ~ 16 个字符&#x27;, trigger: &#x27;blur&#x27;&#125; ], password: [ &#123; require: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123; min: 6, max: 24, message: &#x27;长度为6 ~ 24 个字符&#x27;, trigger: &#x27;blur&#x27;&#125; ], email: [ &#123; require: true, message: &#x27;请输入邮箱&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123; validator: checkEmail, trigger: &#x27;blur&#x27;&#125; ], mobile: [ &#123; require: true, message: &#x27;请输入手机&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123; validator: checkMobile, trigger: &#x27;blur&#x27;&#125; ] &#125; &#125; &#125;, methods: &#123; // 监听添加用户弹层关闭事件，重置表单项 addDialogClose()&#123; this.$refs.addUserRef.resetFields() &#125;, addUserForm()&#123; // 添加表单数据之前使用$refs的validate对表单数据进行预校验 this.$refs.addUserRef.validate(async valid =&gt; &#123; // 如果校验失败，跳出 if (!valid) return false const &#123; data: res &#125; = await this.$http.post(&#x27;users&#x27;, this.addUser) // 如果服务端返回的状态码不为201则弹出添加失败提示 if (res.meta.status !== 201)&#123; return this.$message.error(&#x27;用户添加失败&#x27;) &#125; this.$message.success(&#x27;用户添加成功&#x27;) // 关闭弹层 this.addUserVisible = false // 刷新用户列表 this.getUserList() &#125;) &#125;, &#125; 编辑弹层 EditTemplate 编辑和添加类似，编辑弹层在点击弹层显示时，需进行表单数据GET请求，将数据库中的数据加载到表单。 在提交表单时需进行PUT更新请求，将数据更新到数据库中。 编辑表单和添加表单表单项基本一致时，可使用添加表单的验证配置 :rules=&quot;addUserRules&quot; 123456789101112131415161718192021&lt;!-- dialog:editUser --&gt;&lt;el-dialog title=&quot;编辑用户&quot; :visible.sync=&quot;editUserVisible&quot; width=&quot;640px&quot; @close=&quot;editDialogClose&quot;&gt; &lt;span&gt; &lt;el-form :model=&quot;editUser&quot; :rules=&quot;editUserRules&quot; ref=&quot;editUserRef&quot; :label-position=&quot;labelPosition&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot;&gt; &lt;el-input v-model=&quot;editUser.username&quot; clearable disabled&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; prop=&quot;email&quot;&gt; &lt;el-input v-model=&quot;editUser.email&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机&quot; prop=&quot;mobile&quot;&gt; &lt;el-input v-model=&quot;editUser.mobile&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt;&lt;/span&gt;&lt;span slot=&quot;footer&quot; class=&quot;dialog-footer border-top d-block pt-3&quot;&gt; &lt;el-button @click=&quot;editUserVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;editUserForm&quot;&gt;确 定&lt;/el-button&gt;&lt;/span&gt;&lt;/el-dialog&gt;&lt;!-- /dialog --&gt; Script123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export default &#123; data() &#123; return &#123; // 储存表单数据 editUser: &#123;&#125;, // 编辑用户对话框控制 editUserVisible: false, // 添加用户验证规则 editUserRules: &#123; email: [ &#123; require: true, message: &#x27;请输入邮箱&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123; validator: checkEmail, trigger: &#x27;blur&#x27;&#125; ], mobile: [ &#123; require: true, message: &#x27;请输入手机&#x27;, trigger: &#x27;blur&#x27;&#125;, &#123; validator: checkMobile, trigger: &#x27;blur&#x27;&#125; ] &#125; &#125;, methods: &#123; // 点击编辑表单弹层事件，需将对应数据id传过来 async editDialog(uid)&#123; const &#123; data: res &#125; = await this.$http.get(`users/$&#123;uid&#125;`) if (res.meta.status !== 200)&#123; return this.$message.error(&#x27;查询用户失败&#x27;) &#125; this.editUser = res.data this.editUserVisible = true &#125;, // 监听编辑用户弹层关闭事件，重置表单项 editDialogClose()&#123; this.$refs.editUserRef.resetFields() &#125;, // 提交表单，更新表单数据，注意api中需要传递的参数 editUserForm()&#123; this.$refs.editUserRef.validate(async valid =&gt; &#123; if (!valid) return const &#123; data: res &#125; = await this.$http.put(`users/$&#123;this.editUser.id&#125;`, &#123; email: this.editUser.email, mobile: this.editUser.mobile&#125;) if (res.meta.status !== 200)&#123; return this.$message.error(&#x27;用户编辑失败&#x27;) &#125; this.$message.success(&#x27;用户编辑成功&#x27;) this.editUserVisible = false this.getUserList() &#125;) &#125;, &#125; &#125; 删除 DeleteScript123456789101112131415161718192021222324export default &#123; methods: &#123; // 删除数据事件，需将数据id传过来 async delUserById(uid)&#123; // 点击删除按钮后，弹出二次确认弹层 const confirmResult = await this.$confirm(&#x27;此操作将永久删除该用户, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;删除&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;danger&#x27; &#125;).catch(err =&gt; err) // 点击删除按钮，进行确认判断，如果不为删除，则取消删除事件 if (confirmResult !== &#x27;confirm&#x27;) &#123; return this.$message.info(&#x27;已取消删除&#x27;) &#125; // 如判断为删除，则进行删除请求将id传给服务端 const &#123; data: res &#125; = await this.$http.delete(`users/$&#123;uid&#125;`) if (res.meta.status !== 200)&#123; return this.$message.error(&#x27;删除用户失败&#x27;) &#125; this.$message.success(&#x27;用户删除成功&#x27;) this.getUserList() &#125; &#125;&#125;","permalink":"http://example.com/2022/04/12/Vue2%20ElementUI%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","photos":[]},{"tags":[{"name":"electron","slug":"electron","permalink":"http://example.com/tags/electron/"}],"title":"Electron无法正常启动问题记录","date":"2022/04/06","text":"周末折腾了一下Electron，出现了Electron 无法正确安装，请删除 node_modules/electron 并尝试再次安装这样的错误，查了很多资料。 恰巧中午看到了一个帖子，按照步骤基本解决启动问题了。 步骤如下： 先到usr/local/lib/node_modules中删除Electron的文件夹 然后使用官方npm安装好全局electron npm i electron@latest -g 然后进入到到usr/local/lib/node_modules/Electron文件夹中，打开终端运行node instatll.js 查看下chrome的版本，按官方升级到对应版以上 1234npm i -D electron@latest# Electron 18.0.1# Node 16.13.2#Chromium 100.0.4896.60 然后再次启动就可以了成功了。","permalink":"http://example.com/2022/04/06/Electron%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","photos":[]},{"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}],"title":"从0开始搭建Hexo博客","date":"2022/03/22","text":"本文记录本人搭建Hexo博客的全流程。 会在终端敲点命令，加上点前端知识会让上手更加快捷。 前言hexo是一个静态博客，很多好处别人都说了，我就不再赘述。按照网上的各种教程其实搭建起来是很容易的，我在说一遍也没有什么太多花样。在这个遍地内卷的世界，一个教程我都看到n个版本，各说各的，但是问题还是会。 我整理了下几个常见的问题： 很多教程都是n年前的，很多情况已经发生变化，比如配置git，之前的master因为2020年“黑命贵”的事件变成了main。 因为是静态博客，所以很多配置项都是使用_config.yml来进行，但里面一段段英文会让我脑壳痛。后面我会逐一翻译成中文进行说明。网上这块的东西应该会比较少。虽然简单，但对小白可以降低一点门槛。 另外，官方给了很多命令缩写，有的时候完整命令要敲几次，我做个整理，快速速达到你们想要的目的。 博客很多主题，我觉得后面可以研究下，有时间再整个教程一起分享下。 好了开始我们的hexo之旅吧~ 安装安装前提官方的说明已经比较清楚了，需要准备node.js和Git。 node.js Git 这里到对应的官方按照官方的说明安装就可以了，需要注意的是版本问题，安装新的版本即可。 安装hexo安装好node.js后就可以开始安装hexo到本地。Git只是后面需要将hexo放到Github上时使用。 调出你的终端，运行如下命令 123npm install -g hexo-cli// 简写npm i hexo-cli -g 这里的意思，是安装hexo的全局脚手架 安装完成以后你可以运行如下命令： 123hexo -version// 简写hexo -v 如果此时出来一堆各种文件的版本，那么你就已经安装好hexo了。内容大概如下： 123456789101112131415161718192021hexo: 6.1.0hexo-cli: 4.3.0os: darwin 21.4.0 12.3node: 17.6.0v8: 9.6.180.15-node.13uv: 1.43.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 102nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 3.0.1+quiccldr: 40.0icu: 70.1tz: 2021a3unicode: 14.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV 安装好hexo后，找到需要放置hexo的文件夹，不用新建一个空文件夹放hexo后面hexo在初始化的时的命令可以指定一个文件夹，当然新建好也没问题命令不一样而已。 运行如下命令 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install // 简写 npm i 这里的意思是初始化hexo 如果指定了文件夹folder，那么就在指定的文件夹中初始化，如果没有文件夹，就在当前文件夹初始化。 如果指定了文件夹，就需要按照第2行的命令，进入到指定文件夹。如果没有指定文件夹直接执行第3行。 第3行就是安装hexo各种所需文件到指定或当前文件夹中。 命令执行完成后，你的hexo就已经安装好了。 那么你可以继续运行如下命令： 123456789hexo cleanhexo generatehexo server// 简写hexo clhexo ghexo s// 连续简写hexo cl&amp;&amp;hexo g&amp;&amp;hexo s 说下这三行命令的作用 hexo clean 删除hexo的缓存，建议每次都执行，以免因缓存看不到修改的效果。 hexo generate 创建缓存文件 hexo server 启动服务器 以上命令建议使用连续写法hexo cl&amp;&amp;hexo g&amp;&amp;hexo s，只需要一次命令完成三个动作。 运行完以上命令，终端中会出现 http://localhost:4000/ 的地址，那就是你本地的预览效果。 至此，恭喜你第一阶段完成。 部署部署可以部署到github或者gitee，此处过程省略。 配置少部署的内容，可以使用以下命令进行生成静态文件部署到服务器。 12345hexo cleanhexo generatehexo deploy//连续写法hexo cl&amp;hexo g&amp;hexo d 常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本","permalink":"http://example.com/2022/03/22/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/","photos":[]}],"categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"redux-toolkit","slug":"redux-toolkit","permalink":"http://example.com/tags/redux-toolkit/"},{"name":"zustand","slug":"zustand","permalink":"http://example.com/tags/zustand/"},{"name":"valtio","slug":"valtio","permalink":"http://example.com/tags/valtio/"},{"name":"typescript","slug":"typescript","permalink":"http://example.com/tags/typescript/"},{"name":"react-query","slug":"react-query","permalink":"http://example.com/tags/react-query/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"react-router","slug":"react-router","permalink":"http://example.com/tags/react-router/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"chakraui","slug":"chakraui","permalink":"http://example.com/tags/chakraui/"},{"name":"firebase","slug":"firebase","permalink":"http://example.com/tags/firebase/"},{"name":"api","slug":"api","permalink":"http://example.com/tags/api/"},{"name":"styled-components","slug":"styled-components","permalink":"http://example.com/tags/styled-components/"},{"name":"auth0","slug":"auth0","permalink":"http://example.com/tags/auth0/"},{"name":"formik","slug":"formik","permalink":"http://example.com/tags/formik/"},{"name":"strapi","slug":"strapi","permalink":"http://example.com/tags/strapi/"},{"name":"graphQL","slug":"graphQL","permalink":"http://example.com/tags/graphQL/"},{"name":"nextjs","slug":"nextjs","permalink":"http://example.com/tags/nextjs/"},{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"},{"name":"prettier","slug":"prettier","permalink":"http://example.com/tags/prettier/"},{"name":"eslint","slug":"eslint","permalink":"http://example.com/tags/eslint/"},{"name":"icon","slug":"icon","permalink":"http://example.com/tags/icon/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"elint","slug":"elint","permalink":"http://example.com/tags/elint/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"ElementPlus","slug":"ElementPlus","permalink":"http://example.com/tags/ElementPlus/"},{"name":"避坑指南","slug":"避坑指南","permalink":"http://example.com/tags/%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"name":"pinia","slug":"pinia","permalink":"http://example.com/tags/pinia/"},{"name":"vuex","slug":"vuex","permalink":"http://example.com/tags/vuex/"},{"name":"elementui","slug":"elementui","permalink":"http://example.com/tags/elementui/"},{"name":"electron","slug":"electron","permalink":"http://example.com/tags/electron/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}