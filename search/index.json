[{"content":"终于二刷了 Codevolution 大佬的这个系列，感觉比第一次确实是有了更多的理解。配合之前的foromik使用杠杠滴~\n教程地址：React Query Tutorial for Beginners\nReactQuery 官方地址：ReactQuery\n部分中文文档地址：Tanstact Query 中文文档\nReact Query 是什么？\n是用于在 React 应用中获取数据的库(library)\n‍\n为什么使用 React Query？\n由于 React 是一个 UI 库，没有特定的数据获取模式。\n可以使用useEffect这个钩子函数获取数据，使用useState来维护组件状态，如数据的加载（loading）、错误（error）、结果数据（data）等等。\n如果整个应用程序都需要数据状态管理，我们可以使用状态库管理比如Redux、Mobx。\n但大多数状态管理库都适用于处理客户端状态，比如主题的开关等。\n状态库不适合处理异步或服务器状态，比如 Redux 中的异步处理需要借助第三方的thunk和saga才能处理异步的状态。\n而使用 ReactQuery 可以更好的管理异步数据加载的状态、错误、结果数据等。类似的 Redux 为了更好的处理异步数据请求，在除了简化模板代码的 ReduxToolkit 后，又整了个 RTK Query，就是来对标 ReactQuery 的。但还是很多不如 ReactQuery。\n‍\n以下为几个请求状态库的对比。\n比较 | React Query vs SWR vs Apollo vs RTK Query vs React Router\n‍\n安装\u0026amp;配置 ReactQuery 的 v4 以上版本和之前的版本安装有些不一样，我们都按 v4 版本的来。\n1 pnpm add @tanstack/react-query 安装完成后我们需要对项目进行配置，通过 QueryClientProvider 将查询到的状态通过 Provider 传递给其他页面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // app.js import React from \u0026#39;react\u0026#39; import { BrowserRouter } from \u0026#39;react-router-dom\u0026#39; import { QueryClientProvider, QueryClient } from \u0026#39;@tanstack/react-query\u0026#39; import RootRoute from \u0026#39;@/router\u0026#39; import RootStyle from \u0026#39;@/styles/base.style\u0026#39; import Layout from \u0026#39;@/components/Layout\u0026#39; const queryClient = new QueryClient() const App = () =\u0026gt; { return ( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;RootStyle /\u0026gt; \u0026lt;Layout\u0026gt; \u0026lt;RootRoute /\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ) } export default App const queryClient = new QueryClient()这里可以设置 ReactQuery 的一些默认配置，我们稍后会提到。\n‍\n获取数据 配置完成就可以使用 ReactQuery 了。我们先对比下之前如何获取数据。\n之前的做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // src/pages/SuperHero/index.jsx import React, { useState, useEffect } from \u0026#39;react\u0026#39; import axios from \u0026#39;axios\u0026#39; const SuperHero = () =\u0026gt; { const [isLoading, setIsLoading] = useState(true) const [data, setData] = useState([]) useEffect(() =\u0026gt; { axios(\u0026#39;http://localhost:4000/superheros\u0026#39;).then(res =\u0026gt; { setData(res.data) setIsLoading(false) }) }, []) if (isLoading) { return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;SuperHero\u0026lt;/h4\u0026gt; {data?.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } export default SuperHero ‍\n使用 ReactQuery 的做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // src/pages/RQSuperHero/index.jsx import React from \u0026#39;react\u0026#39; import { useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const RQSuperHero = () =\u0026gt; { const fetcher = () =\u0026gt; axios(\u0026#39;http://localhost:4000/superheros\u0026#39;) const { data, isLoading } = useQuery([\u0026#39;rqsuperhero\u0026#39;], fetcher) if (isLoading) { return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; {data?.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } export default RQSuperHero 肉眼可见的代码减少了，复杂度也低了，ReactQuery 通过 fetcher 这个请求函数就直接返回了数据和加载状态，但是他给的远远不止这些。我们后面会有更多了解。\n这里需要注意useQuery后面的括号中最少需要两个参数\n第一个是查询键，必须是唯一的。以前的版本只需要一个可以序列化的参数，所以可以使用字符串，但 v4 版本后必须放到数组中。\n第二个是请求函数，一般我们可以配置到这个useQuery的方法外面统一管理。\nuseQuery可以返回给我们获取数据的中间加载状态isLoading和加载之后的数据data\n‍\n获取请求时的错误 将请求地址写错，达到出错的效果。\n‍\n之前的做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // src/pages/SuperHero/index.jsx import React, { useState, useEffect } from \u0026#39;react\u0026#39; import axios from \u0026#39;axios\u0026#39; const SuperHero = () =\u0026gt; { const [isLoading, setIsLoading] = useState(true) const [error, setError] = useState(\u0026#39;\u0026#39;) const [data, setData] = useState([]) useEffect(() =\u0026gt; { axios(\u0026#39;http://localhost:4000/superheros1\u0026#39;) .then(res =\u0026gt; { setData(res.data) setIsLoading(false) }) .catch(error =\u0026gt; { setError(error.message) setIsLoading(false) }) }, []) if (isLoading) { return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; } if (error) { return \u0026lt;div\u0026gt;出错了： {error}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;SuperHero\u0026lt;/h4\u0026gt; {data?.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } export default SuperHero ‍\nReactQuery 的做法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // src/pages/RQSuperHero/index.jsx import React from \u0026#39;react\u0026#39; import { useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const RQSuperHero = () =\u0026gt; { const fetcher = () =\u0026gt; axios(\u0026#39;http://localhost:4000/superheros1\u0026#39;) const { data, isLoading, isError, error } = useQuery([\u0026#39;rqsuperhero\u0026#39;], fetcher) if (isLoading) { return \u0026lt;div\u0026gt;加载中\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; {data?.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } export default RQSuperHero isError是获取数据出错的状态，error可以获取出错后返回地的错误消息message\n当发生错误时，ReactQuery 默认还是会去请求三次，如果还是错误才会返回错误消息。\n‍\n开发工具 DevTools 安装\n1 pnpm add @tanstack/react-query-devtools 配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import React from \u0026#39;react\u0026#39; import { BrowserRouter } from \u0026#39;react-router-dom\u0026#39; import { QueryClientProvider, QueryClient } from \u0026#39;@tanstack/react-query\u0026#39; import { ReactQueryDevtools } from \u0026#39;@tanstack/react-query-devtools\u0026#39; import RootRoute from \u0026#39;@/router\u0026#39; import RootStyle from \u0026#39;@/styles/base.style\u0026#39; import Layout from \u0026#39;@/components/Layout\u0026#39; const queryClient = new QueryClient() const App = () =\u0026gt; { return ( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;BrowserRouter\u0026gt; \u0026lt;RootStyle /\u0026gt; \u0026lt;ReactQueryDevtools initialIsOpen={false} position=\u0026#39;bottom-right\u0026#39; /\u0026gt; \u0026lt;Layout\u0026gt; \u0026lt;RootRoute /\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/BrowserRouter\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ) } export default App 参数说明：\ninitialIsOpen：是否开启调试工具，默认是开启，为了不影响我们这里设置关闭。\nposition：调试工具的显示位置，默认为左下，设置到右下，才是我们比较习惯的地方。\n‍\n点击右下角的图标就可以看到这个开发工具的样子了。\n左侧的rqsuperhero就是我们使用ReactQuery的查询键。点击可以看到右侧相关的一些数据情况。\n最上面有一排按钮，分别是：新鲜的fresh、正在获取的fetching、暂停的paused、陈旧的stale、闲置的inactive。这几个状态就是ReactQuery对数据请求和响应的状态处理，后面在ReactQuery配置中会提到这些。\n​\nReactQuery DevTools用的不多，仅做介绍。\n‍\n缓存 ReactQuery 默认缓存时间为 5 分钟。当 ReactQuery 首次获取到数据后就会通过查询键对数据进行缓存。\n当数据没有发生变化时，ReactQuery 每次获取数据会与缓存中的数据对比，如没有变化，则从缓存中返回数据。\n如果发生变化则会在后台对变化的数据缓存进行更新。所以已经更新的数据会直接从缓存中获取，并不会显示对应的加载状态。\n当数据缓存时间过后，再次查询数据时则会发生数据请求，而不会在缓存中获取数据。我们可以在 useQuery 中配置该次请求的缓存时间。\n1 2 3 const { data, isLoading, isError, error } = useQuery([\u0026#39;rqsuperhero\u0026#39;], fetcher, { cacheTime: 5000 }) 查询缓存的好处就是减少对不一定经常更新的数据的网络请求数量。 ‍\n陈旧时间 如果用户对看到过时的数据也没影响，使用缓存显示查询结果，而不需要在后台重新获取数据。但是对更新频繁的数据，我需要实时获取变化情况，缓存则会影响我们，那么可以设置陈旧时间，让数据可以在一段时间内保持新鲜，但过期后，数据就变成陈旧的数据，需要重新发起请求获取。\n1 2 3 const { data, isLoading, isError, error, isFetching } = useQuery([\u0026#39;rqsuperhero\u0026#39;], fetcher, { staleTime: 30000 }) 我们可以设置staleTime陈旧时间，30 秒后数据就会变为陈旧数据，如果再查看数据或者有ReactQuery的更新事件触发，则会发起请求更新缓存。ReactQuery​ 有很多事件来触发更新，比如浏览器页面失去焦点后再次获取到焦点，会触发更新等等，后面会介绍到。\n如果我们设置staleTime: 0则会每次查看数据或触发更新事件时数据就会更新。\n‍\n获取数据 ReactQuery 给了几个触发获取数据的配置，我们来看下。\n当挂载时获取数据，refetchOnMount：\n设置为 true，如果数据过时，则在加载组件时 获取数据。true 是默认值。\n设置为 false，将禁用组件加载获取数据。\n设置为 always，则将始终在加载组件时获取数据。\n设置为函数，则该函数执行的获取结果得到一个布尔值作为设置的值(query) =\u0026gt; boolean。\n当浏览器窗口获取到焦点时获取数据，refetchOnWindowFocus：\n设置为 true，如果数据过时，则在浏览器窗口获取到焦点时获取数据，true 是默认值。\n设置为 false，则在浏览器窗口获取到焦点时，不会获取数据。\n设置为 always，则始终在浏览器窗口获取到焦点时获取数据。\n设置为函数，则该函数执行的获取结果得到一个布尔值作为设置的值(query) =\u0026gt; boolean。\n在时间间隔内连续获取数据，refetchInterval：\n设置为数字，则以毫秒为单位，在该时间范围内连续获取数据。\n设置为函数，则该函数的执行结果得到一个数值作为获取数据的时间范围(data, query) =\u0026gt; number | false。\n默认值为 false\n在后台连续获取数据的时间间隔，refetchIntervalInBackground：\n设置为 true，则在浏览器标签页或窗口处于后台时获取数据。\n默认值为 false\n当重新连接时获取数据，refetchOnReconnect：\n设置为 true，如果数据过时，则在重新连接时获取数据。\n设置为 false，则不会在重新连接时获取数据。\n设置为函数，则该函数执行的获取结果得到一个布尔值作为设置的值(query) =\u0026gt; boolean。\n默认值为 networkOnline（true)\n1 2 3 4 5 6 7 8 const { data, isLoading, isError, error, isFetching } = useQuery([\u0026#39;rqsuperhero\u0026#39;], fetcher, { staleTime: 0, refetchOnMount: true, refetchOnWindowFocus: true, refetchInterval: false, refetchIntervalInBackground: false, refetchOnReconnect: true }) ‍\n通过事件的方式获取数据 首先需要将通过挂载组件、浏览器获取焦点等就获取数据的方式禁用，我们可以设置enabled: false将禁止查询行为自动运行。\n然后通过从useQuery中解析出来的refetch方法获取数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const { data, isLoading, isError, error, isFetching, refetch } = useQuery( [\u0026#39;rqsuperhero\u0026#39;], fetcher, { enabled: false } ) if (isLoading || isFetching) { return \u0026lt;div\u0026gt;加载中\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; \u0026lt;button onClick={refetch}\u0026gt;Fetch Super Hero\u0026lt;/button\u0026gt; {data?.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) ‍\n成功或失败的回调函数 ReactQuery 的第三个参数中可以配置当获取数据成功或失败时的回调函数。有些数据在获取成功后我们需要存到 store 中，就可以使用这个方法。\n1 2 3 4 5 6 7 8 9 10 11 12 const { data, isLoading, isError, error, isFetching, refetch } = useQuery( [\u0026#39;rqsuperhero\u0026#39;], fetcher, { onSuccess: data =\u0026gt; { console.log(\u0026#39;获取数据成功\u0026#39;, data) }, onError: error =\u0026gt; { console.log(\u0026#39;获取数据失败\u0026#39;, error.message) } } ) ‍\n转换或筛选查询数据 可以使用select方法对数据进行加工，返回我们需要返回的结果。\n比如：在示例中加入了女性超级英雄。我们可以筛选超级英雄的性别，将女超级英雄查询出来。然后只返回女超级英雄的名字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const { data, isLoading, isError, error, isFetching, refetch } = useQuery( [\u0026#39;rqsuperhero\u0026#39;], fetcher, { select: data =\u0026gt; { const femaleHero = data.data.filter(hero =\u0026gt; hero.gender === \u0026#39;female\u0026#39;).map(hero =\u0026gt; hero.name) return femaleHero } } ) return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; {data?.map((hero, index) =\u0026gt; ( \u0026lt;div key={hero}\u0026gt;{hero}\u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) ‍\n通过参数查询 最简单的例子就是查看详情了。\n路由加上详情的配置，通过heroId来查询\n1 2 3 4 5 6 7 8 9 // src/router/index.jsx const routes = [ { path: \u0026#39;/\u0026#39;, element: \u0026lt;Navigate to=\u0026#39;/home\u0026#39; /\u0026gt; }, { path: \u0026#39;/home\u0026#39;, element: \u0026lt;Home /\u0026gt; }, { path: \u0026#39;/sh\u0026#39;, element: \u0026lt;SuperHero /\u0026gt; }, { path: \u0026#39;/rqsh\u0026#39;, element: \u0026lt;RQSuperHero /\u0026gt; }, { path: \u0026#39;/rqsh/:heroId\u0026#39;, element: \u0026lt;RQSuperHeroPersonal /\u0026gt; } ] 在列表页加上链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // src/pages/RQSuperHero/index.jsx import React from \u0026#39;react\u0026#39; import { Link } from \u0026#39;react-router-dom\u0026#39; import { useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const RQSuperHero = () =\u0026gt; { const fetcher = () =\u0026gt; axios(\u0026#39;http://localhost:4000/superheros\u0026#39;) const { data, isLoading, isError, error, isFetching } = useQuery([\u0026#39;rqsuperhero\u0026#39;], fetcher) if (isLoading || isFetching) { return \u0026lt;div\u0026gt;加载中\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; {data?.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; \u0026lt;Link to={`/rqsh/${hero.id}`}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ) } export default RQSuperHero 在pages目录下添加一个RQSuperHeroPersonal文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // src/pages/RQSuperHeroPersonal/index.jsx import React from \u0026#39;react\u0026#39; import { useParams } from \u0026#39;react-router-dom\u0026#39; import { useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const RQSuperHeroPersonal = () =\u0026gt; { const { heroId } = useParams() const fetcher = heroId =\u0026gt; axios(`http://localhost:4000/superheros/${heroId}`) const { data, isLoading, isError, error } = useQuery([\u0026#39;rqsuperheropersonal\u0026#39;, heroId], () =\u0026gt; fetcher(heroId) ) if (isLoading) { return \u0026lt;div\u0026gt;加载中\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; {data?.data.id}. {data?.data.name} - {data?.data.alterEgo} - {data?.data.gender} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default RQSuperHeroPersonal 使用参数查询时需要注意，需要将参数放入查询键的数组中。并且，查询函数需要写成箭头函数形式用于传递参数。\n‍\n并行查询 如果页面上有多组数据需要并行同时查询，可以使用useQueries来进行查询。\n我们在示例的db.json中加入DC Super Hero。这样就有两组超级英雄需要一起来查询。\n新建一个RQSuperHeroLeague的页面。配置好路由。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // src/pages/RQSuperHeroLeague/index.jsx import React from \u0026#39;react\u0026#39; import { Link } from \u0026#39;react-router-dom\u0026#39; import { useQueries } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const SuperHeroLeague = () =\u0026gt; { const fetchMarvalHero = () =\u0026gt; axios(\u0026#39;http://localhost:4000/superheros\u0026#39;) const fetchDcHero = () =\u0026gt; axios(\u0026#39;http://localhost:4000/dcsuperheros\u0026#39;) const results = useQueries({ queries: [ { queryKey: [\u0026#39;marvalsuperhero\u0026#39;], queryFn: fetchMarvalHero }, { queryKey: [\u0026#39;dcsuperhero\u0026#39;], queryFn: fetchDcHero } ] }) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Super Hero League\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; {results?.map((league, index) =\u0026gt; ( \u0026lt;ul key={index}\u0026gt; {league.data?.data.map(hero =\u0026gt; ( \u0026lt;li key={hero.id}\u0026gt; {hero.id}. {hero.name} - {hero.alterEgo} \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default SuperHeroLeague 这种并行查询，会把查询的结果放到一个数组中，在获取数据时会同时发起查询，同时返回一个数组，将两组查询结果作为两个对象放到数组中，useQuery的返回结果和回调方法也分别放到对象中了。\n这种并行的操作，有点不好取出isLoading等数据状态。\n‍\n从属查询 在 API 查询中，经常会有通过一个关联 ID 查询相关的内容。比如：通过一个学生的邮箱，查询学生学习的课程，我们将以此为示例。\n先添加用户信息和关联课程信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 db.json { \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;p1@example.com\u0026#34;, \u0026#34;channelId\u0026#34;: \u0026#34;c1\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;p2@example.com\u0026#34;, \u0026#34;channelId\u0026#34;: \u0026#34;c2\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;p3@example.com\u0026#34;, \u0026#34;channelId\u0026#34;: \u0026#34;c3\u0026#34; } ], \u0026#34;channels\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;c1\u0026#34;, \u0026#34;courses\u0026#34;: [\u0026#34;Html\u0026#34;, \u0026#34;Css\u0026#34;, \u0026#34;Javascript\u0026#34;] }, { \u0026#34;id\u0026#34;: \u0026#34;c2\u0026#34;, \u0026#34;courses\u0026#34;: [\u0026#34;Node\u0026#34;, \u0026#34;Expess\u0026#34;, \u0026#34;Koa\u0026#34;] }, { \u0026#34;id\u0026#34;: \u0026#34;c3\u0026#34;, \u0026#34;courses\u0026#34;: [\u0026#34;React\u0026#34;, \u0026#34;Vue\u0026#34;, \u0026#34;Angular\u0026#34;] } ] } ‍\n然后添加对应的路由，添加页面Users。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // src/pages/Users/index.jsx import React, { useState } from \u0026#39;react\u0026#39; import { useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const getUserEmail = email =\u0026gt; axios(`http://localhost:4000/users/${email}`) const getCourses = channelId =\u0026gt; axios(`http://localhost:4000/channels/${channelId}`) const Users = () =\u0026gt; { const [email, setEmail] = useState(\u0026#39;p1@example.com\u0026#39;) const { data: user } = useQuery([\u0026#39;user\u0026#39;, email], () =\u0026gt; getUserEmail(email)) const channelId = user?.data.channelId const { data: courses } = useQuery([\u0026#39;courses\u0026#39;, channelId], () =\u0026gt; getCourses(channelId), { enabled: !!channelId }) return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; User:{\u0026#39; \u0026#39;} \u0026lt;select value={email} onChange={e =\u0026gt; setEmail(e.target.value)}\u0026gt; \u0026lt;option value=\u0026#39;p1@example.com\u0026#39;\u0026gt;p1\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;p2@example.com\u0026#39;\u0026gt;p2\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;p3@example.com\u0026#39;\u0026gt;p3\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Courses:{\u0026#39; \u0026#39;} {courses?.data?.courses.map((course, index) =\u0026gt; ( \u0026lt;span key={index} style={{ marginRight: \u0026#39;10px\u0026#39; }}\u0026gt; {course} \u0026lt;/span\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Users 先将用户的email作为查询条件。所以将几个用户信息做了一个受控的select​ 下拉框。可以选择用户，通过用户匹配对应的email。\n通过将email​ 的值，传入到第一个查询的useQuery中，把参数传入getUserEmail，获取到对应对学生channelId。\n然后再将channelId传入到第二个查询useQuery中，把参数传入getCourses，获取到学生对应的课程信息。通过配置enabled: !!channelId，达到依赖查询，只要channelId有值才会更新。\n这样就可以通过匹配user的邮箱来查询对应的课程。需要注意map的路径层级。\n‍\n‍\n初始化查询数据 主要用于当网络较慢时，通过查询缓存中的数据，优先展示缓存中的数据，而不是显示长时间的 loading 来影响查询体验。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // src/pages/RQSuperHeroPersonal/index.jsx import React from \u0026#39;react\u0026#39; import { useParams } from \u0026#39;react-router-dom\u0026#39; import { useQuery, QueryClient } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const RQSuperHeroPersonal = () =\u0026gt; { const queryClient = new QueryClient() const { heroId } = useParams() const fetcher = heroId =\u0026gt; axios(`http://localhost:4000/superheros/${heroId}`) const { data, isLoading, isError, error } = useQuery( [\u0026#39;rqsuperheropersonal\u0026#39;, heroId], () =\u0026gt; fetcher(heroId), { initialData: () =\u0026gt; { const hero = queryClient .getQueriesData([\u0026#39;rqsuperhero\u0026#39;]) ?.data?.find(hreo =\u0026gt; hero.id === parseInt(heroId)) if (hero) { return { data: hero } } else { return undefined } } } ) if (isLoading) { return \u0026lt;div\u0026gt;加载中\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } console.log(data) return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; {data?.data.id}. {data?.data.name} - {data?.data.alterEgo} - {data?.data.gender} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default RQSuperHeroPersonal 需要先引入QueryClient，在当前useQuery中配置initialData，让当前页面的查询可以使用单独的 QueryClient 配置。\n然后通过匹配缓存中的hero的id是否与查询参数中的heroId，将数据匹配给data​。\n‍\n分页 分页需要通过 ReactQuery 传递两个参数给到请求函数，一个是每页显示多少条数据的pageSize，一个是当前页码pageNumber。\njson-server​ 的两个分页参数是_limit和_page，分别对应这两个参数。\n使用useState做这两个参数对状态管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // src/pages/RQDCSuperHero/index.jsx import React, { useState } from \u0026#39;react\u0026#39; import { useQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const fetchHero = (limit, pageNumber) =\u0026gt; axios({ url: `http://localhost:4000/dcsuperheros`, params: { _limit: limit, _page: pageNumber } }) const RQDCSuperHero = () =\u0026gt; { const [pagination, setPagination] = useState({ pageSize: 2, pageNumber: 1 }) const { isLoading, isError, error, data, isFetching } = useQuery( [\u0026#39;dcheros\u0026#39;, pagination.pageSize, pagination.pageNumber], () =\u0026gt; fetchHero(pagination.pageSize, pagination.pageNumber), { keepPreviousData: true } ) if (isLoading) { return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; {data?.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setPagination({ ...pagination, pageNumber: pagination.pageNumber - 1 })} disabled={pagination.pageNumber === 1} \u0026gt; {isFetching ? \u0026#39;翻页中...\u0026#39; : \u0026#39;上一页\u0026#39;} \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setPagination({ ...pagination, pageNumber: pagination.pageNumber + 1 })} disabled={pagination.pageNumber === 5} \u0026gt; {isFetching ? \u0026#39;翻页中...\u0026#39; : \u0026#39;下一页\u0026#39;} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default RQDCSuperHero ReactQuery的第三个参数配置keepPreviousData: true，可以让之前浏览的页面缓存，后退时会通过缓存展示，提高浏览体验。\n‍\n无限分页 点击加载 这个会用到一个新的方法useInfiniteQuery，使用和 useQuery 类似，但有些许不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // src/pages/RQDCInfiniteSuperHero/index.jsx import React from \u0026#39;react\u0026#39; import { useInfiniteQuery } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const fetchHero = ({ pageParam = 1 }) =\u0026gt; axios({ url: `http://localhost:4000/dcsuperheros`, params: { _limit: 2, _page: pageParam } }) const RQDCInfiniteSuperHero = () =\u0026gt; { const { data, isLoading, isError, error, fetchNextPage, isFetchingNextPage, hasNextPage } = useInfiniteQuery([\u0026#39;infinitedcsuperhero\u0026#39;], fetchHero, { getNextPageParam: (lastPage, pages) =\u0026gt; { if (pages.length \u0026lt; 5) { return pages.length + 1 } else { return undefined } } }) if (isLoading) { return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;RQSuperHero\u0026lt;/h4\u0026gt; {data?.pages?.map(page =\u0026gt; page.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.id}. {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; )) )} {isFetchingNextPage ? \u0026#39;加载中...\u0026#39; : null} \u0026lt;button disabled={!hasNextPage} onClick={() =\u0026gt; fetchNextPage()}\u0026gt; 加载更多 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default RQDCInfiniteSuperHero 这里我们先看第三个参数里的getNextPageParam这个方法。\n当收到查询到的新数据时，此函数将接受无限分页数据列表的最后一页的数据lastPage和所有页面的数据allPages。\n然后这个方法，返回一个变量pageParam，这个变量作为最后一页的参数传递个查询函数。\n返回undefined，则表示没有下一页可用。\n‍\n所以当getNextPageParam这个方法，通过判断，是否达到最后一页了，来做递增计算。然后通过返回值pageParam，将翻页变量传递给fetchHero这个请求方法，进行数据翻页，加载到allPage，返回给页面。\n这里的坑：一定要用 ReactQuery 给的这个pageParam返回参数作为翻页的参数并且给定初始值。\n‍\n所以整个流程是通过useInfiniteQuery中返回的fetchNextPage方法来触发，第三个参数中的getNextPageParam，返回一个pageParam给到请求函数获取下一页的请求。返回到pages中，通过返回的data.pages就可以获取到所有加载的数据。\n‍\n上面这种判断方法比较局限，一般正式的 API 会返回数据总数，那么就可以计算出最后一页是多少。所以通常会通过判断lastPage是否是最后一页来做返回。以下为常用做法。\n1 2 3 4 5 6 7 getNextPageParam: (lastPage, allPages) =\u0026gt; { if (lastPage.page \u0026lt; lastPage.total_pages) { return lastPage + 1 } else { return undefined } } 然后需要注意返回的数据，是放到data的pages里，pages是一个数组，数组里包含每页的数据，数据是一个对象。所以在pages做map后，还需要在下级做个map获取每页的数据。这里相当于使用了reduce做了一个累加。有新的分页就push到数组中。后面我们还会使用一个插件，来增强这个体验，滚动到页面底部就自动加载。\n‍\n滚动底部自动加载 这里使用了SWAPI的数据，否则没有那么多数据加载。\n自动加载使用了一个插件 react-infinite-scroll-component。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // src/pages/SWInfinitePeople/index.jsx import React from \u0026#39;react\u0026#39; import { useInfiniteQuery } from \u0026#39;@tanstack/react-query\u0026#39; import InfiniteScroll from \u0026#39;react-infinite-scroll-component\u0026#39; import axios from \u0026#39;axios\u0026#39; const fetchPeople = url =\u0026gt; axios(url) const SWInfinitePeople = () =\u0026gt; { const initialUrl = \u0026#39;https://swapi.dev/api/people/?page=1\u0026#39; const { data, isLoading, isError, error, fetchNextPage, hasNextPage } = useInfiniteQuery( [\u0026#39;swip\u0026#39;], ({ pageParam = initialUrl }) =\u0026gt; fetchPeople(pageParam), { getNextPageParam: (lastPage, _allPages) =\u0026gt; { if (lastPage.data.next) { return lastPage.data.next } else { return undefined } } } ) if (isLoading) { return \u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt; } if (isError) { return \u0026lt;div\u0026gt;出错了 {error.message}\u0026lt;/div\u0026gt; } const dataLength = data.pages.reduce((acc, page) =\u0026gt; acc + page.data.results.length, 0) return ( \u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;The Star Wars\u0026lt;/h4\u0026gt; \u0026lt;InfiniteScroll dataLength={dataLength} next={fetchNextPage} hasMore={hasNextPage || false} loader={\u0026lt;div\u0026gt;加载中...\u0026lt;/div\u0026gt;} endMessage={\u0026lt;p\u0026gt;到底了\u0026lt;/p\u0026gt;} \u0026gt; {data?.pages?.map(page =\u0026gt; page.data.results.map(people =\u0026gt; \u0026lt;PeopleCard key={people.name} {...people} /\u0026gt;) )} \u0026lt;/InfiniteScroll\u0026gt; \u0026lt;/div\u0026gt; ) } const PeopleCard = ({ name, mass, skin_color, hair_color, height }) =\u0026gt; { return ( \u0026lt;div style={{ marginBottom: \u0026#39;16px\u0026#39;, padding: \u0026#39;0 24px 16px 24px\u0026#39;, border: \u0026#39;1px solid #ddd\u0026#39; }}\u0026gt; \u0026lt;h3\u0026gt; {name} - {mass} \u0026lt;/h3\u0026gt; \u0026lt;div\u0026gt;Hiehgt: {height}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;SkinColor: {skin_color}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;HairColor: {hair_color}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default SWInfinitePeople 因为 SWAPI 返回的的数据结果中有下一页next和上一页previous的完整路径，所以就直接拿到这个路径传给请求函数fetchPeople​。\n因为useInfiniteQuery的pageParam需要一个初始值，所以设置一个常量为initialUrl，放入第一页的URL​。\n然后再getNextPageParams中通过lastPage来获取下一页。传给pageParam。\n将单条数据提取出来，做成一个组件PeopleCard来渲染。将值传给组件就可以了。\nInfiniteScroll这里需要传入几个参数，前三个基本是必填参数。\ndataLength：数据的长度，我们通过 reduce 来计算下 pages 里面的 data 下 resultes 的数据长度之和，就是每次加载的数据长度。\nnext：到达底部后调用的函数。使用useInfiniteQuery返回的fetchNextPage就可以了。\nhasMore：是否还有更多数据，通过useInfiniteQuery返回的hasNextPage就可以了，如果返回undefined则显示false​。\nloader：是加载时显示的内容。\nendMessage：是加载到最底部显示的内容。\n‍\n修改 Mutations mutation主要用于创建、更新、修改、删除数据。ReactQuery 中使用useMutation这个钩子函数。\n‍\n简单添加 我们添加一组超级英雄到列表，将获取列表和添加都放到一个 hooks 里。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // src/hooks/useSuperHero.js import React from \u0026#39;react\u0026#39; import { useQuery, useMutation, QueryClient } from \u0026#39;@tanstack/react-query\u0026#39; import axios from \u0026#39;axios\u0026#39; const fetchHero = async () =\u0026gt; await axios(\u0026#39;http://localhost:4000/dcsuperheros\u0026#39;) const addHero = async hero =\u0026gt; await axios.post(\u0026#39;http://localhost:4000/dcsuperheros\u0026#39;, hero) export const useFetchSuperHero = (onSuccess, onError) =\u0026gt; { return useQuery([\u0026#39;fetch/superheros\u0026#39;], fetchHero, { onSuccess, onError }) } export const useAddSuperHero = hero =\u0026gt; { return useMutation(addHero) } 然后我们在到页面引用对应的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // src/pages/RQAddSuperHero.jsx import React, { useState } from \u0026#39;react\u0026#39; import { useFetchSuperHero, useAddSuperHero } from \u0026#39;@/hooks/useSuperHero.js\u0026#39; const RQAddSuperHero = () =\u0026gt; { const [name, setName] = useState(\u0026#39;\u0026#39;) const [alterEgo, setAlterEgo] = useState(\u0026#39;\u0026#39;) const onSuccess = data =\u0026gt; { console.log({ data }) } const onError = error =\u0026gt; { console.log({ error }) } const { data, isLoading, refetch } = useFetchSuperHero(onSuccess, onError) const { mutate } = useAddSuperHero() const handleSubmit = () =\u0026gt; { const hero = { name, alterEgo } mutate(hero) setName(\u0026#39;\u0026#39;) setAlterEgo(\u0026#39;\u0026#39;) } if (isLoading) { return \u0026lt;div\u0026gt;loading...\u0026lt;/div\u0026gt; } return ( \u0026lt;\u0026gt; \u0026lt;h2\u0026gt;RQAddSuperHero\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; value={name} onChange={e =\u0026gt; setName(e.target.value)} /\u0026gt; \u0026lt;input type=\u0026#39;text\u0026#39; value={alterEgo} onChange={e =\u0026gt; setAlterEgo(e.target.value)} /\u0026gt; \u0026lt;button onClick={handleSubmit}\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;button onClick={refetch}\u0026gt;刷新列表\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {data?.data.map(hero =\u0026gt; ( \u0026lt;div key={hero.id}\u0026gt; {hero.id}. {hero.name} - {hero.alterEgo} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ) } export default RQAddSuperHero useMutation这个方法返回一个mutate方法，这个就是用来接收提交的数据的方法。\nuseMutation同样可以返回data、isLoading、isError、error，但是在与useQuery同时使用时，需要注意修改为别名，以免变量名冲突。\nuseMutation的回调onSuccess和onError通常可以用于提交数据成功以后获取到 API 返回的数据如何操作。稍后我们看下如何在登录时使用。\n‍\n这里的坑：在将useQuery和useMutation放到同一个页面里使用时，会报 React Hooks 的错误，按照教程放到一个单独的 hooks 在引用才解决这个问题。\n‍\n登录示例 这里案例 API 使用的是RealWorld的项目 API，使用了formik作为表单数据接收和表单数据校验，使用useMutation提交数据到 API，拿到 APi 返回的用户信息，在onSuccess后将用户信息存入 store，跳转到首页。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 import React from \u0026#39;react\u0026#39; import { Link, useNavigate } from \u0026#39;react-router-dom\u0026#39; import { Formik, Form, Field, ErrorMessage } from \u0026#39;formik\u0026#39; import * as Yup from \u0026#39;yup\u0026#39; import { useMutation } from \u0026#39;@tanstack/react-query\u0026#39; import userApis from \u0026#39;@/service/apis/user\u0026#39; import { userAction } from \u0026#39;@/store/user\u0026#39; import { LoginWrap, FormError } from \u0026#39;./style\u0026#39; const Login = () =\u0026gt; { const navigate = useNavigate() const initialValues = { email: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; } const validationSchema = Yup.object({ email: Yup.string().email(\u0026#39;请输入正确的邮箱格式\u0026#39;).required(\u0026#39;请输入邮箱\u0026#39;), password: Yup.string().required(\u0026#39;请输入密码\u0026#39;) }) const onSubmit = values =\u0026gt; { mutate(values) } const { isLoading, isError, error, mutate } = useMutation([\u0026#39;user/login\u0026#39;], userApis.postLogin, { onSuccess: data =\u0026gt; { userAction.login({ token: data.token, user: { ...data } }) navigate(\u0026#39;/\u0026#39;) }, onError: error =\u0026gt; { console.log(JSON.stringify(error)) } }) return ( \u0026lt;LoginWrap\u0026gt; \u0026lt;div className=\u0026#39;page-container\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;log-block\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;log-sidebar\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;log-sidebar-text\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;Real World\u0026lt;/h2\u0026gt; 为了消除开发领域的知识不平等，建立了开放式协作的问答社区。欢迎你加入并贡献自己的智慧。 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;log-container\u0026#39;\u0026gt; \u0026lt;p className=\u0026#39;log-tips\u0026#39;\u0026gt; 还没有账号，去\u0026lt;Link to=\u0026#39;/register\u0026#39;\u0026gt;注册\u0026lt;/Link\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;div className=\u0026#39;log-text\u0026#39;\u0026gt; \u0026lt;h2\u0026gt;登录\u0026lt;/h2\u0026gt; \u0026lt;small\u0026gt;Real World Login\u0026lt;/small\u0026gt; {isError ? ( \u0026lt;ul className=\u0026#39;error-messages\u0026#39;\u0026gt; {Object.entries(error).map(([key, messages]) =\u0026gt; messages.map(message =\u0026gt; ( \u0026lt;li key={`${key} ${message}`}\u0026gt; {key} {message} \u0026lt;/li\u0026gt; )) )} \u0026lt;/ul\u0026gt; ) : null} \u0026lt;/div\u0026gt; \u0026lt;Formik initialValues={initialValues} onSubmit={onSubmit} validationSchema={validationSchema} \u0026gt; \u0026lt;Form className=\u0026#39;log-form\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;log-form-item\u0026#39;\u0026gt; \u0026lt;Field type=\u0026#39;text\u0026#39; name=\u0026#39;email\u0026#39; className=\u0026#39;log-form-input\u0026#39; placeholder=\u0026#39;请输入电子邮箱\u0026#39; /\u0026gt; \u0026lt;ErrorMessage name=\u0026#39;email\u0026#39; component={FormError} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;log-form-item\u0026#39;\u0026gt; \u0026lt;Field type=\u0026#39;password\u0026#39; name=\u0026#39;password\u0026#39; className=\u0026#39;log-form-input\u0026#39; placeholder=\u0026#39;请输入密码\u0026#39; /\u0026gt; \u0026lt;ErrorMessage name=\u0026#39;password\u0026#39; component={FormError} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#39;log-form-item\u0026#39;\u0026gt; \u0026lt;button className=\u0026#39;log-form-btn\u0026#39; type=\u0026#39;submit\u0026#39; disabled={isLoading \u0026amp;\u0026amp; true}\u0026gt; {isLoading ? \u0026#39;登录中...\u0026#39; : \u0026#39;登录\u0026#39;} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/Form\u0026gt; \u0026lt;/Formik\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/LoginWrap\u0026gt; ) } export default Login ‍\n主动查询失效 上面的示例中，我们查询后还需要通过点击按钮，通过useQuery的refetch​ 来触发列表刷新。\n在 ReactQuery 中可以使用QueryClient中的invalidateQueries方法可以主动标记查询过时，在通过useQuery查询数据，这时这会因为数据过时而主动重新获取数据。\n1 2 3 4 5 6 7 8 9 10 // sec/hooks/useSuperHero.js export const useAddSuperHero = () =\u0026gt; { const queryClient = new QueryClient() return useMutation(addHero, { onSuccess: () =\u0026gt; { queryClient.invalidateQueries([\u0026#39;super-heros\u0026#39;]) } }) } ‍\n更新缓存数据 通过上面的示例，提交超级英雄的表单后，会发起一个 201 的网络请求，然后返回一个所有数据的 200 响应。\n我们可以通过QueryClient中的 setQueryData 来直接更新查询的缓存数据，而不必浪费网络响应，节约资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // src/hooks/useSuperHero.js export const useAddSuperHero = () =\u0026gt; { const queryClient = new QueryClient() return useMutation(addHero, { onSuccess: () =\u0026gt; { // queryClient.invalidateQueries([\u0026#39;super-heros\u0026#39;]) queryClient.setQueryData([\u0026#39;super-heros\u0026#39;], oldQueryData =\u0026gt; { return { ...oldQueryData, data: [...oldQueryData.data, data.data] } }) } }) } ‍\n乐观更新 乐观更新其实也是种获取数据体验上的优化，如果能获取数据成功，就展示新获取的数据，如果没有获取数据成功，就展示缓存中的陈旧数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // src/hooks/useSuperHero.js export const useAddSuperHero = () =\u0026gt; { const queryClient = new QueryClient() return useMutation(addHero, { onMutate: async newHero =\u0026gt; { await queryClient.cancelQueries([\u0026#39;super-heros\u0026#39;]) const previousHeroData = queryClient.getQueryData([\u0026#39;super-heros\u0026#39;]) queryClient.setQueryData([\u0026#39;super-heros\u0026#39;], oldQueryData =\u0026gt; { return { ...oldQueryData, data: [...oldQueryData.data, { id: oldQueryData?.data?.length + 1, ...newHero }] } }) return { previousHeroData } }, onError: (_err, _newTodo, context) =\u0026gt; { queryClient.setQueryData([\u0026#39;super-heros\u0026#39;], context.previousHeroData) }, onSettled: () =\u0026gt; { queryClient.invalidateQueries([\u0026#39;super-heros\u0026#39;]) } }) } 使用乐观更新，就需要三个步骤：\n先使用onMutate在获取数据mutate调用时使用cancelQueries取消相关的查询。然后通过getQueryData拿到保存之前状态的数据快照。然后使用setQueryData执行乐观更新。返回具有具有快照数据的上下文对象{ previousHeroData }。\n如果修改失败onError，则使用onMutate返回的上下文进行回滚。\n使用onSettled来代替onSuccess，他表示在错误或成功之后的操作，通过主动查询失败重新获取数据。\n‍\n总结 ReactQuery 基本上能满足绝大部分的数据获取、提交的需求，同时简化数据获取的状态以及缓存的管理。上述内容基本满足业务的绝大部分需求，更多功能在遇到了再去查查官方文档。\n","date":"2022-10-21T14:43:34Z","permalink":"https://simfantasy.github.io/p/react-query%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"React Query学习笔记"}]